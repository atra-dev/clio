{"version":3,"sources":["../../../../src/lib/hris-backend.js","../../../../src/lib/invite-delivery.js","../../../../src/lib/security-notifications.js","../../../../src/lib/security-alert-delivery.js","../../../../src/lib/security-detection.js"],"sourcesContent":["import {\n  addDoc,\n  collection,\n  deleteField,\n  deleteDoc,\n  doc,\n  getDoc,\n  getDocs,\n  query,\n  updateDoc,\n  where,\n} from \"firebase/firestore/lite\";\nimport { getFirestoreDb, isFirestoreEnabled } from \"@/lib/firebase\";\nimport {\n  archiveUserAccount,\n  getLoginAccount,\n  inviteUserAccount,\n  listUserAccounts,\n  purgeDueArchivedUserAccounts,\n  revokeInviteById,\n  updateUserAccountRole,\n  updateUserAccountStatus,\n} from \"@/lib/user-accounts\";\nimport { deliverInviteEmail } from \"@/lib/invite-delivery\";\nimport { formatEmployeeName } from \"@/lib/name-utils\";\nimport { listAuditEvents } from \"@/lib/audit-log\";\n\nconst MAX_AUDIT_TRAIL_ITEMS = 80;\nconst DEFAULT_ARCHIVE_RETENTION_YEARS = 5;\nconst MAX_LIFECYCLE_CHECKLIST_ITEMS = 32;\nconst MAX_LIFECYCLE_EVIDENCE_ITEMS = 80;\nconst MAX_INCIDENT_EVIDENCE_ITEMS = 50;\nconst MAX_INCIDENT_FORENSIC_SAMPLES = 8;\nconst MAX_REFERENCE_LABEL_LENGTH = 72;\nconst MAX_REFERENCE_CATALOG_ITEMS = 256;\nconst ALLOWED_REFERENCE_KINDS = new Set([\"role\", \"department\"]);\nconst SYSTEM_REFERENCE_ROLES = [\n  { value: \"SUPER_ADMIN\", label: \"Super Admin\" },\n  { value: \"GRC\", label: \"GRC\" },\n  { value: \"HR\", label: \"HR\" },\n  { value: \"EA\", label: \"EA\" },\n  { value: \"EMPLOYEE_L1\", label: \"Employee (L1)\" },\n  { value: \"EMPLOYEE_L2\", label: \"Employee (L2)\" },\n  { value: \"EMPLOYEE_L3\", label: \"Employee (L3)\" },\n];\nconst SYSTEM_REFERENCE_DEPARTMENTS = [\n  \"Governance, Risk, and Compliance (GRC)\",\n  \"Research and Development (R&D)\",\n  \"Cyber Security Operations Center (CSOC)\",\n  \"Threat Intelligence (TI)\",\n];\nconst LIFECYCLE_ROLE_ALIAS = new Map([\n  [\"SUPER_ADMIN\", \"SUPER_ADMIN\"],\n  [\"SUPERADMIN\", \"SUPER_ADMIN\"],\n  [\"ADMIN\", \"SUPER_ADMIN\"],\n  [\"GRC\", \"GRC\"],\n  [\"HR\", \"HR\"],\n  [\"EA\", \"EA\"],\n  [\"EMPLOYEE\", \"EMPLOYEE_L1\"],\n  [\"EMPLOYEE_L1\", \"EMPLOYEE_L1\"],\n  [\"EMPLOYEE_L2\", \"EMPLOYEE_L2\"],\n  [\"EMPLOYEE_L3\", \"EMPLOYEE_L3\"],\n  [\"L1\", \"EMPLOYEE_L1\"],\n  [\"L2\", \"EMPLOYEE_L2\"],\n  [\"L3\", \"EMPLOYEE_L3\"],\n]);\n\nconst LIFECYCLE_WORKFLOW_TEMPLATES = {\n  onboarding: {\n    type: \"onboarding\",\n    category: \"Onboarding\",\n    stages: [\"Initiated\", \"Document Verification\", \"Access Provisioning\", \"Activation\"],\n    checklist: [\n      { id: \"profile-intake\", label: \"Collect employee profile and contacts\", required: true, slaHours: 12 },\n      { id: \"contract-check\", label: \"Validate contract and onboarding requirements\", required: true, slaHours: 24 },\n      { id: \"account-activation\", label: \"Activate employee account\", required: true, slaHours: 48 },\n    ],\n    approverRoles: [\"HR\", \"GRC\"],\n    slaHours: 72,\n  },\n  \"role-change\": {\n    type: \"role-change\",\n    category: \"Role Change\",\n    stages: [\"Initiated\", \"Approval Review\", \"Role Sync\", \"Completed\"],\n    checklist: [\n      { id: \"movement-justification\", label: \"Attach role-change justification\", required: true, slaHours: 24 },\n      { id: \"effective-date-review\", label: \"Validate effective date and scope\", required: true, slaHours: 24 },\n      { id: \"permission-sync\", label: \"Apply role and permission sync\", required: true, slaHours: 48 },\n    ],\n    approverRoles: [\"HR\", \"GRC\"],\n    slaHours: 96,\n  },\n  disciplinary: {\n    type: \"disciplinary\",\n    category: \"Disciplinary\",\n    stages: [\"Case Opened\", \"Investigation\", \"Decision\", \"Closed\"],\n    checklist: [\n      { id: \"incident-report\", label: \"Record incident report\", required: true, slaHours: 24 },\n      { id: \"evidence-review\", label: \"Attach and review case evidence\", required: true, slaHours: 48 },\n      { id: \"decision-log\", label: \"Finalize disciplinary decision\", required: true, slaHours: 72 },\n    ],\n    approverRoles: [\"HR\", \"GRC\"],\n    slaHours: 120,\n  },\n  offboarding: {\n    type: \"offboarding\",\n    category: \"Offboarding\",\n    stages: [\"Initiated\", \"Clearance\", \"Access Revocation\", \"Archived\"],\n    checklist: [\n      { id: \"clearance-init\", label: \"Start employee clearance checklist\", required: true, slaHours: 12 },\n      { id: \"access-revoked\", label: \"Disable account and revoke access\", required: true, slaHours: 24 },\n      { id: \"archive-records\", label: \"Archive employee records\", required: true, slaHours: 48 },\n    ],\n    approverRoles: [\"HR\", \"GRC\"],\n    slaHours: 72,\n  },\n};\n\nconst LIFECYCLE_PRIVILEGED_TARGET_ROLES = new Set([\"SUPER_ADMIN\", \"GRC\", \"HR\", \"EA\"]);\nconst LIFECYCLE_ASSIGNABLE_BY_PRIVILEGED = new Set([\"EMPLOYEE_L1\", \"EMPLOYEE_L2\", \"EMPLOYEE_L3\"]);\nconst LIFECYCLE_ASSIGNABLE_BY_GRC = new Set([\"GRC\", \"HR\", \"EA\", \"EMPLOYEE_L1\", \"EMPLOYEE_L2\", \"EMPLOYEE_L3\"]);\nconst INCIDENT_SEVERITY_LEVELS = [\"Low\", \"Medium\", \"High\", \"Critical\"];\nconst INCIDENT_STATUS_VALUES = [\"Open\", \"Containment\", \"Investigating\", \"Escalated\", \"Regulatory Review\", \"Resolved\", \"Closed\"];\nconst INCIDENT_CONTAINMENT_STATUS_VALUES = [\"Not Started\", \"In Progress\", \"Contained\"];\nconst INCIDENT_IMPACT_STATUS_VALUES = [\"Pending\", \"In Progress\", \"Completed\"];\nconst INCIDENT_TYPE_VALUES = [\n  \"Unauthorized Access\",\n  \"Data Exposure\",\n  \"Credential Compromise\",\n  \"Insider Misuse\",\n  \"Malware / Ransomware\",\n  \"Policy Violation\",\n  \"System Misconfiguration\",\n  \"Other\",\n];\nconst DEFAULT_INCIDENT_EVIDENCE_MAX_BYTES = 10 * 1024 * 1024;\nconst DEFAULT_INCIDENT_EVIDENCE_ALLOWED_EXTENSIONS = new Set([\n  \"pdf\",\n  \"png\",\n  \"jpg\",\n  \"jpeg\",\n  \"webp\",\n  \"doc\",\n  \"docx\",\n  \"xls\",\n  \"xlsx\",\n  \"csv\",\n  \"txt\",\n]);\nconst DEFAULT_INCIDENT_EVIDENCE_ALLOWED_MIME_TYPES = new Set([\n  \"application/pdf\",\n  \"image/png\",\n  \"image/jpeg\",\n  \"image/webp\",\n  \"application/msword\",\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n  \"application/vnd.ms-excel\",\n  \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n  \"text/csv\",\n  \"text/plain\",\n]);\n\nfunction env(name, fallback) {\n  const value = String(process.env[name] || \"\").trim();\n  return value || fallback;\n}\n\nfunction parseBooleanEnv(name, fallbackValue = false) {\n  const raw = String(process.env[name] || \"\")\n    .trim()\n    .toLowerCase();\n  if (!raw) {\n    return fallbackValue;\n  }\n  return raw === \"true\" || raw === \"1\" || raw === \"yes\";\n}\n\nfunction parseCsvSet(value, fallbackSet) {\n  const normalized = String(value || \"\")\n    .split(\",\")\n    .map((item) => String(item || \"\").trim().toLowerCase())\n    .filter(Boolean);\n  if (normalized.length === 0) {\n    return new Set([...fallbackSet]);\n  }\n  return new Set(normalized);\n}\n\nfunction parseIntegerEnv(name, fallbackValue, { min = 1, max = Number.MAX_SAFE_INTEGER } = {}) {\n  const parsed = Number.parseInt(String(process.env[name] || \"\").trim(), 10);\n  if (!Number.isFinite(parsed)) {\n    return fallbackValue;\n  }\n  return Math.min(max, Math.max(min, parsed));\n}\n\nfunction getIncidentEvidenceValidationConfig() {\n  return {\n    maxBytes: parseIntegerEnv(\"CLIO_INCIDENT_EVIDENCE_MAX_BYTES\", DEFAULT_INCIDENT_EVIDENCE_MAX_BYTES, {\n      min: 128 * 1024,\n      max: 50 * 1024 * 1024,\n    }),\n    allowedExtensions: parseCsvSet(\n      process.env.CLIO_INCIDENT_EVIDENCE_ALLOWED_EXTENSIONS,\n      DEFAULT_INCIDENT_EVIDENCE_ALLOWED_EXTENSIONS,\n    ),\n    allowedMimeTypes: parseCsvSet(\n      process.env.CLIO_INCIDENT_EVIDENCE_ALLOWED_MIME_TYPES,\n      DEFAULT_INCIDENT_EVIDENCE_ALLOWED_MIME_TYPES,\n    ),\n  };\n}\n\nfunction isInviteDeliveryRequired() {\n  const defaultRequired = process.env.NODE_ENV === \"production\";\n  return parseBooleanEnv(\"CLIO_REQUIRE_EMAIL_DELIVERY\", defaultRequired);\n}\n\nfunction extractDeliveryErrorInfo(reason) {\n  const normalized = String(reason || \"\").trim();\n  if (normalized.startsWith(\"email_delivery_failed:\")) {\n    return {\n      code: \"email_delivery_failed\",\n      providerMessage: normalized.slice(\"email_delivery_failed:\".length).trim(),\n    };\n  }\n\n  return {\n    code: normalized || \"email_delivery_failed\",\n    providerMessage: \"\",\n  };\n}\n\nfunction nowIso() {\n  return new Date().toISOString();\n}\n\nfunction addYearsToIso(isoTimestamp, years) {\n  const base = new Date(isoTimestamp);\n  if (Number.isNaN(base.getTime())) {\n    const fallback = new Date();\n    fallback.setUTCFullYear(fallback.getUTCFullYear() + years);\n    return fallback.toISOString();\n  }\n  base.setUTCFullYear(base.getUTCFullYear() + years);\n  return base.toISOString();\n}\n\nfunction getArchiveRetentionYears() {\n  const raw = Number.parseInt(String(process.env.CLIO_RETENTION_YEARS || \"\").trim(), 10);\n  if (!Number.isFinite(raw) || raw < 1) {\n    return DEFAULT_ARCHIVE_RETENTION_YEARS;\n  }\n  return Math.min(raw, 25);\n}\n\nfunction asString(value, fallback = \"\") {\n  const normalized = String(value ?? \"\").trim();\n  return normalized || fallback;\n}\n\nfunction normalizeText(value) {\n  return String(value || \"\")\n    .trim()\n    .toLowerCase();\n}\n\nfunction normalizeEmail(value) {\n  return String(value || \"\").trim().toLowerCase();\n}\n\nfunction normalizeRoleKey(value) {\n  return String(value || \"\")\n    .trim()\n    .toUpperCase()\n    .replace(/[^A-Z0-9]+/g, \"_\")\n    .replace(/^_+|_+$/g, \"\");\n}\n\nfunction normalizeReferenceKind(value) {\n  const normalized = String(value || \"\")\n    .trim()\n    .toLowerCase();\n  return ALLOWED_REFERENCE_KINDS.has(normalized) ? normalized : \"\";\n}\n\nfunction normalizeReferenceLabel(value) {\n  return String(value || \"\")\n    .trim()\n    .replace(/\\s+/g, \" \");\n}\n\nfunction normalizeDepartmentKey(value) {\n  return String(value || \"\")\n    .trim()\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-+|-+$/g, \"\");\n}\n\nfunction normalizeReferenceKey(kind, value) {\n  const normalizedKind = normalizeReferenceKind(kind);\n  if (!normalizedKind) {\n    return \"\";\n  }\n  if (normalizedKind === \"role\") {\n    return normalizeRoleKey(value);\n  }\n  return normalizeDepartmentKey(value);\n}\n\nfunction buildSystemReferenceCatalog() {\n  const roles = SYSTEM_REFERENCE_ROLES.map((entry) => {\n    const value = asString(entry.value);\n    const label = asString(entry.label, value);\n    const key = normalizeReferenceKey(\"role\", value || label);\n    return {\n      id: `system-role-${key}`,\n      kind: \"role\",\n      key,\n      value,\n      label,\n      isSystem: true,\n      createdAt: \"\",\n      updatedAt: \"\",\n    };\n  });\n\n  const departments = SYSTEM_REFERENCE_DEPARTMENTS.map((entry) => {\n    const label = asString(entry);\n    const key = normalizeReferenceKey(\"department\", label);\n    return {\n      id: `system-department-${key}`,\n      kind: \"department\",\n      key,\n      value: label,\n      label,\n      isSystem: true,\n      createdAt: \"\",\n      updatedAt: \"\",\n    };\n  });\n\n  return {\n    roles,\n    departments,\n  };\n}\n\nfunction sortReferenceCatalogItems(items) {\n  return [...items].sort((left, right) => {\n    if (Boolean(left?.isSystem) !== Boolean(right?.isSystem)) {\n      return left?.isSystem ? -1 : 1;\n    }\n    return String(left?.label || \"\").localeCompare(String(right?.label || \"\"), undefined, {\n      sensitivity: \"base\",\n    });\n  });\n}\n\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [];\n}\n\nfunction asObject(value, fallback = {}) {\n  if (value && typeof value === \"object\" && !Array.isArray(value)) {\n    return value;\n  }\n  return fallback;\n}\n\nfunction asBoolean(value, fallback = false) {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value !== 0;\n  }\n  if (typeof value === \"string\") {\n    const normalized = value.trim().toLowerCase();\n    if (!normalized) {\n      return fallback;\n    }\n    if ([\"true\", \"1\", \"yes\", \"y\", \"on\"].includes(normalized)) {\n      return true;\n    }\n    if ([\"false\", \"0\", \"no\", \"n\", \"off\"].includes(normalized)) {\n      return false;\n    }\n  }\n  return fallback;\n}\n\nfunction normalizeEmployeeDocumentsPayload(documents, { actorEmail, now } = {}) {\n  const fallbackActor = normalizeEmail(actorEmail) || \"system@gmail.com\";\n  const fallbackAt = asString(now, nowIso());\n  return asArray(documents)\n    .map((entry, index) => {\n      const source = asObject(entry, {});\n      const uploadedAt = asString(source.uploadedAt, fallbackAt);\n      const uploadedBy = normalizeEmail(source.uploadedBy || fallbackActor) || fallbackActor;\n      const sizeRaw = Number(source.sizeBytes);\n      return {\n        id: asString(source.id),\n        name: asString(source.name, \"Employee Document\"),\n        type: asString(source.type, \"General\"),\n        ref: asString(source.ref),\n        storagePath: asString(source.storagePath),\n        contentType: asString(source.contentType),\n        sizeBytes: Number.isFinite(sizeRaw) && sizeRaw >= 0 ? sizeRaw : 0,\n        uploadedAt,\n        uploadedBy,\n        order: Number.isFinite(Number(source.order)) ? Number(source.order) : index,\n      };\n    })\n    .filter((entry) => entry.ref || entry.name);\n}\n\nasync function listEmployeeDocumentSubcollectionById(recordId, { db } = {}) {\n  const normalizedId = asString(recordId);\n  if (!normalizedId) {\n    return [];\n  }\n\n  const database = db || getDbOrThrow();\n  const employeesCollection = getCollectionName(\"employees\");\n  const subcollectionName = getEmployeeDocumentsSubcollectionName();\n  const snapshot = await getDocs(collection(database, employeesCollection, normalizedId, subcollectionName));\n  return snapshot.docs\n    .map((item, index) => {\n      const payload = normalizeEmployeeDocumentsPayload([item.data()], {\n        now: nowIso(),\n      })[0];\n      if (!payload) {\n        return null;\n      }\n      return {\n        ...payload,\n        id: item.id,\n        recordId: item.id,\n        order: Number.isFinite(Number(payload.order)) ? Number(payload.order) : index,\n      };\n    })\n    .filter(Boolean)\n    .sort((left, right) => {\n      const leftTime = new Date(left.uploadedAt || 0).getTime();\n      const rightTime = new Date(right.uploadedAt || 0).getTime();\n      if (Number.isFinite(leftTime) && Number.isFinite(rightTime) && rightTime !== leftTime) {\n        return rightTime - leftTime;\n      }\n      return Number(left.order || 0) - Number(right.order || 0);\n    });\n}\n\nasync function deleteEmployeeDocumentSubcollectionById(recordId, { db } = {}) {\n  const normalizedId = asString(recordId);\n  if (!normalizedId) {\n    return 0;\n  }\n\n  const database = db || getDbOrThrow();\n  const employeesCollection = getCollectionName(\"employees\");\n  const subcollectionName = getEmployeeDocumentsSubcollectionName();\n  const snapshot = await getDocs(collection(database, employeesCollection, normalizedId, subcollectionName));\n  let removed = 0;\n  for (const item of snapshot.docs) {\n    await deleteDoc(item.ref);\n    removed += 1;\n  }\n  return removed;\n}\n\nasync function replaceEmployeeDocumentSubcollectionById(recordId, documents, { actorEmail, db } = {}) {\n  const normalizedId = asString(recordId);\n  if (!normalizedId) {\n    throw new Error(\"invalid_record_id\");\n  }\n\n  const database = db || getDbOrThrow();\n  const employeesCollection = getCollectionName(\"employees\");\n  const subcollectionName = getEmployeeDocumentsSubcollectionName();\n  const collectionRef = collection(database, employeesCollection, normalizedId, subcollectionName);\n  const normalizedDocuments = normalizeEmployeeDocumentsPayload(documents, {\n    actorEmail,\n    now: nowIso(),\n  });\n\n  await deleteEmployeeDocumentSubcollectionById(normalizedId, { db: database });\n  const created = [];\n  for (const item of normalizedDocuments) {\n    const payload = {\n      name: item.name,\n      type: item.type,\n      ref: item.ref,\n      storagePath: item.storagePath,\n      contentType: item.contentType,\n      sizeBytes: item.sizeBytes,\n      uploadedAt: item.uploadedAt,\n      uploadedBy: item.uploadedBy,\n      order: item.order,\n    };\n    const createdRef = await addDoc(collectionRef, payload);\n    created.push({\n      ...payload,\n      id: createdRef.id,\n      recordId: createdRef.id,\n    });\n  }\n\n  return created\n    .sort((left, right) => new Date(right.uploadedAt || 0).getTime() - new Date(left.uploadedAt || 0).getTime())\n    .map((item, index) => ({\n      ...item,\n      order: Number.isFinite(Number(item.order)) ? Number(item.order) : index,\n    }));\n}\n\nfunction resolveEmployeeDocumentsForResponse(record, subcollectionDocs = []) {\n  if (Array.isArray(subcollectionDocs) && subcollectionDocs.length > 0) {\n    return subcollectionDocs;\n  }\n  return normalizeEmployeeDocumentsPayload(record?.documents, {\n    actorEmail: record?.updatedBy || record?.createdBy,\n    now: record?.updatedAt || record?.createdAt || nowIso(),\n  });\n}\n\nfunction withEmployeeDocuments(record, documents = []) {\n  const normalized = Array.isArray(documents) ? documents : [];\n  return {\n    ...record,\n    documents: normalized,\n    documentsCount: normalized.length,\n  };\n}\n\nasync function resolveAndMigrateEmployeeDocuments(record, { db } = {}) {\n  if (!record?.id) {\n    return [];\n  }\n\n  const documentsFromSubcollection = await listEmployeeDocumentSubcollectionById(record.id, { db });\n  if (documentsFromSubcollection.length > 0) {\n    return documentsFromSubcollection;\n  }\n\n  const legacyDocuments = resolveEmployeeDocumentsForResponse(record, []);\n  if (legacyDocuments.length === 0) {\n    return [];\n  }\n\n  const migrated = await replaceEmployeeDocumentSubcollectionById(record.id, legacyDocuments, {\n    actorEmail: record.updatedBy || record.createdBy,\n    db,\n  });\n  await clearLegacyEmployeeDocumentsField(record.id, {\n    documentsCount: migrated.length,\n    db,\n  });\n  return migrated;\n}\n\nasync function clearLegacyEmployeeDocumentsField(recordId, { documentsCount, db } = {}) {\n  const normalizedId = asString(recordId);\n  if (!normalizedId) {\n    return;\n  }\n\n  const database = db || getDbOrThrow();\n  const patch = {\n    documents: deleteField(),\n  };\n  if (Number.isFinite(Number(documentsCount))) {\n    patch.documentsCount = Math.max(0, Number(documentsCount));\n  }\n  await updateDoc(doc(database, getCollectionName(\"employees\"), normalizedId), patch);\n}\n\nfunction toEmployeeDocumentMergeKey(document) {\n  const storagePath = asString(document?.storagePath);\n  if (storagePath) {\n    return `path:${storagePath}`;\n  }\n  const ref = asString(document?.ref);\n  if (ref) {\n    return `ref:${ref}`;\n  }\n  return `fallback:${asString(document?.name)}|${Number.isFinite(Number(document?.sizeBytes)) ? Number(document.sizeBytes) : 0}|${asString(\n    document?.uploadedAt,\n  )}`;\n}\n\nfunction mergeEmployeeDocuments(existingDocuments, incomingDocuments) {\n  const merged = [];\n  const seen = new Set();\n  let addedCount = 0;\n\n  const pushUnique = (entry, trackAdded = false) => {\n    const normalized = normalizeEmployeeDocumentsPayload([entry], {\n      actorEmail: entry?.uploadedBy,\n      now: entry?.uploadedAt,\n    })[0];\n    if (!normalized) {\n      return;\n    }\n    const key = toEmployeeDocumentMergeKey(normalized);\n    if (seen.has(key)) {\n      return;\n    }\n    seen.add(key);\n    merged.push(normalized);\n    if (trackAdded) {\n      addedCount += 1;\n    }\n  };\n\n  asArray(existingDocuments).forEach((entry) => pushUnique(entry, false));\n  asArray(incomingDocuments).forEach((entry) => pushUnique(entry, true));\n\n  return {\n    merged,\n    addedCount,\n  };\n}\n\nfunction toOnboardingEvidenceDocuments(evidence, actorEmail) {\n  const now = nowIso();\n  const mapped = asArray(evidence).map((item) => {\n    const source = asObject(item, {});\n    return {\n      id: asString(source.id),\n      name: asString(source.name, \"Onboarding Document\"),\n      type: asString(source.type, \"Onboarding\"),\n      ref: asString(source.ref),\n      storagePath: asString(source.storagePath),\n      contentType: asString(source.contentType),\n      sizeBytes: Number.isFinite(Number(source.sizeBytes)) ? Number(source.sizeBytes) : 0,\n      uploadedAt: asString(source.uploadedAt, now),\n      uploadedBy: asString(source.uploadedBy, actorEmail),\n    };\n  });\n  return normalizeEmployeeDocumentsPayload(mapped, {\n    actorEmail,\n    now,\n  });\n}\n\nasync function syncOnboardingEvidenceToEmployeeDocuments(record, actorEmail) {\n  const category = asString(record?.category).toLowerCase();\n  if (!category.includes(\"onboarding\")) {\n    return {\n      synced: false,\n      addedCount: 0,\n    };\n  }\n\n  const employeeEmail = normalizeEmail(record?.employeeEmail);\n  if (!employeeEmail) {\n    return {\n      synced: false,\n      addedCount: 0,\n    };\n  }\n\n  const onboardingDocuments = toOnboardingEvidenceDocuments(record?.evidence, actorEmail);\n  if (onboardingDocuments.length === 0) {\n    return {\n      synced: false,\n      addedCount: 0,\n    };\n  }\n\n  const employeeRows = await listCollectionRecords(getCollectionName(\"employees\"), {\n    filterField: \"email\",\n    filterValue: employeeEmail,\n  });\n  const employeeRecord = employeeRows[0];\n  if (!employeeRecord?.id) {\n    return {\n      synced: false,\n      addedCount: 0,\n    };\n  }\n\n  const existingDocuments = await resolveAndMigrateEmployeeDocuments(employeeRecord);\n  const { merged, addedCount } = mergeEmployeeDocuments(existingDocuments, onboardingDocuments);\n  if (addedCount <= 0) {\n    return {\n      synced: false,\n      addedCount: 0,\n    };\n  }\n\n  const syncedDocuments = await replaceEmployeeDocumentSubcollectionById(employeeRecord.id, merged, {\n    actorEmail,\n  });\n  await clearLegacyEmployeeDocumentsField(employeeRecord.id, {\n    documentsCount: syncedDocuments.length,\n  });\n\n  return {\n    synced: true,\n    addedCount,\n    documentsCount: syncedDocuments.length,\n    employeeRecordId: employeeRecord.id,\n  };\n}\n\nasync function collectOnboardingEvidenceDocumentsByEmployeeEmail(employeeEmail, actorEmail) {\n  const normalizedEmail = normalizeEmail(employeeEmail);\n  if (!normalizedEmail) {\n    return [];\n  }\n\n  const lifecycleRows = await listCollectionRecords(getCollectionName(\"lifecycle\"), {\n    filterField: \"employeeEmail\",\n    filterValue: normalizedEmail,\n  });\n\n  const onboardingEvidenceDocuments = lifecycleRows\n    .filter((row) => asString(row?.category).toLowerCase().includes(\"onboarding\"))\n    .flatMap((row) => toOnboardingEvidenceDocuments(row?.evidence, actorEmail));\n\n  return mergeEmployeeDocuments([], onboardingEvidenceDocuments).merged;\n}\n\nfunction composeEmployeeName({ firstName, middleName, lastName, suffix, fallback }) {\n  return formatEmployeeName({\n    firstName: asString(firstName),\n    middleName: asString(middleName),\n    lastName: asString(lastName),\n    suffix: asString(suffix),\n    fallback: asString(fallback),\n    fallbackLabel: \"Employee\",\n  });\n}\n\nfunction normalizeLifecycleType(value) {\n  const normalized = String(value || \"\")\n    .trim()\n    .toLowerCase();\n  if (!normalized) {\n    return \"onboarding\";\n  }\n  if (normalized.includes(\"role\") || normalized.includes(\"promotion\")) {\n    return \"role-change\";\n  }\n  if (normalized.includes(\"disciplin\")) {\n    return \"disciplinary\";\n  }\n  if (normalized.includes(\"offboard\") || normalized.includes(\"resign\") || normalized.includes(\"terminate\")) {\n    return \"offboarding\";\n  }\n  if (normalized.includes(\"onboard\")) {\n    return \"onboarding\";\n  }\n  return \"onboarding\";\n}\n\nfunction getLifecycleTemplateByCategory(category) {\n  const type = normalizeLifecycleType(category);\n  return LIFECYCLE_WORKFLOW_TEMPLATES[type] || LIFECYCLE_WORKFLOW_TEMPLATES.onboarding;\n}\n\nfunction addHoursToIso(isoValue, hours) {\n  const timestamp = Number.isFinite(Number(hours)) ? Number(hours) : 0;\n  const base = new Date(isoValue || nowIso());\n  if (Number.isNaN(base.getTime())) {\n    return nowIso();\n  }\n  base.setTime(base.getTime() + Math.max(0, timestamp) * 60 * 60 * 1000);\n  return base.toISOString();\n}\n\nfunction normalizeRoleId(value) {\n  return String(value || \"\")\n    .trim()\n    .toUpperCase()\n    .replace(/[^A-Z0-9_]+/g, \"\");\n}\n\nfunction normalizeDecision(value) {\n  const normalized = String(value || \"\")\n    .trim()\n    .toLowerCase();\n  if (normalized === \"approve\" || normalized === \"approved\") {\n    return \"approved\";\n  }\n  if (normalized === \"reject\" || normalized === \"rejected\") {\n    return \"rejected\";\n  }\n  return \"\";\n}\n\nfunction buildChecklistFromTemplate(template, { atIso }) {\n  return asArray(template?.checklist)\n    .slice(0, MAX_LIFECYCLE_CHECKLIST_ITEMS)\n    .map((task, index) => {\n      const id = asString(task?.id, `task-${index + 1}`);\n      const slaHours = Number.parseInt(String(task?.slaHours || \"\"), 10);\n      return {\n        id,\n        label: asString(task?.label, id),\n        required: task?.required !== false,\n        status: \"Pending\",\n        dueAt: addHoursToIso(atIso, Number.isFinite(slaHours) && slaHours > 0 ? slaHours : 24),\n        completedAt: \"\",\n        completedBy: \"\",\n      };\n    });\n}\n\nfunction mergeChecklistWithTemplate(baseChecklist, templateChecklist) {\n  const existing = new Map();\n  asArray(baseChecklist).forEach((task) => {\n    const key = asString(task?.id);\n    if (key) {\n      existing.set(key, task);\n    }\n  });\n\n  return templateChecklist.map((task) => {\n    const previous = existing.get(task.id);\n    if (!previous) {\n      return task;\n    }\n    return {\n      ...task,\n      status: asString(previous.status, task.status),\n      dueAt: asString(previous.dueAt, task.dueAt),\n      completedAt: asString(previous.completedAt),\n      completedBy: asString(previous.completedBy),\n    };\n  });\n}\n\nfunction buildApprovalChain(requiredRoles, existingChain) {\n  const existingByRole = new Map();\n  asArray(existingChain).forEach((entry) => {\n    const role = normalizeRoleId(entry?.role);\n    if (role) {\n      existingByRole.set(role, entry);\n    }\n  });\n\n  return requiredRoles.map((role, index) => {\n    const previous = existingByRole.get(role);\n    return {\n      order: index + 1,\n      role,\n      status: asString(previous?.status, \"Pending\"),\n      decidedAt: asString(previous?.decidedAt),\n      decidedBy: asString(previous?.decidedBy),\n      note: asString(previous?.note),\n    };\n  });\n}\n\nfunction resolveApprovalState(approvalChain) {\n  const chain = asArray(approvalChain);\n  if (chain.length === 0) {\n    return \"Not Required\";\n  }\n  if (chain.some((step) => normalizeText(step?.status) === \"rejected\")) {\n    return \"Rejected\";\n  }\n  if (chain.length > 0 && chain.every((step) => normalizeText(step?.status) === \"approved\")) {\n    return \"Approved\";\n  }\n  return \"Pending\";\n}\n\nfunction summarizeChecklistProgress(checklist) {\n  const requiredTasks = checklist.filter((task) => task.required !== false);\n  const completedRequired = requiredTasks.filter((task) => normalizeText(task.status) === \"completed\").length;\n  const totalRequired = requiredTasks.length;\n  return {\n    completedRequired,\n    totalRequired,\n    percent: totalRequired === 0 ? 0 : Math.round((completedRequired / totalRequired) * 100),\n  };\n}\n\nfunction sanitizeWorkflowStageIndex(stageIndex, stagesLength) {\n  const parsed = Number.parseInt(String(stageIndex ?? \"\"), 10);\n  if (!Number.isFinite(parsed)) {\n    return 0;\n  }\n  return Math.max(0, Math.min(parsed, Math.max(0, stagesLength - 1)));\n}\n\nfunction resolveRequiredApproverRoles() {\n  return [];\n}\n\nfunction validateLifecycleTargetRolePermission({ actorRole, targetRole }) {\n  if (!targetRole) {\n    return;\n  }\n\n  const normalizedActorRole = normalizeRoleId(actorRole);\n  const normalizedTargetRole = normalizeRoleId(targetRole);\n\n  if (normalizedActorRole === \"SUPER_ADMIN\") {\n    return;\n  }\n\n  if (normalizedActorRole === \"GRC\") {\n    if (normalizedTargetRole === \"SUPER_ADMIN\") {\n      throw new Error(\"forbidden_target_role\");\n    }\n    if (!LIFECYCLE_ASSIGNABLE_BY_GRC.has(normalizedTargetRole)) {\n      throw new Error(\"invalid_target_role\");\n    }\n    return;\n  }\n\n  if (normalizedActorRole === \"HR\" || normalizedActorRole === \"EA\") {\n    if (!LIFECYCLE_ASSIGNABLE_BY_PRIVILEGED.has(normalizedTargetRole)) {\n      throw new Error(\"forbidden_target_role\");\n    }\n    return;\n  }\n\n  if (LIFECYCLE_PRIVILEGED_TARGET_ROLES.has(normalizedTargetRole)) {\n    throw new Error(\"forbidden_target_role\");\n  }\n\n  if (!LIFECYCLE_ASSIGNABLE_BY_PRIVILEGED.has(normalizedTargetRole)) {\n    throw new Error(\"invalid_target_role\");\n  }\n}\n\nfunction buildInitialLifecycleWorkflow({\n  template,\n  baseWorkflow,\n  requiredApprovers,\n  atIso,\n  actorEmail,\n}) {\n  const templateChecklist = buildChecklistFromTemplate(template, { atIso });\n  const checklist = mergeChecklistWithTemplate(baseWorkflow?.checklist, templateChecklist);\n  const approvalChain = buildApprovalChain(requiredApprovers, baseWorkflow?.approvalChain);\n  const stages = asArray(template?.stages).map((stage) => asString(stage)).filter(Boolean);\n  const stageIndex = sanitizeWorkflowStageIndex(baseWorkflow?.stageIndex ?? 0, stages.length);\n  const stage = asString(stages[stageIndex], \"Initiated\");\n  const stageHistory = appendTrail(baseWorkflow?.stageHistory, {\n    at: atIso,\n    by: actorEmail,\n    stage,\n  });\n  const progress = summarizeChecklistProgress(checklist);\n\n  return {\n    type: asString(template?.type, \"onboarding\"),\n    stageIndex,\n    stage,\n    stages,\n    checklist,\n    stageHistory,\n    approvalChain,\n    approvalState: resolveApprovalState(approvalChain),\n    progress,\n    slaDueAt: asString(baseWorkflow?.slaDueAt, addHoursToIso(atIso, Number.parseInt(String(template?.slaHours || 72), 10))),\n    slaBreached: false,\n    updatedAt: atIso,\n  };\n}\n\nfunction applyLifecycleWorkflowAction({\n  workflow,\n  evidence,\n  action,\n  actorEmail,\n  atIso,\n}) {\n  const nextWorkflow = {\n    ...workflow,\n    checklist: asArray(workflow.checklist).map((task) => ({ ...task })),\n    stageHistory: asArray(workflow.stageHistory).map((entry) => ({ ...entry })),\n  };\n  let nextEvidence = asArray(evidence).map((item) => ({ ...item }));\n  const actionType = normalizeText(action?.type);\n\n  if (!actionType) {\n    return {\n      workflow: nextWorkflow,\n      evidence: nextEvidence,\n    };\n  }\n\n  if (actionType === \"toggle-task\") {\n    const taskId = asString(action?.taskId);\n    if (!taskId) {\n      throw new Error(\"invalid_workflow_action\");\n    }\n\n    let matched = false;\n    nextWorkflow.checklist = nextWorkflow.checklist.map((task) => {\n      if (task.id !== taskId) {\n        return task;\n      }\n      matched = true;\n      const completed = Boolean(action?.completed);\n      return {\n        ...task,\n        status: completed ? \"Completed\" : \"Pending\",\n        completedAt: completed ? atIso : \"\",\n        completedBy: completed ? actorEmail : \"\",\n      };\n    });\n    if (!matched) {\n      throw new Error(\"invalid_workflow_action\");\n    }\n  } else if (actionType === \"set-stage\") {\n    const nextIndex = sanitizeWorkflowStageIndex(action?.stageIndex, asArray(nextWorkflow.stages).length);\n    const nextStage = asString(nextWorkflow.stages?.[nextIndex], nextWorkflow.stage);\n    nextWorkflow.stageIndex = nextIndex;\n    nextWorkflow.stage = nextStage;\n    nextWorkflow.stageHistory = appendTrail(nextWorkflow.stageHistory, {\n      at: atIso,\n      by: actorEmail,\n      stage: nextStage,\n      action: \"stage-update\",\n    });\n  } else if (actionType === \"add-evidence\") {\n    const evidenceEntry = asObject(action?.evidence, null);\n    if (!evidenceEntry) {\n      throw new Error(\"invalid_workflow_action\");\n    }\n    const evidenceId = asString(evidenceEntry.id, `evidence-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`);\n    nextEvidence = [\n      ...nextEvidence,\n      {\n        id: evidenceId,\n        name: asString(evidenceEntry.name, \"Evidence File\"),\n        ref: asString(evidenceEntry.ref),\n        storagePath: asString(evidenceEntry.storagePath),\n        contentType: asString(evidenceEntry.contentType),\n        sizeBytes: Number.isFinite(Number(evidenceEntry.sizeBytes)) ? Number(evidenceEntry.sizeBytes) : 0,\n        uploadedAt: asString(evidenceEntry.uploadedAt, atIso),\n        uploadedBy: asString(evidenceEntry.uploadedBy, actorEmail),\n        note: asString(evidenceEntry.note),\n      },\n    ].slice(-MAX_LIFECYCLE_EVIDENCE_ITEMS);\n  } else if (actionType === \"remove-evidence\") {\n    const evidenceId = asString(action?.evidenceId);\n    if (!evidenceId) {\n      throw new Error(\"invalid_workflow_action\");\n    }\n    nextEvidence = nextEvidence.filter((item) => asString(item?.id) !== evidenceId);\n  } else {\n    throw new Error(\"invalid_workflow_action\");\n  }\n\n  const progress = summarizeChecklistProgress(nextWorkflow.checklist);\n  nextWorkflow.progress = progress;\n  nextWorkflow.updatedAt = atIso;\n  nextWorkflow.slaBreached =\n    Boolean(nextWorkflow.slaDueAt) &&\n    new Date(nextWorkflow.slaDueAt).getTime() < new Date(atIso).getTime() &&\n    progress.completedRequired < progress.totalRequired;\n\n  return {\n    workflow: nextWorkflow,\n    evidence: nextEvidence,\n  };\n}\n\nfunction applyApprovalDecision({\n  workflow,\n  actorRole,\n  actorEmail,\n  decision,\n  note,\n  atIso,\n}) {\n  const normalizedDecision = normalizeDecision(decision);\n  if (!normalizedDecision) {\n    throw new Error(\"invalid_approval_decision\");\n  }\n\n  const chain = asArray(workflow?.approvalChain).map((step) => ({ ...step }));\n  const pendingIndex = chain.findIndex((step) => normalizeText(step?.status) === \"pending\");\n  if (pendingIndex < 0) {\n    throw new Error(\"no_pending_approval_step\");\n  }\n\n  const actorRoleId = normalizeRoleId(actorRole);\n  const expectedRole = normalizeRoleId(chain[pendingIndex]?.role);\n  if (!actorRoleId || actorRoleId !== expectedRole) {\n    throw new Error(\"approval_not_allowed_for_role\");\n  }\n\n  chain[pendingIndex] = {\n    ...chain[pendingIndex],\n    status: normalizedDecision === \"approved\" ? \"Approved\" : \"Rejected\",\n    decidedAt: atIso,\n    decidedBy: actorEmail,\n    note: asString(note),\n  };\n\n  if (normalizedDecision === \"rejected\") {\n    return {\n      workflow: {\n        ...workflow,\n        approvalChain: chain,\n        approvalState: \"Rejected\",\n        updatedAt: atIso,\n      },\n      status: \"Rejected\",\n    };\n  }\n\n  const approvalState = resolveApprovalState(chain);\n  const nextWorkflow = {\n    ...workflow,\n    approvalChain: chain,\n    approvalState,\n    updatedAt: atIso,\n  };\n\n  const nextStatus = approvalState === \"Approved\" ? \"Approved\" : asString(workflow?.status, \"Pending Approval\");\n  return {\n    workflow: nextWorkflow,\n    status: nextStatus,\n  };\n}\n\nfunction appendTrail(currentValue, entry) {\n  const trail = [...asArray(currentValue), entry];\n  if (trail.length <= MAX_AUDIT_TRAIL_ITEMS) {\n    return trail;\n  }\n  return trail.slice(trail.length - MAX_AUDIT_TRAIL_ITEMS);\n}\n\nfunction byRecentUpdated(a, b) {\n  return new Date(b.updatedAt || b.createdAt || 0).getTime() - new Date(a.updatedAt || a.createdAt || 0).getTime();\n}\n\nfunction getCollectionName(key) {\n  const map = {\n    employees: env(\"CLIO_FIRESTORE_EMPLOYEES_COLLECTION\", \"employees\"),\n    lifecycle: env(\"CLIO_FIRESTORE_LIFECYCLE_COLLECTION\", \"employment_lifecycle\"),\n    attendance: env(\"CLIO_FIRESTORE_ATTENDANCE_COLLECTION\", \"attendance\"),\n    leave: env(\"CLIO_FIRESTORE_LEAVE_COLLECTION\", \"leave_requests\"),\n    performance: env(\"CLIO_FIRESTORE_PERFORMANCE_COLLECTION\", \"performance_records\"),\n    templates: env(\"CLIO_FIRESTORE_TEMPLATES_COLLECTION\", \"document_templates\"),\n    exports: env(\"CLIO_FIRESTORE_EXPORTS_COLLECTION\", \"export_requests\"),\n    incidents: env(\"CLIO_FIRESTORE_INCIDENTS_COLLECTION\", \"security_incidents\"),\n    settingsReference: env(\"CLIO_FIRESTORE_SETTINGS_REFERENCE_COLLECTION\", \"settings_reference_data\"),\n  };\n  return map[key] || key;\n}\n\nfunction getEmployeeDocumentsSubcollectionName() {\n  return env(\"CLIO_FIRESTORE_EMPLOYEE_DOCUMENTS_SUBCOLLECTION\", \"documents\");\n}\n\nfunction getDbOrThrow() {\n  if (!isFirestoreEnabled()) {\n    throw new Error(\"firestore_not_configured\");\n  }\n  const db = getFirestoreDb();\n  if (!db) {\n    throw new Error(\"firestore_not_configured\");\n  }\n  return db;\n}\n\nasync function listCollectionRecords(collectionName, { filterField, filterValue } = {}) {\n  const db = getDbOrThrow();\n  const ref = collection(db, collectionName);\n  let snapshot;\n  if (filterField && typeof filterValue === \"string\" && filterValue.trim()) {\n    snapshot = await getDocs(query(ref, where(filterField, \"==\", filterValue.trim())));\n  } else {\n    snapshot = await getDocs(ref);\n  }\n\n  return snapshot.docs\n    .map((item) => ({\n      ...item.data(),\n      id: item.id,\n      recordId: item.id,\n    }))\n    .sort(byRecentUpdated);\n}\n\nasync function getCollectionRecordById(collectionName, recordId) {\n  const db = getDbOrThrow();\n  const normalizedId = asString(recordId);\n  if (!normalizedId) {\n    throw new Error(\"invalid_record_id\");\n  }\n\n  const ref = doc(db, collectionName, normalizedId);\n  const snapshot = await getDoc(ref);\n  if (!snapshot.exists()) {\n    return null;\n  }\n  return {\n    ...snapshot.data(),\n    id: snapshot.id,\n    recordId: snapshot.id,\n  };\n}\n\nasync function createCollectionRecord(collectionName, payload) {\n  const db = getDbOrThrow();\n  const ref = await addDoc(collection(db, collectionName), payload);\n  return {\n    ...payload,\n    id: ref.id,\n    recordId: ref.id,\n  };\n}\n\nasync function updateCollectionRecord(collectionName, recordId, payload) {\n  const db = getDbOrThrow();\n  const normalizedId = asString(recordId);\n  if (!normalizedId) {\n    throw new Error(\"invalid_record_id\");\n  }\n\n  const ref = doc(db, collectionName, normalizedId);\n  const snapshot = await getDoc(ref);\n  if (!snapshot.exists()) {\n    return null;\n  }\n\n  const current = snapshot.data() || {};\n  const next = {\n    ...current,\n    ...payload,\n  };\n  await updateDoc(ref, next);\n  return {\n    ...next,\n    id: snapshot.id,\n    recordId: snapshot.id,\n  };\n}\n\nasync function updateCollectionRecordsByField(collectionName, filterField, filterValue, buildPatch) {\n  const db = getDbOrThrow();\n  const normalized = asString(filterValue);\n  if (!normalized) {\n    return 0;\n  }\n\n  const snapshot = await getDocs(\n    query(collection(db, collectionName), where(filterField, \"==\", normalized)),\n  );\n\n  let updatedCount = 0;\n  for (const recordSnapshot of snapshot.docs) {\n    const current = recordSnapshot.data() || {};\n    const patch = buildPatch(current, recordSnapshot.id);\n    if (!patch || typeof patch !== \"object\" || Object.keys(patch).length === 0) {\n      continue;\n    }\n    await updateDoc(doc(db, collectionName, recordSnapshot.id), patch);\n    updatedCount += 1;\n  }\n\n  return updatedCount;\n}\n\nasync function deleteCollectionRecord(collectionName, recordId) {\n  const db = getDbOrThrow();\n  const normalizedId = asString(recordId);\n  if (!normalizedId) {\n    throw new Error(\"invalid_record_id\");\n  }\n\n  const ref = doc(db, collectionName, normalizedId);\n  const snapshot = await getDoc(ref);\n  if (!snapshot.exists()) {\n    return null;\n  }\n\n  await deleteDoc(ref);\n  return {\n    ...snapshot.data(),\n    id: snapshot.id,\n    recordId: snapshot.id,\n  };\n}\n\nfunction toReferenceCatalogItem(raw, kind) {\n  const normalizedKind = normalizeReferenceKind(kind || raw?.kind);\n  if (!normalizedKind) {\n    return null;\n  }\n\n  const valueSource = asString(raw?.value || raw?.label);\n  const labelSource = asString(raw?.label || raw?.value);\n  const value = valueSource || labelSource;\n  const label = labelSource || valueSource;\n  const key = normalizeReferenceKey(normalizedKind, value || label);\n  if (!value || !label || !key) {\n    return null;\n  }\n\n  return {\n    id: asString(raw?.id || raw?.recordId),\n    kind: normalizedKind,\n    key,\n    value,\n    label,\n    isSystem: Boolean(raw?.isSystem),\n    createdAt: asString(raw?.createdAt),\n    updatedAt: asString(raw?.updatedAt),\n  };\n}\n\nexport async function listSettingsReferenceCatalogBackend() {\n  const collectionName = getCollectionName(\"settingsReference\");\n  const baseCatalog = buildSystemReferenceCatalog();\n  const rows = (await listCollectionRecords(collectionName)).slice(0, MAX_REFERENCE_CATALOG_ITEMS);\n\n  const roleByKey = new Map(baseCatalog.roles.map((item) => [item.key, item]));\n  const departmentByKey = new Map(baseCatalog.departments.map((item) => [item.key, item]));\n\n  rows.forEach((row) => {\n    const item = toReferenceCatalogItem(row);\n    if (!item) {\n      return;\n    }\n\n    if (item.kind === \"role\") {\n      if (!roleByKey.has(item.key)) {\n        roleByKey.set(item.key, item);\n      }\n      return;\n    }\n\n    if (!departmentByKey.has(item.key)) {\n      departmentByKey.set(item.key, item);\n    }\n  });\n\n  return {\n    roles: sortReferenceCatalogItems([...roleByKey.values()]),\n    departments: sortReferenceCatalogItems([...departmentByKey.values()]),\n  };\n}\n\nexport async function createSettingsReferenceItemBackend({ kind, label }, actorEmail) {\n  const normalizedKind = normalizeReferenceKind(kind);\n  if (!normalizedKind) {\n    throw new Error(\"invalid_reference_kind\");\n  }\n\n  const normalizedLabel = normalizeReferenceLabel(label);\n  if (!normalizedLabel || normalizedLabel.length > MAX_REFERENCE_LABEL_LENGTH) {\n    throw new Error(\"invalid_reference_label\");\n  }\n\n  const key = normalizeReferenceKey(normalizedKind, normalizedLabel);\n  if (!key) {\n    throw new Error(\"invalid_reference_label\");\n  }\n\n  const catalog = await listSettingsReferenceCatalogBackend();\n  const targetRows = normalizedKind === \"role\" ? catalog.roles : catalog.departments;\n  const alreadyExists = targetRows.some((entry) => entry.key === key);\n  if (alreadyExists) {\n    throw new Error(\"duplicate_reference_value\");\n  }\n\n  const timestamp = nowIso();\n  const payload = {\n    kind: normalizedKind,\n    key,\n    value: normalizedLabel,\n    label: normalizedLabel,\n    isSystem: false,\n    createdAt: timestamp,\n    createdBy: actorEmail,\n    updatedAt: timestamp,\n    updatedBy: actorEmail,\n  };\n\n  const created = await createCollectionRecord(getCollectionName(\"settingsReference\"), payload);\n  const item = toReferenceCatalogItem(created, normalizedKind);\n  if (!item) {\n    throw new Error(\"invalid_reference_label\");\n  }\n  return item;\n}\n\nexport async function deleteSettingsReferenceItemBackend({ kind, recordId }) {\n  const normalizedKind = normalizeReferenceKind(kind);\n  if (!normalizedKind) {\n    throw new Error(\"invalid_reference_kind\");\n  }\n\n  const normalizedRecordId = asString(recordId);\n  if (!normalizedRecordId || normalizedRecordId.startsWith(\"system-\")) {\n    throw new Error(\"immutable_reference_item\");\n  }\n\n  const current = await getCollectionRecordById(getCollectionName(\"settingsReference\"), normalizedRecordId);\n  if (!current) {\n    return null;\n  }\n\n  const currentKind = normalizeReferenceKind(current.kind);\n  if (!currentKind || currentKind !== normalizedKind || current.isSystem === true) {\n    throw new Error(\"immutable_reference_item\");\n  }\n\n  const deleted = await deleteCollectionRecord(getCollectionName(\"settingsReference\"), normalizedRecordId);\n  return toReferenceCatalogItem(deleted, normalizedKind);\n}\n\nfunction normalizeEmployeeWritePayload(payload, actorEmail, { base } = {}) {\n  const timestamp = nowIso();\n  const employeeEmail = normalizeEmail(payload?.email || base?.email);\n  if (!employeeEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const baseGovernmentIds = asObject(base?.governmentIds, {});\n  const incomingGovernmentIds = asObject(payload?.governmentIds, {});\n  const governmentIds = {\n    ...baseGovernmentIds,\n    ...incomingGovernmentIds,\n  };\n\n  const basePayrollInformation = asObject(base?.payrollInformation, {});\n  const incomingPayrollInformation = asObject(payload?.payrollInformation, {});\n  const payrollInformation = {\n    ...basePayrollInformation,\n    ...incomingPayrollInformation,\n  };\n\n  const managerEmail = normalizeEmail(payload?.managerEmail || base?.managerEmail);\n  const contact = asString(payload?.contact, asString(base?.contact, \"-\"));\n  const address = asString(payload?.address, asString(base?.address, \"-\"));\n  const emergencyContact = asString(payload?.emergencyContact, asString(base?.emergencyContact, \"-\"));\n  const govId = asString(payload?.govId, asString(base?.govId, \"Masked\"));\n  const firstName = asString(payload?.firstName, asString(base?.firstName, \"\"));\n  const middleName = asString(payload?.middleName, asString(base?.middleName, \"\"));\n  const lastName = asString(payload?.lastName, asString(base?.lastName, \"\"));\n  const suffix = asString(payload?.suffix, asString(base?.suffix, \"\"));\n  const legacyName = asString(payload?.name, asString(base?.name, employeeEmail));\n  const composedName = composeEmployeeName({\n    firstName,\n    middleName,\n    lastName,\n    suffix,\n    fallback: legacyName || employeeEmail,\n  });\n\n  if (!governmentIds.primaryId) {\n    governmentIds.primaryId = govId;\n  }\n\n  const payloadHasDocuments = Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"documents\");\n  const payloadDocuments = payloadHasDocuments ? asArray(payload?.documents) : null;\n  const baseDocumentsCountRaw = Number(base?.documentsCount);\n  const baseDocumentsCount = Number.isFinite(baseDocumentsCountRaw)\n    ? Math.max(0, baseDocumentsCountRaw)\n    : asArray(base?.documents).length;\n  const documentsCount = payloadDocuments ? payloadDocuments.length : baseDocumentsCount;\n\n  return {\n    employeeId: asString(payload?.employeeId, asString(base?.employeeId, `CL-${Date.now().toString().slice(-6)}`)),\n    name: composedName,\n    firstName,\n    middleName,\n    lastName,\n    suffix,\n    email: employeeEmail,\n    role: asString(payload?.role, asString(base?.role, \"EMPLOYEE_L1\")),\n    department: asString(payload?.department, asString(base?.department, \"-\")),\n    jobTitle: asString(payload?.jobTitle, asString(base?.jobTitle, \"-\")),\n    managerEmail,\n    hireDate: asString(payload?.hireDate, asString(base?.hireDate, \"\")),\n    employmentStatus: asString(payload?.employmentStatus, asString(base?.employmentStatus, \"Active Employee\")),\n    status: asString(payload?.status, asString(base?.status, \"Active\")),\n    governmentIds,\n    govId,\n    contact,\n    address,\n    emergencyContact,\n    contactInformation: {\n      primaryPhone: contact,\n      address,\n      emergencyContact,\n    },\n    payrollInformation,\n    payrollGroup: asString(payload?.payrollGroup, asString(base?.payrollGroup, \"-\")),\n    documentsCount,\n    classification: \"Restricted PII\",\n    createdAt: asString(base?.createdAt, timestamp),\n    createdBy: asString(base?.createdBy, actorEmail),\n    updatedAt: timestamp,\n    updatedBy: actorEmail,\n    activityHistory: appendTrail(base?.activityHistory, {\n      at: timestamp,\n      by: actorEmail,\n      action: base ? \"update\" : \"create\",\n    }),\n  };\n}\n\nexport async function listEmployeeRecordsBackend({ ownerEmail, includeDocuments = false } = {}) {\n  const rows = await listCollectionRecords(getCollectionName(\"employees\"), {\n    filterField: ownerEmail ? \"email\" : undefined,\n    filterValue: ownerEmail ? normalizeEmail(ownerEmail) : undefined,\n  });\n  if (!includeDocuments) {\n    return rows;\n  }\n\n  const enriched = await Promise.all(\n    rows.map(async (record) => {\n      const documents = await resolveAndMigrateEmployeeDocuments(record);\n      return withEmployeeDocuments(record, documents);\n    }),\n  );\n  return enriched;\n}\n\nexport async function getEmployeeRecordBackend(recordId, { includeDocuments = true } = {}) {\n  const record = await getCollectionRecordById(getCollectionName(\"employees\"), recordId);\n  if (!record || !includeDocuments) {\n    return record;\n  }\n\n  let documents = await resolveAndMigrateEmployeeDocuments(record);\n  if (documents.length === 0) {\n    const backfilledDocuments = await collectOnboardingEvidenceDocumentsByEmployeeEmail(\n      record.email,\n      record.updatedBy || record.createdBy,\n    );\n    if (backfilledDocuments.length > 0) {\n      documents = await replaceEmployeeDocumentSubcollectionById(record.id, backfilledDocuments, {\n        actorEmail: record.updatedBy || record.createdBy,\n      });\n      await clearLegacyEmployeeDocumentsField(record.id, {\n        documentsCount: documents.length,\n      });\n    }\n  }\n  return withEmployeeDocuments(record, documents);\n}\n\nexport async function createEmployeeRecordBackend(payload, actorEmail) {\n  const normalized = normalizeEmployeeWritePayload(payload, actorEmail);\n  const created = await createCollectionRecord(getCollectionName(\"employees\"), normalized);\n  const payloadDocuments = asArray(payload?.documents);\n  if (payloadDocuments.length === 0) {\n    return withEmployeeDocuments(created, []);\n  }\n\n  const syncedDocuments = await replaceEmployeeDocumentSubcollectionById(created.id, payloadDocuments, {\n    actorEmail,\n  });\n  await clearLegacyEmployeeDocumentsField(created.id, {\n    documentsCount: syncedDocuments.length,\n  });\n  return withEmployeeDocuments(created, syncedDocuments);\n}\n\nexport async function updateEmployeeRecordBackend(recordId, payload, actorEmail) {\n  const current = await getEmployeeRecordBackend(recordId, { includeDocuments: true });\n  if (!current) {\n    return null;\n  }\n  const payloadHasDocuments = Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"documents\");\n  const payloadDocuments = payloadHasDocuments ? asArray(payload?.documents) : null;\n  const normalized = normalizeEmployeeWritePayload(payload, actorEmail, { base: current });\n  const updated = await updateCollectionRecord(getCollectionName(\"employees\"), recordId, normalized);\n  if (!updated) {\n    return null;\n  }\n\n  if (payloadDocuments) {\n    const syncedDocuments = await replaceEmployeeDocumentSubcollectionById(recordId, payloadDocuments, {\n      actorEmail,\n    });\n    await clearLegacyEmployeeDocumentsField(recordId, {\n      documentsCount: syncedDocuments.length,\n    });\n    return withEmployeeDocuments(updated, syncedDocuments);\n  }\n\n  const documents = await resolveAndMigrateEmployeeDocuments(updated);\n  return withEmployeeDocuments(updated, documents);\n}\n\nexport async function deleteEmployeeRecordBackend(recordId) {\n  await deleteEmployeeDocumentSubcollectionById(recordId);\n  return await deleteCollectionRecord(getCollectionName(\"employees\"), recordId);\n}\n\nfunction normalizeLifecyclePayload(payload, actorEmail, actorRole, { base } = {}) {\n  const timestamp = nowIso();\n  const category = asString(payload?.category, asString(base?.category, \"Onboarding\"));\n  const employeeEmail = normalizeEmail(payload?.employeeEmail || base?.employeeEmail);\n  if (!employeeEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const baseDetails = asObject(base?.details, {});\n  const incomingDetails = asObject(payload?.details, {});\n  const details = {\n    ...baseDetails,\n    ...incomingDetails,\n  };\n\n  const template = getLifecycleTemplateByCategory(category);\n  const requiredApprovers = resolveRequiredApproverRoles(template, details);\n  const baseWorkflow = asObject(base?.workflow, {});\n  const workflowPatch = asObject(payload?.workflow, {});\n  const workflowSeed = {\n    ...baseWorkflow,\n    ...workflowPatch,\n  };\n\n  const workflow = buildInitialLifecycleWorkflow({\n    template,\n    baseWorkflow: workflowSeed,\n    requiredApprovers,\n    atIso: timestamp,\n    actorEmail,\n  });\n\n  const action = payload?.workflowAction && typeof payload.workflowAction === \"object\" ? payload.workflowAction : null;\n  const withAction = applyLifecycleWorkflowAction({\n    workflow,\n    evidence: asArray(base?.evidence),\n    action,\n    actorEmail,\n    atIso: timestamp,\n  });\n\n  const progress = summarizeChecklistProgress(withAction.workflow.checklist);\n  withAction.workflow.progress = progress;\n  withAction.workflow.slaBreached =\n    Boolean(withAction.workflow.slaDueAt) &&\n    new Date(withAction.workflow.slaDueAt).getTime() < new Date(timestamp).getTime() &&\n    progress.completedRequired < progress.totalRequired;\n  withAction.workflow.approvalState = resolveApprovalState(withAction.workflow.approvalChain);\n\n  const requestedStatus = asString(payload?.status, asString(base?.status, \"In Progress\"));\n  const status = requestedStatus;\n\n  return {\n    employeeEmail,\n    employee: asString(payload?.employee, asString(base?.employee, employeeEmail || \"Unknown Employee\")),\n    category,\n    workflowType: asString(template.type, \"onboarding\"),\n    owner: asString(payload?.owner, asString(base?.owner, \"HR Operations\")),\n    details,\n    evidence: withAction.evidence,\n    workflow: withAction.workflow,\n    status,\n    createdAt: asString(base?.createdAt, timestamp),\n    createdBy: asString(base?.createdBy, actorEmail),\n    updatedAt: timestamp,\n    updatedBy: actorEmail,\n    traceability: appendTrail(base?.traceability, {\n      at: timestamp,\n      by: actorEmail,\n      action: base ? \"update\" : \"create\",\n      category,\n      status,\n      stage: withAction.workflow.stage,\n      checklistProgress: withAction.workflow.progress.percent,\n      approvalState: withAction.workflow.approvalState,\n    }),\n  };\n}\n\nfunction shouldTriggerAccessRevocation(record) {\n  const category = asString(record?.category).toLowerCase();\n  const status = asString(record?.status).toLowerCase();\n  return (\n    category.includes(\"offboarding\") ||\n    status.includes(\"resign\") ||\n    status.includes(\"terminated\") ||\n    status.includes(\"access revoked\")\n  );\n}\n\nfunction shouldApplyLifecycleRoleSync(record) {\n  const category = asString(record?.category).toLowerCase();\n  const status = asString(record?.status).toLowerCase();\n  const isRoleMovement = category.includes(\"role change\") || category.includes(\"promotion\");\n  const isFinalized = status.includes(\"approved\") || status.includes(\"completed\");\n  return isRoleMovement && isFinalized;\n}\n\nfunction shouldApplyLifecycleArchivePolicy(record) {\n  const category = asString(record?.category).toLowerCase();\n  const status = asString(record?.status).toLowerCase();\n  const exitStatusDetected =\n    status.includes(\"resign\") || status.includes(\"terminated\") || status.includes(\"access revoked\");\n  const finalizedOffboarding =\n    category.includes(\"offboarding\") &&\n    (status.includes(\"approved\") || status.includes(\"completed\") || status.includes(\"revoked\"));\n  return exitStatusDetected || finalizedOffboarding;\n}\n\nfunction shouldApplyOnboardingActivation(record) {\n  const category = asString(record?.category).toLowerCase();\n  const status = asString(record?.status).toLowerCase();\n  const isOnboarding = category.includes(\"onboarding\");\n  const isFinalized = status.includes(\"approved\") || status.includes(\"completed\");\n  return isOnboarding && isFinalized;\n}\n\nfunction shouldTriggerOnboardingInvite(record) {\n  const category = asString(record?.category).toLowerCase();\n  return category.includes(\"onboarding\");\n}\n\nfunction resolveLifecycleInviteRole(record) {\n  const details = asObject(record?.details, {});\n  const roleRaw = asString(details?.roleTo || details?.role || details?.roleFrom);\n  if (!roleRaw) {\n    return \"EMPLOYEE_L1\";\n  }\n  const normalized = normalizeRoleKey(roleRaw);\n  if (!normalized) {\n    return \"EMPLOYEE_L1\";\n  }\n  return LIFECYCLE_ROLE_ALIAS.get(normalized) || normalized || \"EMPLOYEE_L1\";\n}\n\nasync function triggerOnboardingInvite(record, actorEmail, actorRole) {\n  const normalizedEmail = normalizeEmail(record?.employeeEmail);\n  if (!normalizedEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const existingAccount = await getLoginAccount(normalizedEmail).catch(() => null);\n  const existingStatus = asString(existingAccount?.status).toLowerCase();\n  if (existingStatus === \"active\") {\n    return {\n      type: \"onboarding-invite-skipped\",\n      message: \"User account is already active. Invite was not reissued.\",\n      accountStatus: \"active\",\n    };\n  }\n\n  const inviteRole = resolveLifecycleInviteRole(record);\n  validateLifecycleTargetRolePermission({\n    actorRole,\n    targetRole: inviteRole,\n  });\n  const result = await inviteUserAccount({\n    email: normalizedEmail,\n    role: inviteRole,\n    invitedBy: actorEmail,\n  });\n\n  const enforceDelivery = isInviteDeliveryRequired();\n  let delivery = null;\n  try {\n    delivery = await deliverInviteEmail({\n      toEmail: result.user.email,\n      role: result.user.role,\n      invitedBy: actorEmail,\n      expiresAt: result.invite.expiresAt,\n      inviteToken: result.invite.token,\n    });\n  } catch (deliveryError) {\n    const rawReason = deliveryError instanceof Error ? deliveryError.message : \"email_delivery_failed\";\n    const deliveryErrorInfo = extractDeliveryErrorInfo(rawReason);\n    if (enforceDelivery) {\n      await revokeInviteById(result.invite.id).catch(() => null);\n      throw new Error(deliveryErrorInfo.code || \"email_delivery_failed\");\n    }\n\n    delivery = {\n      provider: \"unavailable\",\n      status: \"failed\",\n      messageId: null,\n      reason: deliveryErrorInfo.code || \"email_delivery_failed\",\n      providerMessage: deliveryErrorInfo.providerMessage || null,\n    };\n  }\n\n  return {\n    type: \"onboarding-invite\",\n    message:\n      delivery?.status === \"failed\"\n        ? \"Onboarding invite was created. Email delivery failed in test mode.\"\n        : \"Onboarding invite sent. User can verify email and activate access.\",\n    inviteId: result.invite.id,\n    inviteStatus: result.invite.status,\n    role: result.user.role,\n    deliveryProvider: delivery?.provider || \"unknown\",\n    deliveryStatus: delivery?.status || \"unknown\",\n  };\n}\n\nfunction resolveLifecycleRoleTarget(record) {\n  const details = asObject(record?.details, {});\n  const roleToRaw = asString(details?.roleTo);\n  if (!roleToRaw) {\n    return \"\";\n  }\n\n  const normalized = normalizeRoleKey(roleToRaw);\n  return LIFECYCLE_ROLE_ALIAS.get(normalized) || \"\";\n}\n\nfunction resolveArchiveReasonFromLifecycle(record) {\n  const details = asObject(record?.details, {});\n  const detailReason = asString(details?.offboardingReason || details?.reason || details?.note);\n  if (detailReason) {\n    return detailReason;\n  }\n\n  const category = asString(record?.category);\n  const status = asString(record?.status);\n  if (category || status) {\n    return [category, status].filter(Boolean).join(\" - \");\n  }\n\n  return \"Resigned\";\n}\n\nfunction buildArchivePatch(current, { actorEmail, archivedAt, reason, retentionDeleteAt, trailField }) {\n  const patch = {\n    isArchived: true,\n    archivedAt,\n    archivedBy: actorEmail,\n    archiveReason: reason,\n    retentionDeleteAt,\n    updatedAt: archivedAt,\n    updatedBy: actorEmail,\n  };\n\n  if (trailField) {\n    patch[trailField] = appendTrail(current?.[trailField], {\n      at: archivedAt,\n      by: actorEmail,\n      action: \"archive\",\n      reason,\n    });\n  }\n\n  return patch;\n}\n\nasync function syncUserRoleByLifecycle(record, actorRole) {\n  const normalizedEmail = normalizeEmail(record?.employeeEmail);\n  if (!normalizedEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const targetRole = resolveLifecycleRoleTarget(record);\n  if (!targetRole) {\n    throw new Error(\"invalid_target_role\");\n  }\n  validateLifecycleTargetRolePermission({\n    actorRole,\n    targetRole,\n  });\n\n  const updated = await updateUserAccountRole({\n    userId: normalizedEmail,\n    role: targetRole,\n  });\n  if (!updated) {\n    throw new Error(\"role_sync_failed\");\n  }\n\n  return updated;\n}\n\nasync function syncEmployeeRecordRoleByLifecycle(record, actorEmail, actorRole) {\n  const normalizedEmail = normalizeEmail(record?.employeeEmail);\n  if (!normalizedEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const targetRole = resolveLifecycleRoleTarget(record);\n  if (!targetRole) {\n    throw new Error(\"invalid_target_role\");\n  }\n  validateLifecycleTargetRolePermission({\n    actorRole,\n    targetRole,\n  });\n\n  const details = asObject(record?.details, {});\n  const nextDepartment = asString(details?.departmentTo);\n  const updatedAt = nowIso();\n  const updatedCount = await updateCollectionRecordsByField(\n    getCollectionName(\"employees\"),\n    \"email\",\n    normalizedEmail,\n    (current) => {\n      const patch = {\n        role: targetRole,\n        updatedAt,\n        updatedBy: actorEmail,\n        activityHistory: appendTrail(current?.activityHistory, {\n          at: updatedAt,\n          by: actorEmail,\n          action: \"lifecycle-role-sync\",\n          role: targetRole,\n        }),\n      };\n      if (nextDepartment) {\n        patch.department = nextDepartment;\n      }\n      return patch;\n    },\n  );\n\n  return updatedCount;\n}\n\nasync function revokeUserAccessByEmail(email) {\n  const normalizedEmail = normalizeEmail(email);\n  if (!normalizedEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const updated = await updateUserAccountStatus({\n    userId: normalizedEmail,\n    status: \"disabled\",\n  });\n  if (!updated) {\n    throw new Error(\"employee_account_not_found\");\n  }\n  if (asString(updated.status).toLowerCase() !== \"disabled\") {\n    throw new Error(\"access_revocation_failed\");\n  }\n  return updated;\n}\n\nasync function activateUserAccessByEmail(email) {\n  const normalizedEmail = normalizeEmail(email);\n  if (!normalizedEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const updated = await updateUserAccountStatus({\n    userId: normalizedEmail,\n    status: \"active\",\n  });\n  if (!updated) {\n    throw new Error(\"employee_account_not_found\");\n  }\n  if (asString(updated.status).toLowerCase() !== \"active\") {\n    throw new Error(\"account_activation_failed\");\n  }\n  return updated;\n}\n\nasync function activateEmployeeRecordByEmail(record, actorEmail) {\n  const normalizedEmail = normalizeEmail(record?.employeeEmail);\n  if (!normalizedEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const details = asObject(record?.details, {});\n  const employeeId = asString(details?.employeeId || details?.employeeNumber);\n  const firstName = asString(details?.firstName);\n  const middleName = asString(details?.middleName);\n  const lastName = asString(details?.lastName);\n  const suffix = asString(details?.suffix);\n  const startDate = asString(details?.startDate);\n  const roleRaw = asString(details?.roleTo || details?.role || details?.roleFrom);\n  const roleNormalized = normalizeRoleKey(roleRaw);\n  const roleValue = LIFECYCLE_ROLE_ALIAS.get(roleNormalized) || roleNormalized || \"EMPLOYEE_L1\";\n  const departmentValue = asString(details?.departmentTo || details?.department);\n  const displayName = composeEmployeeName({\n    firstName,\n    middleName,\n    lastName,\n    suffix,\n    fallback: asString(record?.employee, normalizedEmail),\n  });\n  const updatedAt = nowIso();\n  const updatedCount = await updateCollectionRecordsByField(getCollectionName(\"employees\"), \"email\", normalizedEmail, (current) => {\n    const patch = {\n      status: \"Active\",\n      employmentStatus: \"Active Employee\",\n      isArchived: false,\n      updatedAt,\n      updatedBy: actorEmail,\n      activityHistory: appendTrail(current?.activityHistory, {\n        at: updatedAt,\n        by: actorEmail,\n        action: \"lifecycle-onboarding-sync\",\n        status: \"Active\",\n      }),\n    };\n    if (employeeId) {\n      patch.employeeId = employeeId;\n    }\n    if (firstName) {\n      patch.firstName = firstName;\n    }\n    if (middleName) {\n      patch.middleName = middleName;\n    }\n    if (lastName) {\n      patch.lastName = lastName;\n    }\n    if (suffix) {\n      patch.suffix = suffix;\n    }\n    if (displayName) {\n      patch.name = displayName;\n    }\n    if (departmentValue) {\n      patch.department = departmentValue;\n    }\n    if (roleValue) {\n      patch.role = roleValue;\n    }\n    if (startDate) {\n      patch.hireDate = startDate;\n    }\n    return patch;\n  });\n\n  if (updatedCount > 0) {\n    return updatedCount;\n  }\n\n  const createdPayload = normalizeEmployeeWritePayload(\n    {\n      employeeId,\n      email: normalizedEmail,\n      name: displayName,\n      firstName,\n      middleName,\n      lastName,\n      suffix,\n      role: roleValue || \"EMPLOYEE_L1\",\n      department: departmentValue || \"-\",\n      hireDate: startDate || \"\",\n      status: \"Active\",\n      employmentStatus: \"Active Employee\",\n    },\n    actorEmail,\n  );\n  await createCollectionRecord(getCollectionName(\"employees\"), createdPayload);\n  return 1;\n}\n\nasync function archiveEmployeeDataByEmail(record, actorEmail) {\n  const normalizedEmail = normalizeEmail(record?.employeeEmail);\n  if (!normalizedEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const archivedAt = nowIso();\n  const retentionDeleteAt = addYearsToIso(archivedAt, getArchiveRetentionYears());\n  const reason = resolveArchiveReasonFromLifecycle(record);\n\n  const userArchive = await archiveUserAccount({\n    userId: normalizedEmail,\n    archivedBy: actorEmail,\n    reason,\n    retentionDeleteAt,\n  });\n\n  const employeesArchived = await updateCollectionRecordsByField(getCollectionName(\"employees\"), \"email\", normalizedEmail, (current) => ({\n    ...buildArchivePatch(current, {\n      actorEmail,\n      archivedAt,\n      reason,\n      retentionDeleteAt,\n      trailField: \"activityHistory\",\n    }),\n    status: \"Archived\",\n    employmentStatus: \"Resigned\",\n  }));\n\n  const lifecycleArchived = await updateCollectionRecordsByField(getCollectionName(\"lifecycle\"), \"employeeEmail\", normalizedEmail, (current) => ({\n    ...buildArchivePatch(current, {\n      actorEmail,\n      archivedAt,\n      reason,\n      retentionDeleteAt,\n      trailField: \"traceability\",\n    }),\n    archiveStatus: \"Archived\",\n  }));\n\n  const attendanceArchived = await updateCollectionRecordsByField(getCollectionName(\"attendance\"), \"employeeEmail\", normalizedEmail, (current) => ({\n    ...buildArchivePatch(current, {\n      actorEmail,\n      archivedAt,\n      reason,\n      retentionDeleteAt,\n      trailField: \"modificationTrail\",\n    }),\n    archiveStatus: \"Archived\",\n  }));\n\n  const leaveArchived = await updateCollectionRecordsByField(getCollectionName(\"leave\"), \"employeeEmail\", normalizedEmail, (current) => ({\n    ...buildArchivePatch(current, {\n      actorEmail,\n      archivedAt,\n      reason,\n      retentionDeleteAt,\n      trailField: \"modificationTrail\",\n    }),\n    archiveStatus: \"Archived\",\n  }));\n\n  const performanceArchived = await updateCollectionRecordsByField(getCollectionName(\"performance\"), \"employeeEmail\", normalizedEmail, (current) => ({\n    ...buildArchivePatch(current, {\n      actorEmail,\n      archivedAt,\n      reason,\n      retentionDeleteAt,\n      trailField: \"traceability\",\n    }),\n    archiveStatus: \"Archived\",\n  }));\n\n  const exportsArchived = await updateCollectionRecordsByField(getCollectionName(\"exports\"), \"requestedBy\", normalizedEmail, (current) => ({\n    ...buildArchivePatch(current, {\n      actorEmail,\n      archivedAt,\n      reason,\n      retentionDeleteAt,\n      trailField: \"history\",\n    }),\n    archiveStatus: \"Archived\",\n  }));\n\n  return {\n    archivedAt,\n    retentionDeleteAt,\n    reason,\n    userStatus: userArchive?.status || \"disabled\",\n    counts: {\n      employees: employeesArchived,\n      lifecycle: lifecycleArchived,\n      attendance: attendanceArchived,\n      leave: leaveArchived,\n      performance: performanceArchived,\n      exports: exportsArchived,\n    },\n  };\n}\n\nasync function applyLifecycleAutomations(record, actorEmail, actorRole) {\n  const effects = [];\n  if (shouldApplyOnboardingActivation(record)) {\n    const activatedAccount = await activateUserAccessByEmail(record.employeeEmail);\n    const activatedEmployeeRecords = await activateEmployeeRecordByEmail(record, actorEmail);\n    effects.push({\n      type: \"onboarding-activation\",\n      message: \"User account and employee profile activated.\",\n      accountStatus: activatedAccount?.status || \"active\",\n      employeeRecordsUpdated: activatedEmployeeRecords,\n    });\n  }\n  if (shouldApplyLifecycleRoleSync(record)) {\n    const employeeRecordsUpdated = await syncEmployeeRecordRoleByLifecycle(record, actorEmail, actorRole);\n    const account = await syncUserRoleByLifecycle(record, actorRole);\n    effects.push({\n      type: \"role-sync\",\n      message: `Role synchronized to ${account?.role || \"target role\"}.`,\n      role: account?.role || null,\n      employeeRecordsUpdated,\n    });\n  }\n  if (shouldTriggerAccessRevocation(record)) {\n    const account = await revokeUserAccessByEmail(record.employeeEmail);\n    effects.push({\n      type: \"access-revocation\",\n      message: \"User account access revoked.\",\n      accountStatus: account?.status || \"disabled\",\n    });\n  }\n  if (shouldApplyLifecycleArchivePolicy(record)) {\n    const archiveResult = await archiveEmployeeDataByEmail(record, actorEmail);\n    effects.push({\n      type: \"archive-policy\",\n      message: `Employee data archived until ${archiveResult.retentionDeleteAt}.`,\n      retentionDeleteAt: archiveResult.retentionDeleteAt,\n      archivedAt: archiveResult.archivedAt,\n      counts: archiveResult.counts,\n    });\n  }\n  return effects;\n}\n\nexport async function listLifecycleRecordsBackend() {\n  return await listCollectionRecords(getCollectionName(\"lifecycle\"));\n}\n\nexport async function getLifecycleRecordBackend(recordId) {\n  return await getCollectionRecordById(getCollectionName(\"lifecycle\"), recordId);\n}\n\nexport async function createLifecycleRecordBackend(payload, actorEmail, actorRole = \"\") {\n  const normalized = normalizeLifecyclePayload(payload, actorEmail, actorRole);\n  const effects = [];\n  if (shouldTriggerOnboardingInvite(normalized)) {\n    const inviteEffect = await triggerOnboardingInvite(normalized, actorEmail, actorRole);\n    if (inviteEffect) {\n      effects.push(inviteEffect);\n    }\n  }\n  const automationEffects = await applyLifecycleAutomations(normalized, actorEmail, actorRole);\n  effects.push(...automationEffects);\n\n  const created = await createCollectionRecord(getCollectionName(\"lifecycle\"), {\n    ...normalized,\n    lastAutomationEffects: effects,\n    lastAutomationAt: nowIso(),\n    lastAutomationBy: actorEmail,\n  });\n\n  await syncOnboardingEvidenceToEmployeeDocuments(created, actorEmail).catch(() => null);\n\n  return {\n    record: created,\n    effects,\n  };\n}\n\nexport async function updateLifecycleRecordBackend(recordId, payload, actorEmail, actorRole = \"\") {\n  const current = await getLifecycleRecordBackend(recordId);\n  if (!current) {\n    return null;\n  }\n  const normalized = normalizeLifecyclePayload(payload, actorEmail, actorRole, { base: current });\n  const effects = await applyLifecycleAutomations(normalized, actorEmail, actorRole);\n\n  const updated = await updateCollectionRecord(getCollectionName(\"lifecycle\"), recordId, {\n    ...normalized,\n    lastAutomationEffects: effects,\n    lastAutomationAt: nowIso(),\n    lastAutomationBy: actorEmail,\n  });\n\n  await syncOnboardingEvidenceToEmployeeDocuments(updated, actorEmail).catch(() => null);\n\n  return {\n    record: updated,\n    effects,\n  };\n}\n\nexport async function forceOffboardLifecycleRecordBackend(recordId, actorEmail, reason, actorRole = \"\") {\n  return await updateLifecycleRecordBackend(\n    recordId,\n    {\n      category: \"Offboarding\",\n      status: \"Access Revoked\",\n      details: {\n        offboardingReason: asString(reason, \"Resignation\"),\n      },\n    },\n    actorEmail,\n    actorRole,\n  );\n}\n\nexport async function approveLifecycleRecordBackend(\n  recordId,\n  { decision, note } = {},\n  actorEmail,\n  actorRole = \"\",\n) {\n  const current = await getLifecycleRecordBackend(recordId);\n  if (!current) {\n    return null;\n  }\n\n  const timestamp = nowIso();\n  const baseWorkflow = asObject(current.workflow, {});\n  const approvalResult = applyApprovalDecision({\n    workflow: baseWorkflow,\n    actorRole,\n    actorEmail,\n    decision,\n    note,\n    atIso: timestamp,\n  });\n\n  const normalized = normalizeLifecyclePayload(\n    {\n      status: approvalResult.status,\n      workflow: approvalResult.workflow,\n    },\n    actorEmail,\n    actorRole,\n    { base: current },\n  );\n\n  const effects = await applyLifecycleAutomations(normalized, actorEmail, actorRole);\n  const updated = await updateCollectionRecord(getCollectionName(\"lifecycle\"), recordId, {\n    ...normalized,\n    lastAutomationEffects: effects,\n    lastAutomationAt: nowIso(),\n    lastAutomationBy: actorEmail,\n  });\n\n  await syncOnboardingEvidenceToEmployeeDocuments(updated, actorEmail).catch(() => null);\n\n  return {\n    record: updated,\n    effects,\n  };\n}\n\nfunction normalizeAttendancePayload(payload, actorEmail, { base } = {}) {\n  const timestamp = nowIso();\n  const employeeEmail = normalizeEmail(payload?.employeeEmail || base?.employeeEmail);\n  if (!employeeEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const next = {\n    employeeEmail,\n    employee: asString(payload?.employee, asString(base?.employee, employeeEmail)),\n    date: asString(payload?.date, asString(base?.date, timestamp.slice(0, 10))),\n    checkIn: asString(payload?.checkIn, asString(base?.checkIn, \"-\")),\n    checkOut: asString(payload?.checkOut, asString(base?.checkOut, \"-\")),\n    status: asString(payload?.status, asString(base?.status, \"Recorded\")),\n    reason: asString(payload?.reason, asString(base?.reason, \"\")),\n    createdAt: asString(base?.createdAt, timestamp),\n    createdBy: asString(base?.createdBy, actorEmail),\n    updatedAt: timestamp,\n    updatedBy: actorEmail,\n  };\n\n  next.modificationTrail = appendTrail(base?.modificationTrail, {\n    at: timestamp,\n    by: actorEmail,\n    action: base ? \"update\" : \"create\",\n    status: next.status,\n    checkIn: next.checkIn,\n    checkOut: next.checkOut,\n    reason: next.reason,\n  });\n\n  return next;\n}\n\nfunction normalizeLeavePayload(payload, actorEmail, { base } = {}) {\n  const timestamp = nowIso();\n  const employeeEmail = normalizeEmail(payload?.employeeEmail || base?.employeeEmail);\n  if (!employeeEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  const status = asString(payload?.status, asString(base?.status, \"Pending\"));\n  const next = {\n    employeeEmail,\n    employee: asString(payload?.employee, asString(base?.employee, employeeEmail)),\n    leaveType: asString(payload?.leaveType, asString(base?.leaveType, \"Leave\")),\n    startDate: asString(payload?.startDate, asString(base?.startDate, \"\")),\n    endDate: asString(payload?.endDate, asString(base?.endDate, \"\")),\n    reason: asString(payload?.reason, asString(base?.reason, \"\")),\n    status,\n    approver: asString(payload?.approver, asString(base?.approver, \"\")),\n    approvalNote: asString(payload?.approvalNote, asString(base?.approvalNote, \"\")),\n    createdAt: asString(base?.createdAt, timestamp),\n    createdBy: asString(base?.createdBy, actorEmail),\n    updatedAt: timestamp,\n    updatedBy: actorEmail,\n  };\n\n  next.modificationTrail = appendTrail(base?.modificationTrail, {\n    at: timestamp,\n    by: actorEmail,\n    action: base ? \"update\" : \"create\",\n    status,\n    leaveType: next.leaveType,\n  });\n\n  return next;\n}\n\nexport async function listAttendanceLogsBackend({ ownerEmail } = {}) {\n  return await listCollectionRecords(getCollectionName(\"attendance\"), {\n    filterField: ownerEmail ? \"employeeEmail\" : undefined,\n    filterValue: ownerEmail ? normalizeEmail(ownerEmail) : undefined,\n  });\n}\n\nexport async function getAttendanceLogBackend(recordId) {\n  return await getCollectionRecordById(getCollectionName(\"attendance\"), recordId);\n}\n\nexport async function createAttendanceLogBackend(payload, actorEmail) {\n  const normalized = normalizeAttendancePayload(payload, actorEmail);\n  return await createCollectionRecord(getCollectionName(\"attendance\"), normalized);\n}\n\nexport async function updateAttendanceLogBackend(recordId, payload, actorEmail) {\n  const current = await getAttendanceLogBackend(recordId);\n  if (!current) {\n    return null;\n  }\n  const normalized = normalizeAttendancePayload(payload, actorEmail, { base: current });\n  return await updateCollectionRecord(getCollectionName(\"attendance\"), recordId, normalized);\n}\n\nexport async function listLeaveRequestsBackend({ ownerEmail } = {}) {\n  return await listCollectionRecords(getCollectionName(\"leave\"), {\n    filterField: ownerEmail ? \"employeeEmail\" : undefined,\n    filterValue: ownerEmail ? normalizeEmail(ownerEmail) : undefined,\n  });\n}\n\nexport async function getLeaveRequestBackend(recordId) {\n  return await getCollectionRecordById(getCollectionName(\"leave\"), recordId);\n}\n\nexport async function createLeaveRequestBackend(payload, actorEmail) {\n  const normalized = normalizeLeavePayload(payload, actorEmail);\n  return await createCollectionRecord(getCollectionName(\"leave\"), normalized);\n}\n\nexport async function updateLeaveRequestBackend(recordId, payload, actorEmail) {\n  const current = await getLeaveRequestBackend(recordId);\n  if (!current) {\n    return null;\n  }\n  const normalized = normalizeLeavePayload(payload, actorEmail, { base: current });\n  return await updateCollectionRecord(getCollectionName(\"leave\"), recordId, normalized);\n}\n\nfunction normalizePerformancePayload(payload, actorEmail, { base } = {}) {\n  const timestamp = nowIso();\n  const employeeEmail = normalizeEmail(payload?.employeeEmail || base?.employeeEmail);\n  if (!employeeEmail) {\n    throw new Error(\"invalid_employee_email\");\n  }\n\n  return {\n    employeeEmail,\n    employee: asString(payload?.employee, asString(base?.employee, employeeEmail)),\n    period: asString(payload?.period, asString(base?.period, \"\")),\n    kpiScore: asString(payload?.kpiScore, asString(base?.kpiScore, \"\")),\n    evaluationForm: payload?.evaluationForm ?? base?.evaluationForm ?? {},\n    reviewHistory: asArray(payload?.reviewHistory ?? base?.reviewHistory),\n    promotionJustification: asString(payload?.promotionJustification, asString(base?.promotionJustification, \"\")),\n    reviewer: asString(payload?.reviewer, asString(base?.reviewer, \"\")),\n    rating: asString(payload?.rating, asString(base?.rating, \"\")),\n    status: asString(payload?.status, asString(base?.status, \"Draft\")),\n    createdAt: asString(base?.createdAt, timestamp),\n    createdBy: asString(base?.createdBy, actorEmail),\n    updatedAt: timestamp,\n    updatedBy: actorEmail,\n    traceability: appendTrail(base?.traceability, {\n      at: timestamp,\n      by: actorEmail,\n      action: base ? \"update\" : \"create\",\n      period: asString(payload?.period, asString(base?.period, \"\")),\n    }),\n  };\n}\n\nexport async function listPerformanceRecordsBackend({ ownerEmail } = {}) {\n  return await listCollectionRecords(getCollectionName(\"performance\"), {\n    filterField: ownerEmail ? \"employeeEmail\" : undefined,\n    filterValue: ownerEmail ? normalizeEmail(ownerEmail) : undefined,\n  });\n}\n\nexport async function getPerformanceRecordBackend(recordId) {\n  return await getCollectionRecordById(getCollectionName(\"performance\"), recordId);\n}\n\nexport async function createPerformanceRecordBackend(payload, actorEmail) {\n  const normalized = normalizePerformancePayload(payload, actorEmail);\n  return await createCollectionRecord(getCollectionName(\"performance\"), normalized);\n}\n\nexport async function updatePerformanceRecordBackend(recordId, payload, actorEmail) {\n  const current = await getPerformanceRecordBackend(recordId);\n  if (!current) {\n    return null;\n  }\n  const normalized = normalizePerformancePayload(payload, actorEmail, { base: current });\n  return await updateCollectionRecord(getCollectionName(\"performance\"), recordId, normalized);\n}\n\nfunction normalizeTemplatePayload(payload, actorEmail, { base } = {}) {\n  const timestamp = nowIso();\n  const version = asString(payload?.version, asString(base?.version, \"v1.0\"));\n  const templateName = asString(payload?.templateName, asString(base?.templateName));\n  if (!templateName) {\n    throw new Error(\"invalid_template_name\");\n  }\n\n  const previousVersionEntry = base\n    ? {\n        version: asString(base.version, \"v1.0\"),\n        changedAt: timestamp,\n        changedBy: actorEmail,\n        note: asString(payload?.changeNote, \"Template updated\"),\n      }\n    : null;\n\n  const currentHistory = asArray(base?.versionHistory);\n  const nextHistory = previousVersionEntry ? appendTrail(currentHistory, previousVersionEntry) : currentHistory;\n\n  const modificationLog = appendTrail(base?.modificationLog, {\n    at: timestamp,\n    by: actorEmail,\n    action: base ? \"update\" : \"upload\",\n    version,\n  });\n\n  return {\n    templateName,\n    category: asString(payload?.category, asString(base?.category, \"HR Template\")),\n    classification: asString(payload?.classification, asString(base?.classification, \"Restricted PII\")),\n    documentType: asString(payload?.documentType, asString(base?.documentType, \"Template\")),\n    tags: asArray(payload?.tags ?? base?.tags),\n    version,\n    status: asString(payload?.status, asString(base?.status, \"Active\")),\n    contentRef: asString(payload?.contentRef, asString(base?.contentRef, \"\")),\n    acknowledgments: asArray(payload?.acknowledgments ?? base?.acknowledgments),\n    usageLogs: asArray(payload?.usageLogs ?? base?.usageLogs),\n    versionHistory: nextHistory,\n    modificationLog,\n    createdAt: asString(base?.createdAt, timestamp),\n    createdBy: asString(base?.createdBy, actorEmail),\n    updatedAt: timestamp,\n    updatedBy: actorEmail,\n  };\n}\n\nexport async function listDocumentTemplatesBackend() {\n  return await listCollectionRecords(getCollectionName(\"templates\"));\n}\n\nexport async function getDocumentTemplateBackend(recordId) {\n  return await getCollectionRecordById(getCollectionName(\"templates\"), recordId);\n}\n\nexport async function createDocumentTemplateBackend(payload, actorEmail) {\n  const normalized = normalizeTemplatePayload(payload, actorEmail);\n  return await createCollectionRecord(getCollectionName(\"templates\"), normalized);\n}\n\nexport async function updateDocumentTemplateBackend(recordId, payload, actorEmail) {\n  const current = await getDocumentTemplateBackend(recordId);\n  if (!current) {\n    return null;\n  }\n  const normalized = normalizeTemplatePayload(payload, actorEmail, { base: current });\n  return await updateCollectionRecord(getCollectionName(\"templates\"), recordId, normalized);\n}\n\nexport async function deleteDocumentTemplateBackend(recordId, actorEmail) {\n  const current = await getDocumentTemplateBackend(recordId);\n  if (!current) {\n    return null;\n  }\n  return await updateCollectionRecord(getCollectionName(\"templates\"), recordId, {\n    ...current,\n    status: \"Archived\",\n    archivedAt: nowIso(),\n    archivedBy: actorEmail,\n    updatedAt: nowIso(),\n    updatedBy: actorEmail,\n    modificationLog: appendTrail(current.modificationLog, {\n      at: nowIso(),\n      by: actorEmail,\n      action: \"archive\",\n      version: asString(current.version, \"v1.0\"),\n    }),\n  });\n}\n\nfunction normalizeExportRequestPayload(payload, actorEmail, { base } = {}) {\n  const timestamp = nowIso();\n  const dataset = asString(payload?.dataset, asString(base?.dataset, \"Employee Dataset\"));\n  if (!dataset) {\n    throw new Error(\"invalid_export_dataset\");\n  }\n\n  const format = asString(payload?.format, asString(base?.format, \"CSV\")).toUpperCase();\n  const requestedBy = normalizeEmail(payload?.requestedBy || base?.requestedBy || actorEmail);\n  const scope = asString(payload?.scope, asString(base?.scope, \"full\"));\n  const status = asString(payload?.status, asString(base?.status, \"Pending\"));\n  const estimateVolume = asString(payload?.estimateVolume, asString(base?.estimateVolume, \"0\"));\n  const justification = asString(payload?.justification, asString(base?.justification));\n\n  return {\n    dataset,\n    format,\n    requestedBy,\n    scope,\n    estimateVolume,\n    justification,\n    status,\n    reviewer: asString(payload?.reviewer, asString(base?.reviewer, \"\")),\n    reviewNote: asString(payload?.reviewNote, asString(base?.reviewNote, \"\")),\n    reviewedAt: asString(payload?.reviewedAt, asString(base?.reviewedAt, \"\")),\n    exportedAt: asString(payload?.exportedAt, asString(base?.exportedAt, \"\")),\n    exportedBy: asString(payload?.exportedBy, asString(base?.exportedBy, \"\")),\n    alert: asString(payload?.alert, asString(base?.alert, \"\")),\n    createdAt: asString(base?.createdAt, timestamp),\n    createdBy: asString(base?.createdBy, actorEmail),\n    updatedAt: timestamp,\n    updatedBy: actorEmail,\n    history: appendTrail(base?.history, {\n      at: timestamp,\n      by: actorEmail,\n      action: base ? \"update\" : \"create\",\n      status,\n    }),\n  };\n}\n\nexport async function listExportRequestsBackend({ ownerEmail } = {}) {\n  return await listCollectionRecords(getCollectionName(\"exports\"), {\n    filterField: ownerEmail ? \"requestedBy\" : undefined,\n    filterValue: ownerEmail ? normalizeEmail(ownerEmail) : undefined,\n  });\n}\n\nexport async function getExportRequestBackend(recordId) {\n  return await getCollectionRecordById(getCollectionName(\"exports\"), recordId);\n}\n\nexport async function createExportRequestBackend(payload, actorEmail) {\n  const normalized = normalizeExportRequestPayload(payload, actorEmail);\n  return await createCollectionRecord(getCollectionName(\"exports\"), normalized);\n}\n\nexport async function updateExportRequestBackend(recordId, payload, actorEmail) {\n  const current = await getExportRequestBackend(recordId);\n  if (!current) {\n    return null;\n  }\n  const normalized = normalizeExportRequestPayload(payload, actorEmail, { base: current });\n  return await updateCollectionRecord(getCollectionName(\"exports\"), recordId, normalized);\n}\n\nexport async function approveExportRequestBackend(recordId, actorEmail, { approved, note } = {}) {\n  const status = approved ? \"Approved\" : \"Rejected\";\n  return await updateExportRequestBackend(\n    recordId,\n    {\n      status,\n      reviewer: actorEmail,\n      reviewNote: asString(note, \"\"),\n      reviewedAt: nowIso(),\n    },\n    actorEmail,\n  );\n}\n\nexport async function markExportAsCompletedBackend(recordId, actorEmail) {\n  return await updateExportRequestBackend(\n    recordId,\n    {\n      status: \"Exported\",\n      exportedBy: actorEmail,\n      exportedAt: nowIso(),\n    },\n    actorEmail,\n  );\n}\n\nfunction normalizeIncidentSeverity(value, fallback = \"Medium\") {\n  const normalized = asString(value, fallback).toLowerCase();\n  const matched = INCIDENT_SEVERITY_LEVELS.find((entry) => entry.toLowerCase() === normalized);\n  return matched || \"Medium\";\n}\n\nfunction normalizeIncidentStatus(value, fallback = \"Open\") {\n  const normalized = asString(value, fallback).toLowerCase();\n  const matched = INCIDENT_STATUS_VALUES.find((entry) => entry.toLowerCase() === normalized);\n  return matched || \"Open\";\n}\n\nfunction normalizeIncidentContainmentStatus(value, fallback = \"Not Started\") {\n  const normalized = asString(value, fallback).toLowerCase();\n  const matched = INCIDENT_CONTAINMENT_STATUS_VALUES.find((entry) => entry.toLowerCase() === normalized);\n  return matched || \"Not Started\";\n}\n\nfunction normalizeIncidentImpactStatus(value, fallback = \"Pending\") {\n  const normalized = asString(value, fallback).toLowerCase();\n  const matched = INCIDENT_IMPACT_STATUS_VALUES.find((entry) => entry.toLowerCase() === normalized);\n  return matched || \"Pending\";\n}\n\nfunction normalizeIncidentType(value, fallback = \"Other\") {\n  const normalized = asString(value, fallback).toLowerCase();\n  const matched = INCIDENT_TYPE_VALUES.find((entry) => entry.toLowerCase() === normalized);\n  return matched || \"Other\";\n}\n\nfunction buildIncidentCode(isoValue = nowIso()) {\n  const date = new Date(isoValue || nowIso());\n  if (Number.isNaN(date.getTime())) {\n    return `INC-${Date.now().toString().slice(-10)}`;\n  }\n  const yyyy = String(date.getUTCFullYear());\n  const mm = String(date.getUTCMonth() + 1).padStart(2, \"0\");\n  const dd = String(date.getUTCDate()).padStart(2, \"0\");\n  const hh = String(date.getUTCHours()).padStart(2, \"0\");\n  const mi = String(date.getUTCMinutes()).padStart(2, \"0\");\n  const random = Math.random().toString(36).slice(2, 5).toUpperCase();\n  return `INC-${yyyy}${mm}${dd}-${hh}${mi}${random}`;\n}\n\nfunction extractEvidenceExtension(value) {\n  const normalized = asString(value).toLowerCase();\n  if (!normalized) {\n    return \"\";\n  }\n  const clean = normalized.split(\"?\")[0].split(\"#\")[0];\n  const token = clean.split(\".\").pop() || \"\";\n  if (!/^[a-z0-9]{2,10}$/.test(token)) {\n    return \"\";\n  }\n  return token;\n}\n\nfunction sanitizeIncidentEvidenceDocuments(value, actorEmail, fallbackNowIso) {\n  const timestamp = asString(fallbackNowIso, nowIso());\n  const config = getIncidentEvidenceValidationConfig();\n  return asArray(value)\n    .map((entry, index) => {\n      const source = asObject(entry, {});\n      const uploadedAt = toIsoOrEmpty(source.uploadedAt || timestamp) || timestamp;\n      const uploadedBy = normalizeEmail(source.uploadedBy || actorEmail);\n      const name = asString(source.name, `Incident Evidence ${index + 1}`);\n      const type = asString(source.type, \"Incident Evidence\");\n      const ref = asString(source.ref);\n      const storagePath = asString(source.storagePath);\n      const fileExtension = extractEvidenceExtension(source.fileExtension || name || storagePath || ref);\n      const contentType = normalizeText(source.contentType);\n      const sizeBytes = Number.isFinite(Number(source.sizeBytes)) ? Number(source.sizeBytes) : 0;\n      const id = asString(source.id || source.recordId || storagePath || `${index + 1}`);\n      if (!name && !ref && !storagePath) {\n        return null;\n      }\n      if (fileExtension && !config.allowedExtensions.has(fileExtension)) {\n        throw new Error(\"invalid_incident_evidence_extension\");\n      }\n      if (contentType && !config.allowedMimeTypes.has(contentType)) {\n        throw new Error(\"invalid_incident_evidence_content_type\");\n      }\n      if (sizeBytes > config.maxBytes) {\n        throw new Error(\"invalid_incident_evidence_size\");\n      }\n      return {\n        id,\n        name: name || \"Incident Evidence\",\n        type: type || \"Incident Evidence\",\n        ref,\n        storagePath,\n        fileExtension,\n        contentType,\n        sizeBytes,\n        scanStatus: asString(source.scanStatus),\n        scanReference: asString(source.scanReference),\n        scannedAt: toIsoOrEmpty(source.scannedAt || \"\"),\n        uploadedAt,\n        uploadedBy: uploadedBy || actorEmail,\n      };\n    })\n    .filter(Boolean)\n    .slice(0, MAX_INCIDENT_EVIDENCE_ITEMS);\n}\n\nfunction resolveIncidentEscalationLevel({ severity, restrictedPiiInvolved, executiveNotificationRequired }) {\n  if (severity === \"Critical\" || executiveNotificationRequired) {\n    return \"Executive\";\n  }\n  if (severity === \"High\" || restrictedPiiInvolved) {\n    return \"GRC\";\n  }\n  return \"Operational\";\n}\n\nfunction resolveIncidentRegulatoryStatus({\n  regulatoryNotificationRequired,\n  regulatoryNotifiedAt,\n  regulatoryDueAt,\n  nowIsoValue = nowIso(),\n}) {\n  if (!regulatoryNotificationRequired) {\n    return \"Not Required\";\n  }\n  if (toTimeMs(regulatoryNotifiedAt)) {\n    return \"Notified\";\n  }\n  const dueAtMs = toTimeMs(regulatoryDueAt);\n  const nowMs = toTimeMs(nowIsoValue) || Date.now();\n  if (Number.isFinite(dueAtMs) && dueAtMs < nowMs) {\n    return \"Overdue\";\n  }\n  return \"Pending\";\n}\n\nfunction incidentSeverityRank(value) {\n  const severity = normalizeIncidentSeverity(value);\n  switch (severity) {\n    case \"Critical\":\n      return 3;\n    case \"High\":\n      return 2;\n    case \"Medium\":\n      return 1;\n    default:\n      return 0;\n  }\n}\n\nfunction isIncidentAccessEvent(row) {\n  const method = normalizeText(row?.requestMethod);\n  const activity = normalizeText(row?.activityName);\n  return method === \"get\" || activity.includes(\"viewed\") || activity.includes(\"listed\") || activity.includes(\"access\");\n}\n\nfunction isIncidentExportEvent(row) {\n  const moduleName = normalizeText(row?.module);\n  const path = normalizeText(row?.requestPath);\n  const activity = normalizeText(row?.activityName);\n  return moduleName.includes(\"export\") || path.includes(\"/api/hris/exports\") || activity.includes(\"export\");\n}\n\nfunction isIncidentDeletionEvent(row) {\n  const method = normalizeText(row?.requestMethod);\n  const activity = normalizeText(row?.activityName);\n  return (\n    method === \"delete\" ||\n    activity.includes(\"delete\") ||\n    activity.includes(\"purge\") ||\n    activity.includes(\"removed\") ||\n    activity.includes(\"archive\")\n  );\n}\n\nfunction isIncidentAdministrativeEvent(row) {\n  const moduleName = normalizeText(row?.module);\n  const method = normalizeText(row?.requestMethod);\n  const activity = normalizeText(row?.activityName);\n  return (\n    moduleName.includes(\"authorization\") ||\n    moduleName.includes(\"user management\") ||\n    moduleName.includes(\"access management\") ||\n    method === \"patch\" ||\n    method === \"post\" ||\n    activity.includes(\"approve\") ||\n    activity.includes(\"revok\") ||\n    activity.includes(\"invite\") ||\n    activity.includes(\"role\")\n  );\n}\n\nfunction normalizeIncidentForensicSample(row) {\n  return {\n    id: asString(row?.id),\n    activityName: asString(row?.activityName),\n    module: asString(row?.module),\n    status: asString(row?.status),\n    occurredAt: asString(row?.occurredAt),\n    performedBy: asString(row?.performedBy),\n    requestMethod: asString(row?.requestMethod),\n    requestPath: asString(row?.requestPath),\n  };\n}\n\nfunction incidentMatchesSubject(row, subjectEmail) {\n  const subject = normalizeEmail(subjectEmail);\n  if (!subject) {\n    return true;\n  }\n\n  const metadata = asObject(row?.metadata, {});\n  const candidates = [\n    row?.performedBy,\n    row?.performedByEmail,\n    metadata.employeeEmail,\n    metadata.ownerEmail,\n    metadata.requestedBy,\n    metadata.targetEmployeeEmail,\n    metadata.affectedEmployeeEmail,\n  ];\n  return candidates.some((value) => normalizeEmail(value) === subject);\n}\n\nasync function buildIncidentForensicSnapshot(record, { limit } = {}) {\n  const nowIsoValue = nowIso();\n  const windowStart = toIsoOrEmpty(record?.forensicWindowStart || record?.detectedAt) || nowIsoValue;\n  const windowEnd = toIsoOrEmpty(record?.forensicWindowEnd || nowIsoValue) || nowIsoValue;\n  const windowStartMs = toTimeMs(windowStart) || 0;\n  const windowEndMs = toTimeMs(windowEnd) || Date.now();\n  const subjectEmail = normalizeEmail(record?.affectedEmployeeEmail || record?.employeeEmail || \"\");\n  const safeLimit = Number.isFinite(Number(limit)) ? Number(limit) : 1800;\n\n  let rows = [];\n  try {\n    rows = await listAuditEvents({ limit: Math.max(100, Math.min(5000, safeLimit)) });\n  } catch {\n    rows = [];\n  }\n\n  const scopedRows = rows.filter((row) => {\n    const occurredAtMs = toTimeMs(row?.occurredAt || row?.loggedAt);\n    if (!Number.isFinite(occurredAtMs)) {\n      return false;\n    }\n    if (occurredAtMs < windowStartMs || occurredAtMs > windowEndMs) {\n      return false;\n    }\n    return incidentMatchesSubject(row, subjectEmail);\n  });\n\n  const buckets = {\n    accessLogs: [],\n    exportLogs: [],\n    administrativeActions: [],\n    deletionActivities: [],\n  };\n\n  scopedRows.forEach((row) => {\n    const sample = normalizeIncidentForensicSample(row);\n    if (isIncidentDeletionEvent(row)) {\n      buckets.deletionActivities.push(sample);\n      return;\n    }\n    if (isIncidentExportEvent(row)) {\n      buckets.exportLogs.push(sample);\n      return;\n    }\n    if (isIncidentAdministrativeEvent(row)) {\n      buckets.administrativeActions.push(sample);\n      return;\n    }\n    if (isIncidentAccessEvent(row)) {\n      buckets.accessLogs.push(sample);\n    }\n  });\n\n  return {\n    generatedAt: nowIsoValue,\n    windowStart,\n    windowEnd,\n    scopedSubjectEmail: subjectEmail || \"\",\n    totalScopedLogs: scopedRows.length,\n    accessLogsCount: buckets.accessLogs.length,\n    exportLogsCount: buckets.exportLogs.length,\n    administrativeActionsCount: buckets.administrativeActions.length,\n    deletionActivitiesCount: buckets.deletionActivities.length,\n    accessLogs: buckets.accessLogs.slice(0, MAX_INCIDENT_FORENSIC_SAMPLES),\n    exportLogs: buckets.exportLogs.slice(0, MAX_INCIDENT_FORENSIC_SAMPLES),\n    administrativeActions: buckets.administrativeActions.slice(0, MAX_INCIDENT_FORENSIC_SAMPLES),\n    deletionActivities: buckets.deletionActivities.slice(0, MAX_INCIDENT_FORENSIC_SAMPLES),\n  };\n}\n\nfunction normalizeIncidentWritePayload(payload, actorEmail, { base } = {}) {\n  const timestamp = nowIso();\n  const title = asString(payload?.title, asString(base?.title));\n  if (!title) {\n    throw new Error(\"invalid_incident_title\");\n  }\n\n  const detectedAt = toIsoOrEmpty(payload?.detectedAt || base?.detectedAt || timestamp) || timestamp;\n  const severity = normalizeIncidentSeverity(payload?.severity, asString(base?.severity, \"Medium\"));\n  const incidentType = normalizeIncidentType(payload?.incidentType, asString(base?.incidentType, \"Other\"));\n  const restrictedPiiInvolved = asBoolean(payload?.restrictedPiiInvolved, asBoolean(base?.restrictedPiiInvolved, false));\n  const executiveNotificationRequired = asBoolean(\n    payload?.executiveNotificationRequired,\n    severity === \"Critical\" || asBoolean(base?.executiveNotificationRequired, false),\n  );\n  const escalationRequired = asBoolean(\n    payload?.escalationRequired,\n    executiveNotificationRequired ||\n      restrictedPiiInvolved ||\n      incidentSeverityRank(severity) >= incidentSeverityRank(\"High\") ||\n      asBoolean(base?.escalationRequired, false),\n  );\n  const escalationLevel = resolveIncidentEscalationLevel({\n    severity,\n    restrictedPiiInvolved,\n    executiveNotificationRequired,\n  });\n\n  const status = normalizeIncidentStatus(payload?.status, asString(base?.status, \"Open\"));\n  const containmentStatus = normalizeIncidentContainmentStatus(\n    payload?.containmentStatus,\n    asString(base?.containmentStatus, \"Not Started\"),\n  );\n  const impactAssessmentStatus = normalizeIncidentImpactStatus(\n    payload?.impactAssessmentStatus,\n    asString(base?.impactAssessmentStatus, \"Pending\"),\n  );\n\n  const regulatoryNotificationRequired = asBoolean(\n    payload?.regulatoryNotificationRequired,\n    restrictedPiiInvolved || asBoolean(base?.regulatoryNotificationRequired, false),\n  );\n  const regulatoryDueAt = regulatoryNotificationRequired\n    ? asString(base?.regulatoryDueAt, addHoursToIso(detectedAt, 72))\n    : \"\";\n  const regulatoryNotifiedAt = toIsoOrEmpty(payload?.regulatoryNotifiedAt || base?.regulatoryNotifiedAt || \"\");\n  const affectedIndividualsNotifiedAt = toIsoOrEmpty(\n    payload?.affectedIndividualsNotifiedAt || base?.affectedIndividualsNotifiedAt || \"\",\n  );\n  const regulatoryStatus = resolveIncidentRegulatoryStatus({\n    regulatoryNotificationRequired,\n    regulatoryNotifiedAt,\n    regulatoryDueAt,\n    nowIsoValue: timestamp,\n  });\n\n  const documentationRetained = asBoolean(payload?.documentationRetained, asBoolean(base?.documentationRetained, false));\n  const documentationRetainedAt = documentationRetained\n    ? toIsoOrEmpty(payload?.documentationRetainedAt || base?.documentationRetainedAt || timestamp) || timestamp\n    : \"\";\n  const executiveNotifiedAt = toIsoOrEmpty(payload?.executiveNotifiedAt || base?.executiveNotifiedAt || \"\");\n  const grcAlertedAt = escalationRequired\n    ? toIsoOrEmpty(payload?.grcAlertedAt || base?.grcAlertedAt || timestamp) || timestamp\n    : \"\";\n\n  const containmentStartedAt =\n    containmentStatus === \"In Progress\" || containmentStatus === \"Contained\"\n      ? toIsoOrEmpty(payload?.containmentStartedAt || base?.containmentStartedAt || timestamp) || timestamp\n      : toIsoOrEmpty(payload?.containmentStartedAt || base?.containmentStartedAt || \"\");\n  const containmentCompletedAt =\n    containmentStatus === \"Contained\"\n      ? toIsoOrEmpty(payload?.containmentCompletedAt || base?.containmentCompletedAt || timestamp) || timestamp\n      : toIsoOrEmpty(payload?.containmentCompletedAt || base?.containmentCompletedAt || \"\");\n  const impactAssessmentCompletedAt =\n    impactAssessmentStatus === \"Completed\"\n      ? toIsoOrEmpty(payload?.impactAssessmentCompletedAt || base?.impactAssessmentCompletedAt || timestamp) || timestamp\n      : toIsoOrEmpty(payload?.impactAssessmentCompletedAt || base?.impactAssessmentCompletedAt || \"\");\n\n  const forensicWindowStart = toIsoOrEmpty(payload?.forensicWindowStart || base?.forensicWindowStart || detectedAt) || detectedAt;\n  const forensicWindowEnd = toIsoOrEmpty(payload?.forensicWindowEnd || base?.forensicWindowEnd || timestamp) || timestamp;\n  const evidenceDocuments = sanitizeIncidentEvidenceDocuments(\n    Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"evidenceDocuments\")\n      ? payload?.evidenceDocuments\n      : base?.evidenceDocuments,\n    actorEmail,\n    timestamp,\n  );\n  const detectionWindowStart = toIsoOrEmpty(payload?.detectionWindowStart || base?.detectionWindowStart || \"\");\n  const detectionWindowEnd = toIsoOrEmpty(payload?.detectionWindowEnd || base?.detectionWindowEnd || \"\");\n  const alertRecipients = asArray(payload?.alertRecipients || base?.alertRecipients)\n    .map((value) => normalizeEmail(value))\n    .filter(Boolean)\n    .slice(0, 40);\n\n  return {\n    incidentCode: asString(base?.incidentCode, buildIncidentCode(detectedAt)),\n    title,\n    summary: asString(payload?.summary, asString(base?.summary)),\n    incidentType,\n    severity,\n    status,\n    restrictedPiiInvolved,\n    affectedEmployeeEmail: normalizeEmail(payload?.affectedEmployeeEmail || base?.affectedEmployeeEmail),\n    ownerEmail: normalizeEmail(payload?.ownerEmail || base?.ownerEmail || actorEmail),\n    escalationRequired,\n    escalationLevel,\n    executiveNotificationRequired,\n    executiveNotifiedAt,\n    grcAlertedAt,\n    containmentStatus,\n    containmentSummary: asString(payload?.containmentSummary, asString(base?.containmentSummary)),\n    containmentStartedAt,\n    containmentCompletedAt,\n    impactAssessmentStatus,\n    impactSummary: asString(payload?.impactSummary, asString(base?.impactSummary)),\n    impactAssessmentCompletedAt,\n    regulatoryNotificationRequired,\n    regulatoryDueAt,\n    regulatoryNotifiedAt,\n    affectedIndividualsNotifiedAt,\n    regulatoryStatus,\n    documentationRetained,\n    documentationRetainedAt,\n    documentationLocation: asString(payload?.documentationLocation, asString(base?.documentationLocation)),\n    forensicWindowStart,\n    forensicWindowEnd,\n    evidenceDocuments,\n    evidenceDocumentsCount: evidenceDocuments.length,\n    notes: asString(payload?.notes, asString(base?.notes)),\n    classificationStandard: asString(payload?.classificationStandard, asString(base?.classificationStandard, \"CLIO-IR-SEVERITY-V1\")),\n    autoGenerated: asBoolean(payload?.autoGenerated, asBoolean(base?.autoGenerated, false)),\n    detectionRuleId: asString(payload?.detectionRuleId, asString(base?.detectionRuleId)),\n    detectionFingerprint: asString(payload?.detectionFingerprint, asString(base?.detectionFingerprint)),\n    detectionWindowStart,\n    detectionWindowEnd,\n    sourceSystem: asString(payload?.sourceSystem, asString(base?.sourceSystem)),\n    sourceEventId: asString(payload?.sourceEventId, asString(base?.sourceEventId)),\n    sourceEventModule: asString(payload?.sourceEventModule, asString(base?.sourceEventModule)),\n    sourceEventPath: asString(payload?.sourceEventPath, asString(base?.sourceEventPath)),\n    sourceIp: asString(payload?.sourceIp, asString(base?.sourceIp)),\n    alertRecipients,\n    alertDispatchSummary: asObject(payload?.alertDispatchSummary, asObject(base?.alertDispatchSummary, {})),\n    externalIntegrations: asObject(payload?.externalIntegrations, asObject(base?.externalIntegrations, {})),\n    lastAlertDispatchAt: toIsoOrEmpty(payload?.lastAlertDispatchAt || base?.lastAlertDispatchAt || \"\"),\n    detectedAt,\n    resolvedAt: toIsoOrEmpty(payload?.resolvedAt || base?.resolvedAt || (status === \"Resolved\" ? timestamp : \"\")),\n    closedAt: toIsoOrEmpty(payload?.closedAt || base?.closedAt || (status === \"Closed\" ? timestamp : \"\")),\n    createdAt: asString(base?.createdAt, timestamp),\n    createdBy: asString(base?.createdBy, actorEmail),\n    updatedAt: timestamp,\n    updatedBy: actorEmail,\n    traceability: appendTrail(base?.traceability, {\n      at: timestamp,\n      by: actorEmail,\n      action: base ? \"update\" : \"create\",\n      status,\n      severity,\n      escalationLevel,\n      regulatoryStatus,\n    }),\n  };\n}\n\nfunction withIncidentForensic(record, forensicSnapshot, actorEmail) {\n  const snapshot = asObject(forensicSnapshot, {});\n  return {\n    ...record,\n    forensicSnapshot: snapshot,\n    forensicSummary: {\n      accessLogsCount: Number(snapshot.accessLogsCount || 0),\n      exportLogsCount: Number(snapshot.exportLogsCount || 0),\n      administrativeActionsCount: Number(snapshot.administrativeActionsCount || 0),\n      deletionActivitiesCount: Number(snapshot.deletionActivitiesCount || 0),\n      totalScopedLogs: Number(snapshot.totalScopedLogs || 0),\n      generatedAt: asString(snapshot.generatedAt),\n      windowStart: asString(snapshot.windowStart),\n      windowEnd: asString(snapshot.windowEnd),\n    },\n    forensicLastUpdatedAt: asString(snapshot.generatedAt, nowIso()),\n    forensicLastUpdatedBy: actorEmail,\n  };\n}\n\nexport async function listIncidentRecordsBackend() {\n  return await listCollectionRecords(getCollectionName(\"incidents\"));\n}\n\nexport async function getIncidentRecordBackend(recordId) {\n  return await getCollectionRecordById(getCollectionName(\"incidents\"), recordId);\n}\n\nexport async function createIncidentRecordBackend(payload, actorEmail) {\n  const normalized = normalizeIncidentWritePayload(payload, actorEmail);\n  const forensicSnapshot = await buildIncidentForensicSnapshot(normalized, {\n    limit: Number.parseInt(env(\"CLIO_INCIDENT_FORENSIC_LOG_LIMIT\", \"1800\"), 10),\n  });\n  const withForensic = withIncidentForensic(normalized, forensicSnapshot, actorEmail);\n  return await createCollectionRecord(getCollectionName(\"incidents\"), withForensic);\n}\n\nexport async function updateIncidentRecordBackend(recordId, payload, actorEmail) {\n  const current = await getIncidentRecordBackend(recordId);\n  if (!current) {\n    return null;\n  }\n  const normalized = normalizeIncidentWritePayload(payload, actorEmail, { base: current });\n  const shouldRefreshForensic =\n    asBoolean(payload?.refreshForensicSnapshot, false) ||\n    Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"forensicWindowStart\") ||\n    Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"forensicWindowEnd\") ||\n    Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"affectedEmployeeEmail\") ||\n    Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"detectedAt\");\n\n  const forensicSnapshot = shouldRefreshForensic\n    ? await buildIncidentForensicSnapshot(normalized, {\n        limit: Number.parseInt(env(\"CLIO_INCIDENT_FORENSIC_LOG_LIMIT\", \"1800\"), 10),\n      })\n    : asObject(current.forensicSnapshot, {});\n  const withForensic = withIncidentForensic(normalized, forensicSnapshot, actorEmail);\n  return await updateCollectionRecord(getCollectionName(\"incidents\"), recordId, withForensic);\n}\n\nasync function purgeCollectionByRetention(collectionName, cutoff) {\n  const db = getDbOrThrow();\n  const snapshot = await getDocs(\n    query(collection(db, collectionName), where(\"retentionDeleteAt\", \"<=\", cutoff)),\n  );\n  let deleted = 0;\n  for (const recordSnapshot of snapshot.docs) {\n    await deleteDoc(doc(db, collectionName, recordSnapshot.id));\n    deleted += 1;\n  }\n  return deleted;\n}\n\nasync function purgeEmployeeCollectionByRetention(cutoff) {\n  const db = getDbOrThrow();\n  const employeesCollection = getCollectionName(\"employees\");\n  const snapshot = await getDocs(\n    query(collection(db, employeesCollection), where(\"retentionDeleteAt\", \"<=\", cutoff)),\n  );\n\n  let deleted = 0;\n  for (const recordSnapshot of snapshot.docs) {\n    await deleteEmployeeDocumentSubcollectionById(recordSnapshot.id, { db });\n    await deleteDoc(doc(db, employeesCollection, recordSnapshot.id));\n    deleted += 1;\n  }\n  return deleted;\n}\n\nexport async function purgeArchivedEmployeeDataBackend({ now } = {}) {\n  const cutoff = asString(now, nowIso());\n  const deletedByCollection = {\n    employees: await purgeEmployeeCollectionByRetention(cutoff),\n    lifecycle: await purgeCollectionByRetention(getCollectionName(\"lifecycle\"), cutoff),\n    attendance: await purgeCollectionByRetention(getCollectionName(\"attendance\"), cutoff),\n    leave: await purgeCollectionByRetention(getCollectionName(\"leave\"), cutoff),\n    performance: await purgeCollectionByRetention(getCollectionName(\"performance\"), cutoff),\n    exports: await purgeCollectionByRetention(getCollectionName(\"exports\"), cutoff),\n  };\n\n  const deletedUsers = await purgeDueArchivedUserAccounts({ now: cutoff });\n  return {\n    cutoff,\n    deletedByCollection,\n    deletedUsers,\n  };\n}\n\nfunction toTimeMs(value) {\n  const timestamp = new Date(value || \"\").getTime();\n  return Number.isNaN(timestamp) ? null : timestamp;\n}\n\nfunction toIsoOrEmpty(value) {\n  const timestamp = toTimeMs(value);\n  if (!Number.isFinite(timestamp)) {\n    return \"\";\n  }\n  return new Date(timestamp).toISOString();\n}\n\nfunction clampInt(value, fallback, { min = 0, max = Number.MAX_SAFE_INTEGER } = {}) {\n  const parsed = Number.parseInt(String(value ?? \"\"), 10);\n  if (!Number.isFinite(parsed)) {\n    return fallback;\n  }\n  return Math.min(max, Math.max(min, parsed));\n}\n\nfunction deriveRetentionState(retentionDeleteAt, nowMs, dueWithinMs) {\n  const retentionMs = toTimeMs(retentionDeleteAt);\n  if (!Number.isFinite(retentionMs)) {\n    return {\n      state: \"no_retention\",\n      daysToDeletion: null,\n    };\n  }\n\n  const daysToDeletion = Math.ceil((retentionMs - nowMs) / (24 * 60 * 60 * 1000));\n  if (retentionMs <= nowMs) {\n    return {\n      state: \"due\",\n      daysToDeletion,\n    };\n  }\n\n  if (retentionMs <= nowMs + dueWithinMs) {\n    return {\n      state: \"due_soon\",\n      daysToDeletion,\n    };\n  }\n\n  return {\n    state: \"scheduled\",\n    daysToDeletion,\n  };\n}\n\nfunction getRetentionRecordLabel(moduleId, row, moduleLabel) {\n  const recordId = asString(row?.recordId, asString(row?.id));\n  if (moduleId === \"employees\") {\n    return asString(row?.name, asString(row?.employeeId, asString(row?.email, recordId || `${moduleLabel} Record`)));\n  }\n  if (moduleId === \"lifecycle\") {\n    const employee = asString(row?.employee, asString(row?.employeeEmail));\n    const category = asString(row?.category);\n    return [employee || \"Employee\", category].filter(Boolean).join(\" - \");\n  }\n  if (moduleId === \"attendance\") {\n    return [asString(row?.employee, \"Employee\"), asString(row?.date)].filter(Boolean).join(\" - \");\n  }\n  if (moduleId === \"leave\") {\n    return [asString(row?.employee, \"Employee\"), asString(row?.leaveType, \"Leave\")].filter(Boolean).join(\" - \");\n  }\n  if (moduleId === \"performance\") {\n    return [asString(row?.employee, \"Employee\"), asString(row?.period, \"Performance\")].filter(Boolean).join(\" - \");\n  }\n  if (moduleId === \"exports\") {\n    return [asString(row?.dataset, \"Export Request\"), asString(row?.format)].filter(Boolean).join(\" - \");\n  }\n  if (moduleId === \"user_accounts\") {\n    return asString(row?.email, recordId || \"User Account\");\n  }\n\n  return asString(\n    row?.name,\n    asString(row?.employee, asString(row?.dataset, asString(row?.email, recordId || `${moduleLabel} Record`))),\n  );\n}\n\nfunction toRetentionArchiveRecord({ moduleId, moduleLabel, row, nowMs, dueWithinMs }) {\n  const archivedAt = toIsoOrEmpty(row?.archivedAt);\n  const retentionDeleteAt = toIsoOrEmpty(row?.retentionDeleteAt);\n  const normalizedStatus = normalizeText(row?.status);\n  const normalizedArchiveStatus = normalizeText(row?.archiveStatus);\n  const isArchived = Boolean(\n    row?.isArchived ||\n      archivedAt ||\n      retentionDeleteAt ||\n      normalizedStatus === \"archived\" ||\n      normalizedArchiveStatus === \"archived\",\n  );\n  if (!isArchived) {\n    return null;\n  }\n\n  const recordId = asString(row?.recordId, asString(row?.id));\n  const retention = deriveRetentionState(retentionDeleteAt, nowMs, dueWithinMs);\n  const label = getRetentionRecordLabel(moduleId, row, moduleLabel);\n  const ownerEmail = normalizeEmail(row?.employeeEmail || row?.email || row?.requestedBy || row?.ownerEmail);\n  const subtitleParts = [\n    asString(row?.employeeId),\n    ownerEmail,\n    asString(row?.department),\n    asString(row?.category),\n  ].filter(Boolean);\n\n  return {\n    id: `${moduleId}:${recordId || Math.random().toString(36).slice(2, 10)}`,\n    moduleId,\n    moduleLabel,\n    recordId: recordId || \"\",\n    title: label,\n    subtitle: subtitleParts.join(\" | \"),\n    ownerEmail: ownerEmail || \"\",\n    status: asString(row?.status, asString(row?.archiveStatus, \"Archived\")),\n    archiveReason: asString(row?.archiveReason, asString(row?.reason, asString(row?.reviewNote, \"\"))),\n    archivedAt,\n    retentionDeleteAt,\n    daysToDeletion: retention.daysToDeletion,\n    deletionState: retention.state,\n    updatedAt: toIsoOrEmpty(row?.updatedAt),\n  };\n}\n\nfunction summarizeRetentionRecords(records, { moduleCatalog, nowMs, dueWithinDays }) {\n  const dueCounts = {\n    due: 0,\n    dueSoon: 0,\n    scheduled: 0,\n    noRetention: 0,\n  };\n\n  const moduleCounts = moduleCatalog.map((module) => ({\n    id: module.id,\n    label: module.label,\n    count: 0,\n  }));\n  const moduleCountById = new Map(moduleCounts.map((item) => [item.id, item]));\n\n  let nextDeletionAt = \"\";\n  let oldestArchivedAt = \"\";\n\n  records.forEach((record) => {\n    if (record.deletionState === \"due\") {\n      dueCounts.due += 1;\n    } else if (record.deletionState === \"due_soon\") {\n      dueCounts.dueSoon += 1;\n    } else if (record.deletionState === \"scheduled\") {\n      dueCounts.scheduled += 1;\n    } else {\n      dueCounts.noRetention += 1;\n    }\n\n    const moduleCount = moduleCountById.get(record.moduleId);\n    if (moduleCount) {\n      moduleCount.count += 1;\n    }\n\n    if (record.retentionDeleteAt) {\n      if (!nextDeletionAt || toTimeMs(record.retentionDeleteAt) < toTimeMs(nextDeletionAt)) {\n        nextDeletionAt = record.retentionDeleteAt;\n      }\n    }\n\n    if (record.archivedAt) {\n      if (!oldestArchivedAt || toTimeMs(record.archivedAt) < toTimeMs(oldestArchivedAt)) {\n        oldestArchivedAt = record.archivedAt;\n      }\n    }\n  });\n\n  return {\n    generatedAt: new Date(nowMs).toISOString(),\n    totalArchived: records.length,\n    dueNow: dueCounts.due,\n    dueWithinWindow: dueCounts.due + dueCounts.dueSoon,\n    scheduledFuture: dueCounts.scheduled,\n    missingRetentionDate: dueCounts.noRetention,\n    nextDeletionAt: nextDeletionAt || null,\n    oldestArchivedAt: oldestArchivedAt || null,\n    dueWithinDays,\n    moduleBreakdown: moduleCounts.sort((left, right) => right.count - left.count),\n  };\n}\n\nfunction sortRetentionRecords(records) {\n  const stateRank = {\n    due: 0,\n    due_soon: 1,\n    scheduled: 2,\n    no_retention: 3,\n  };\n\n  return [...records].sort((left, right) => {\n    const leftRank = stateRank[left.deletionState] ?? 9;\n    const rightRank = stateRank[right.deletionState] ?? 9;\n    if (leftRank !== rightRank) {\n      return leftRank - rightRank;\n    }\n\n    const leftRetention = toTimeMs(left.retentionDeleteAt);\n    const rightRetention = toTimeMs(right.retentionDeleteAt);\n    if (Number.isFinite(leftRetention) && Number.isFinite(rightRetention) && leftRetention !== rightRetention) {\n      return leftRetention - rightRetention;\n    }\n    if (Number.isFinite(leftRetention) && !Number.isFinite(rightRetention)) {\n      return -1;\n    }\n    if (!Number.isFinite(leftRetention) && Number.isFinite(rightRetention)) {\n      return 1;\n    }\n\n    return (toTimeMs(right.archivedAt) || 0) - (toTimeMs(left.archivedAt) || 0);\n  });\n}\n\nexport async function listRetentionArchiveSnapshotBackend({\n  moduleId = \"all\",\n  status = \"all\",\n  queryText = \"\",\n  dueWithinDays = 30,\n  now,\n} = {}) {\n  const normalizedModuleId = normalizeText(moduleId) || \"all\";\n  const normalizedStatus = normalizeText(status) || \"all\";\n  const normalizedQuery = normalizeText(queryText);\n  const retentionYears = getArchiveRetentionYears();\n  const safeDueWithinDays = clampInt(dueWithinDays, 30, { min: 1, max: 365 });\n  const nowIsoValue = toIsoOrEmpty(now) || nowIso();\n  const nowMs = toTimeMs(nowIsoValue) || Date.now();\n  const dueWithinMs = safeDueWithinDays * 24 * 60 * 60 * 1000;\n\n  const moduleCatalog = [\n    { id: \"employees\", label: \"Employee Records\", loader: () => listEmployeeRecordsBackend() },\n    { id: \"lifecycle\", label: \"Employment Lifecycle\", loader: () => listLifecycleRecordsBackend() },\n    { id: \"attendance\", label: \"Attendance\", loader: () => listAttendanceLogsBackend() },\n    { id: \"leave\", label: \"Leave Requests\", loader: () => listLeaveRequestsBackend() },\n    { id: \"performance\", label: \"Performance\", loader: () => listPerformanceRecordsBackend() },\n    { id: \"exports\", label: \"Reports & Exports\", loader: () => listExportRequestsBackend() },\n    { id: \"user_accounts\", label: \"User Accounts\", loader: () => listUserAccounts() },\n  ];\n\n  const moduleIds = new Set(moduleCatalog.map((item) => item.id));\n  if (normalizedModuleId !== \"all\" && !moduleIds.has(normalizedModuleId)) {\n    throw new Error(\"invalid_retention_module\");\n  }\n\n  const supportedStatusFilters = new Set([\"all\", \"due\", \"due_soon\", \"scheduled\", \"no_retention\"]);\n  const effectiveStatus = supportedStatusFilters.has(normalizedStatus) ? normalizedStatus : \"all\";\n\n  const loaded = await Promise.all(\n    moduleCatalog.map(async (module) => {\n      const rows = await module.loader();\n      return {\n        ...module,\n        rows: Array.isArray(rows) ? rows : [],\n      };\n    }),\n  );\n\n  const archivedRecords = loaded.flatMap((module) =>\n    module.rows\n      .map((row) =>\n        toRetentionArchiveRecord({\n          moduleId: module.id,\n          moduleLabel: module.label,\n          row,\n          nowMs,\n          dueWithinMs,\n        }),\n      )\n      .filter(Boolean),\n  );\n\n  const moduleScopedRecords =\n    normalizedModuleId === \"all\"\n      ? archivedRecords\n      : archivedRecords.filter((record) => record.moduleId === normalizedModuleId);\n\n  const filteredRecords = moduleScopedRecords.filter((record) => {\n    const byStatus = effectiveStatus === \"all\" ? true : record.deletionState === effectiveStatus;\n    const textBlob = normalizeText(\n      [\n        record.moduleLabel,\n        record.recordId,\n        record.title,\n        record.subtitle,\n        record.ownerEmail,\n        record.archiveReason,\n      ].join(\" \"),\n    );\n    const byQuery = normalizedQuery ? textBlob.includes(normalizedQuery) : true;\n    return byStatus && byQuery;\n  });\n\n  return {\n    policy: {\n      retentionYears,\n      dueWithinDays: safeDueWithinDays,\n      generatedAt: nowIsoValue,\n      moduleCatalog: moduleCatalog.map((module) => ({\n        id: module.id,\n        label: module.label,\n      })),\n    },\n    summary: summarizeRetentionRecords(moduleScopedRecords, {\n      moduleCatalog,\n      nowMs,\n      dueWithinDays: safeDueWithinDays,\n    }),\n    records: sortRetentionRecords(filteredRecords),\n  };\n}\n","function normalizeEmailProvider(rawValue) {\n  const raw = String(rawValue || \"\")\n    .trim()\n    .toLowerCase();\n  if (!raw) {\n    return \"firebase\";\n  }\n\n  if (raw === \"firebase\" || raw.includes(\"firebase\")) {\n    return \"firebase\";\n  }\n\n  if (raw === \"resend\" || raw.includes(\"resend\")) {\n    return \"resend\";\n  }\n\n  if (raw === \"console\" || raw === \"dev\" || raw.includes(\"console\")) {\n    return \"console\";\n  }\n\n  return raw;\n}\n\nfunction getEmailProvider() {\n  return normalizeEmailProvider(process.env.CLIO_EMAIL_PROVIDER);\n}\n\nfunction isConsoleEmailAllowed() {\n  return String(process.env.CLIO_ALLOW_CONSOLE_EMAIL || \"\")\n    .trim()\n    .toLowerCase() === \"true\";\n}\n\nfunction getAppBaseUrl() {\n  const configured = String(process.env.CLIO_APP_BASE_URL || \"\").trim();\n  if (configured) {\n    return configured.replace(/\\/+$/, \"\");\n  }\n  return \"http://localhost:3000\";\n}\n\nfunction getLoginPath() {\n  const configured = String(process.env.CLIO_LOGIN_PATH || \"\").trim();\n  if (!configured) {\n    return \"/login\";\n  }\n  return configured.startsWith(\"/\") ? configured : `/${configured}`;\n}\n\nfunction getInviteVerifyPath() {\n  const configured = String(process.env.CLIO_INVITE_VERIFY_PATH || \"\").trim();\n  if (!configured) {\n    return \"/verify-invite\";\n  }\n  return configured.startsWith(\"/\") ? configured : `/${configured}`;\n}\n\nfunction buildLoginUrl() {\n  const baseUrl = getAppBaseUrl();\n  return `${baseUrl}${getLoginPath()}`;\n}\n\nfunction buildInviteVerificationUrl(inviteToken) {\n  const baseUrl = getAppBaseUrl();\n  const path = getInviteVerifyPath();\n  const token = String(inviteToken || \"\").trim();\n  if (!token) {\n    throw new Error(\"invalid_invite_token\");\n  }\n  return `${baseUrl}${path}?token=${encodeURIComponent(token)}`;\n}\n\nfunction isDevelopmentPreviewEnabled() {\n  return process.env.NODE_ENV !== \"production\";\n}\n\nfunction buildEmailContent({ role, invitedBy, verifyUrl, loginUrl, expiresAt }) {\n  const expirationDate = new Date(expiresAt);\n  const readableExpiration = Number.isNaN(expirationDate.getTime())\n    ? expiresAt\n    : expirationDate.toLocaleString(\"en-US\", {\n        month: \"short\",\n        day: \"2-digit\",\n        year: \"numeric\",\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n      });\n\n  const subject = \"You are invited to CLIO HRIS\";\n  const text = [\n    \"You were invited to access CLIO HRIS.\",\n    `Assigned role: ${role}`,\n    `Invited by: ${invitedBy}`,\n    `Verify your email: ${verifyUrl}`,\n    `Sign-in page: ${loginUrl}`,\n    `Invitation expires: ${readableExpiration}`,\n    \"\",\n    \"Step 1: Open the verification link and complete email verification.\",\n    \"Step 2: After verification, sign in using Google with the same invited work email.\",\n    \"Only invited accounts can access the workspace.\",\n  ].join(\"\\n\");\n\n  return {\n    subject,\n    text,\n    html: [\n      \"<p>You were invited to access <strong>CLIO HRIS</strong>.</p>\",\n      `<p><strong>Assigned role:</strong> ${role}<br/>`,\n      `<strong>Invited by:</strong> ${invitedBy}<br/>`,\n      `<strong>Invitation expires:</strong> ${readableExpiration}</p>`,\n      `<p><a href=\"${verifyUrl}\">Verify your email</a></p>`,\n      `<p><a href=\"${loginUrl}\">Open CLIO sign-in</a></p>`,\n      \"<p>After verification, sign in using Google with the same invited work email.</p>\",\n    ].join(\"\"),\n  };\n}\n\nfunction parseFirebaseAuthError(payload) {\n  const code = String(payload?.error?.message || \"\").trim();\n  if (!code) {\n    return \"email_delivery_failed\";\n  }\n  if (code === \"OPERATION_NOT_ALLOWED\") {\n    return \"firebase_email_provider_not_enabled\";\n  }\n  if (code === \"MISSING_CONTINUE_URI\" || code === \"INVALID_CONTINUE_URI\") {\n    return \"firebase_continue_url_invalid\";\n  }\n  if (code === \"INVALID_EMAIL\") {\n    return \"invalid_email\";\n  }\n  if (code === \"PROJECT_NOT_FOUND\" || code === \"API_KEY_INVALID\") {\n    return \"firebase_api_key_not_configured\";\n  }\n  return \"email_delivery_failed\";\n}\n\nasync function sendViaFirebaseAuth({ toEmail, verifyUrl }) {\n  const apiKey = String(process.env.NEXT_PUBLIC_FIREBASE_API_KEY || \"\").trim();\n  if (!apiKey) {\n    throw new Error(\"firebase_api_key_not_configured\");\n  }\n\n  const response = await fetch(`https://identitytoolkit.googleapis.com/v1/accounts:sendOobCode?key=${apiKey}`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      requestType: \"EMAIL_SIGNIN\",\n      email: toEmail,\n      continueUrl: verifyUrl,\n      canHandleCodeInApp: true,\n    }),\n  });\n\n  const payload = await response.json().catch(() => ({}));\n  if (!response.ok) {\n    throw new Error(parseFirebaseAuthError(payload));\n  }\n\n  return {\n    provider: \"firebase\",\n    status: \"sent\",\n    messageId: `firebase-${Date.now()}`,\n  };\n}\n\nasync function sendViaResend({ toEmail, subject, html, text }) {\n  const apiKey = String(process.env.RESEND_API_KEY || \"\").trim();\n  const fromAddress = String(process.env.CLIO_EMAIL_FROM || \"\").trim();\n  if (!apiKey || !fromAddress || !apiKey.startsWith(\"re_\")) {\n    throw new Error(\"email_provider_not_configured\");\n  }\n\n  const response = await fetch(\"https://api.resend.com/emails\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${apiKey}`,\n    },\n    body: JSON.stringify({\n      from: fromAddress,\n      to: [toEmail],\n      subject,\n      html,\n      text,\n    }),\n  });\n\n  if (!response.ok) {\n    const payload = await response.json().catch(() => ({}));\n    const providerMessage =\n      typeof payload?.message === \"string\"\n        ? payload.message\n        : typeof payload?.error?.message === \"string\"\n          ? payload.error.message\n          : \"\";\n    throw new Error(\n      providerMessage ? `email_delivery_failed:${providerMessage}` : \"email_delivery_failed\",\n    );\n  }\n\n  const payload = await response.json().catch(() => ({}));\n  return {\n    provider: \"resend\",\n    status: \"sent\",\n    messageId: typeof payload?.id === \"string\" ? payload.id : `resend-${Date.now()}`,\n  };\n}\n\nfunction sendViaConsole({ toEmail, subject, verifyUrl, loginUrl }) {\n  const messageId = `console-${Date.now()}`;\n  if (isDevelopmentPreviewEnabled()) {\n    console.info(\"[CLIO:InviteEmail]\", {\n      toEmail,\n      subject,\n      verifyUrl,\n      loginUrl,\n      messageId,\n    });\n  }\n\n  return {\n    provider: \"console\",\n    status: \"simulated\",\n    messageId,\n    previewUrl: verifyUrl,\n    loginUrl,\n  };\n}\n\nexport async function deliverInviteEmail({ toEmail, role, invitedBy, expiresAt, inviteToken }) {\n  const verifyUrl = buildInviteVerificationUrl(inviteToken);\n  const loginUrl = buildLoginUrl();\n  const content = buildEmailContent({\n    role,\n    invitedBy,\n    verifyUrl,\n    loginUrl,\n    expiresAt,\n  });\n  const provider = getEmailProvider();\n\n  if (provider === \"firebase\") {\n    return await sendViaFirebaseAuth({\n      toEmail,\n      verifyUrl,\n    });\n  }\n\n  if (provider === \"resend\") {\n    return await sendViaResend({\n      toEmail,\n      subject: content.subject,\n      html: content.html,\n      text: content.text,\n    });\n  }\n\n  if (provider === \"console\") {\n    if (!isConsoleEmailAllowed()) {\n      throw new Error(\"email_provider_not_configured\");\n    }\n\n    return sendViaConsole({\n      toEmail,\n      subject: content.subject,\n      verifyUrl,\n      loginUrl,\n    });\n  }\n\n  throw new Error(\"unsupported_email_provider\");\n}\n","import {\n  addDoc,\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  limit as queryLimit,\n  orderBy,\n  query,\n  updateDoc,\n} from \"firebase/firestore/lite\";\nimport { getFirestoreDb, isFirestoreEnabled } from \"@/lib/firebase\";\nimport { listUserAccounts } from \"@/lib/user-accounts\";\n\nconst DEFAULT_LIST_LIMIT = 20;\nconst MAX_LIST_LIMIT = 120;\nconst MAX_READ_ALL_LIMIT = 300;\n\nfunction nowIso() {\n  return new Date().toISOString();\n}\n\nfunction asString(value, fallback = \"\") {\n  const normalized = String(value || \"\").trim();\n  return normalized || fallback;\n}\n\nfunction asBoolean(value, fallback = false) {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value !== 0;\n  }\n  if (typeof value === \"string\") {\n    const normalized = value.trim().toLowerCase();\n    if (!normalized) {\n      return fallback;\n    }\n    if ([\"true\", \"1\", \"yes\", \"on\", \"y\"].includes(normalized)) {\n      return true;\n    }\n    if ([\"false\", \"0\", \"no\", \"off\", \"n\"].includes(normalized)) {\n      return false;\n    }\n  }\n  return fallback;\n}\n\nfunction asObject(value) {\n  if (value && typeof value === \"object\" && !Array.isArray(value)) {\n    return value;\n  }\n  return {};\n}\n\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [];\n}\n\nfunction clampInt(value, fallback, { min = 1, max = Number.MAX_SAFE_INTEGER } = {}) {\n  const parsed = Number.parseInt(String(value || \"\"), 10);\n  if (!Number.isFinite(parsed)) {\n    return fallback;\n  }\n  return Math.min(max, Math.max(min, parsed));\n}\n\nfunction normalizeEmail(value) {\n  return String(value || \"\").trim().toLowerCase();\n}\n\nfunction normalizeText(value) {\n  return String(value || \"\").trim().toLowerCase();\n}\n\nfunction parseEmailList(rawValue) {\n  return String(rawValue || \"\")\n    .split(\",\")\n    .map((item) => normalizeEmail(item))\n    .filter(Boolean);\n}\n\nfunction normalizeSeverity(value) {\n  const normalized = String(value || \"\").trim().toLowerCase();\n  if (normalized === \"critical\") return \"critical\";\n  if (normalized === \"high\") return \"high\";\n  if (normalized === \"low\") return \"low\";\n  return \"medium\";\n}\n\nfunction normalizeNotificationStatus(value) {\n  return String(value || \"\").trim().toLowerCase() === \"read\" ? \"read\" : \"unread\";\n}\n\nfunction getNotificationsCollectionName() {\n  return asString(process.env.CLIO_FIRESTORE_NOTIFICATIONS_COLLECTION, \"clio_notifications\");\n}\n\nfunction getFirestoreStore() {\n  if (!isFirestoreEnabled()) {\n    return null;\n  }\n  return getFirestoreDb();\n}\n\nfunction toNotificationRecord(snapshot) {\n  const payload = snapshot.data() || {};\n  return {\n    ...payload,\n    id: snapshot.id,\n    recordId: snapshot.id,\n  };\n}\n\nfunction isVisibleNotification(row, recipientEmail) {\n  const recipient = normalizeEmail(recipientEmail);\n  const owner = normalizeEmail(row?.recipientEmail);\n  const broadcast = asBoolean(row?.broadcast, false);\n  return broadcast || (recipient && owner && recipient === owner);\n}\n\nfunction sortByCreatedDesc(left, right) {\n  return new Date(right?.createdAt || 0).getTime() - new Date(left?.createdAt || 0).getTime();\n}\n\nfunction normalizeNotificationPayload(payload) {\n  const now = nowIso();\n  const recipientEmail = normalizeEmail(payload?.recipientEmail);\n  const broadcast = asBoolean(payload?.broadcast, false);\n  if (!recipientEmail && !broadcast) {\n    throw new Error(\"invalid_notification_recipient\");\n  }\n\n  return {\n    title: asString(payload?.title, \"Security notification\"),\n    message: asString(payload?.message, \"A security event requires review.\"),\n    severity: normalizeSeverity(payload?.severity),\n    type: asString(payload?.type, \"security\"),\n    module: asString(payload?.module, \"Incident Management\"),\n    actionUrl: asString(payload?.actionUrl, \"/incident-management\"),\n    recipientEmail,\n    broadcast,\n    status: normalizeNotificationStatus(payload?.status),\n    metadata: asObject(payload?.metadata),\n    createdAt: asString(payload?.createdAt, now),\n    updatedAt: asString(payload?.updatedAt, now),\n    readAt: asString(payload?.readAt, \"\"),\n    createdBy: normalizeEmail(payload?.createdBy),\n  };\n}\n\nexport async function createInAppNotification(payload) {\n  const db = getFirestoreStore();\n  if (!db) {\n    return null;\n  }\n\n  const normalized = normalizeNotificationPayload(payload);\n  const ref = await addDoc(collection(db, getNotificationsCollectionName()), normalized);\n  return {\n    ...normalized,\n    id: ref.id,\n    recordId: ref.id,\n  };\n}\n\nexport async function createInAppNotificationsBulk(payloads) {\n  const entries = asArray(payloads);\n  if (entries.length === 0) {\n    return [];\n  }\n\n  const created = [];\n  for (const payload of entries) {\n    const result = await createInAppNotification(payload);\n    if (result) {\n      created.push(result);\n    }\n  }\n  return created;\n}\n\nexport async function listInAppNotifications({\n  recipientEmail,\n  status = \"all\",\n  limit = DEFAULT_LIST_LIMIT,\n} = {}) {\n  const db = getFirestoreStore();\n  if (!db) {\n    return {\n      records: [],\n      unreadCount: 0,\n      totalScoped: 0,\n    };\n  }\n\n  const normalizedStatus = String(status || \"\").trim().toLowerCase();\n  const safeLimit = clampInt(limit, DEFAULT_LIST_LIMIT, { min: 1, max: MAX_LIST_LIMIT });\n  const scanLimit = Math.max(safeLimit * 4, 100);\n\n  const snapshot = await getDocs(\n    query(\n      collection(db, getNotificationsCollectionName()),\n      orderBy(\"createdAt\", \"desc\"),\n      queryLimit(scanLimit),\n    ),\n  );\n\n  const scoped = snapshot.docs.map(toNotificationRecord).filter((row) => isVisibleNotification(row, recipientEmail));\n  const unreadCount = scoped.reduce((count, row) => count + (normalizeNotificationStatus(row?.status) === \"unread\" ? 1 : 0), 0);\n\n  const statusFiltered = scoped.filter((row) => {\n    if (normalizedStatus === \"all\" || !normalizedStatus) {\n      return true;\n    }\n    return normalizeNotificationStatus(row?.status) === normalizedStatus;\n  });\n\n  return {\n    records: statusFiltered.sort(sortByCreatedDesc).slice(0, safeLimit),\n    unreadCount,\n    totalScoped: scoped.length,\n  };\n}\n\nexport async function markInAppNotificationRead(recordId, recipientEmail) {\n  const db = getFirestoreStore();\n  if (!db) {\n    return null;\n  }\n\n  const normalizedId = asString(recordId);\n  if (!normalizedId) {\n    throw new Error(\"invalid_record_id\");\n  }\n\n  const ref = doc(db, getNotificationsCollectionName(), normalizedId);\n  const snapshot = await getDoc(ref);\n  if (!snapshot.exists()) {\n    return null;\n  }\n\n  const current = toNotificationRecord(snapshot);\n  if (!isVisibleNotification(current, recipientEmail)) {\n    throw new Error(\"forbidden_notification_access\");\n  }\n\n  if (normalizeNotificationStatus(current.status) === \"read\") {\n    return current;\n  }\n\n  const patched = {\n    ...current,\n    status: \"read\",\n    readAt: nowIso(),\n    updatedAt: nowIso(),\n  };\n  await updateDoc(ref, patched);\n  return patched;\n}\n\nexport async function markAllInAppNotificationsRead({ recipientEmail, limit = 120 } = {}) {\n  const normalizedRecipient = normalizeEmail(recipientEmail);\n  if (!normalizedRecipient) {\n    return {\n      updatedCount: 0,\n    };\n  }\n\n  const db = getFirestoreStore();\n  if (!db) {\n    return {\n      updatedCount: 0,\n    };\n  }\n\n  const safeLimit = clampInt(limit, 120, { min: 1, max: MAX_READ_ALL_LIMIT });\n  const { records } = await listInAppNotifications({\n    recipientEmail: normalizedRecipient,\n    status: \"unread\",\n    limit: safeLimit,\n  });\n\n  let updatedCount = 0;\n  for (const row of records) {\n    const recordId = asString(row?.id || row?.recordId);\n    if (!recordId) {\n      continue;\n    }\n    const ref = doc(db, getNotificationsCollectionName(), recordId);\n    await updateDoc(ref, {\n      status: \"read\",\n      readAt: nowIso(),\n      updatedAt: nowIso(),\n    });\n    updatedCount += 1;\n  }\n\n  return {\n    updatedCount,\n  };\n}\n\nexport function resolveNotificationRecipients(values = []) {\n  return Array.from(\n    new Set(\n      asArray(values)\n        .map((value) => normalizeEmail(value))\n        .filter(Boolean),\n    ),\n  );\n}\n\nexport async function resolveIncidentStakeholderRecipients({\n  ownerEmail,\n  affectedEmployeeEmail,\n  actorEmail,\n  includeAffectedEmployee = true,\n  includeActor = false,\n} = {}) {\n  const baseRecipients = [\n    normalizeEmail(process.env.CLIO_GRC_ALERT_EMAIL),\n    ...parseEmailList(process.env.GRC_EMAILS),\n    ...parseEmailList(process.env.SUPER_ADMIN_EMAILS),\n    normalizeEmail(ownerEmail),\n  ];\n\n  if (includeAffectedEmployee) {\n    baseRecipients.push(normalizeEmail(affectedEmployeeEmail));\n  }\n  if (includeActor) {\n    baseRecipients.push(normalizeEmail(actorEmail));\n  }\n\n  let dynamicRoleRecipients = [];\n  try {\n    const users = await listUserAccounts();\n    dynamicRoleRecipients = asArray(users)\n      .filter((user) => normalizeEmail(user?.email))\n      .filter((user) => normalizeText(user?.status) === \"active\")\n      .filter((user) => {\n        const role = String(user?.role || \"\").trim().toUpperCase();\n        return role === \"GRC\" || role === \"SUPER_ADMIN\";\n      })\n      .map((user) => normalizeEmail(user?.email));\n  } catch {\n    dynamicRoleRecipients = [];\n  }\n\n  return resolveNotificationRecipients([...baseRecipients, ...dynamicRoleRecipients]);\n}\n","const RESEND_API_BASE = \"https://api.resend.com\";\nconst TWILIO_API_BASE = \"https://api.twilio.com/2010-04-01\";\n\nfunction asString(value, fallback = \"\") {\n  const normalized = String(value || \"\").trim();\n  return normalized || fallback;\n}\n\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [];\n}\n\nfunction parseBooleanEnv(name, fallbackValue = false) {\n  const raw = asString(process.env[name]).toLowerCase();\n  if (!raw) {\n    return fallbackValue;\n  }\n  return raw === \"true\" || raw === \"1\" || raw === \"yes\";\n}\n\nfunction normalizeEmail(value) {\n  return asString(value).toLowerCase();\n}\n\nfunction normalizePhone(value) {\n  return String(value || \"\").replace(/[^\\d+]/g, \"\").trim();\n}\n\nfunction parseCsvList(value) {\n  return asString(value)\n    .split(\",\")\n    .map((item) => item.trim())\n    .filter(Boolean);\n}\n\nfunction dedupe(values = []) {\n  return Array.from(new Set(values.filter(Boolean)));\n}\n\nfunction normalizeEmailProvider(value) {\n  const normalized = asString(value).toLowerCase();\n  if (!normalized) {\n    return \"\";\n  }\n  if (normalized.includes(\"resend\")) return \"resend\";\n  if (normalized.includes(\"firebase\")) return \"firebase\";\n  if (normalized.includes(\"console\") || normalized === \"dev\") return \"console\";\n  if (normalized === \"none\" || normalized === \"off\") return \"none\";\n  return normalized;\n}\n\nfunction normalizeSmsProvider(value) {\n  const normalized = asString(value).toLowerCase();\n  if (!normalized) {\n    return \"\";\n  }\n  if (normalized.includes(\"twilio\")) return \"twilio\";\n  if (normalized.includes(\"console\") || normalized === \"dev\") return \"console\";\n  if (normalized === \"none\" || normalized === \"off\") return \"none\";\n  return normalized;\n}\n\nfunction resolveAlertEmailProvider() {\n  const configured = normalizeEmailProvider(process.env.CLIO_ALERT_EMAIL_PROVIDER);\n  if (configured) {\n    return configured;\n  }\n  const hasResend = asString(process.env.RESEND_API_KEY).startsWith(\"re_\") && asString(process.env.CLIO_EMAIL_FROM);\n  return hasResend ? \"resend\" : \"console\";\n}\n\nfunction resolveAlertSmsProvider() {\n  const configured = normalizeSmsProvider(process.env.CLIO_ALERT_SMS_PROVIDER);\n  if (configured) {\n    return configured;\n  }\n  return \"none\";\n}\n\nfunction resolveSecurityAlertRecipients(explicitRecipients = []) {\n  const fromEnv = [\n    ...parseCsvList(process.env.CLIO_SECURITY_ALERT_RECIPIENTS),\n    ...parseCsvList(process.env.GRC_EMAILS),\n    ...parseCsvList(process.env.SUPER_ADMIN_EMAILS),\n  ];\n  return dedupe(\n    [...fromEnv, ...asArray(explicitRecipients)]\n      .map((value) => normalizeEmail(value))\n      .filter(Boolean),\n  );\n}\n\nfunction resolveSmsRecipients(explicitRecipients = []) {\n  const fromEnv = parseCsvList(process.env.CLIO_SMS_ALERT_RECIPIENTS);\n  return dedupe([...fromEnv, ...asArray(explicitRecipients)].map((value) => normalizePhone(value)).filter(Boolean));\n}\n\nfunction buildIncidentAlertSubject({ incident, detection }) {\n  const severity = asString(incident?.severity || detection?.severity || \"Medium\").toUpperCase();\n  const incidentCode = asString(incident?.incidentCode, \"INCIDENT\");\n  const title = asString(incident?.title, \"Security anomaly detected\");\n  return `[CLIO][${severity}] ${incidentCode} - ${title}`;\n}\n\nfunction buildIncidentAlertText({ incident, detection, sourceEvent }) {\n  const ruleId = asString(detection?.ruleId, \"N/A\");\n  const sourceIp = asString(sourceEvent?.metadata?.sourceIp || sourceEvent?.sourceIp, \"unknown\");\n  const actor = asString(sourceEvent?.performedBy, \"unknown\");\n  const requestPath = asString(sourceEvent?.metadata?.requestPath || sourceEvent?.requestPath, \"unknown\");\n  const observedCount = Number(detection?.observedCount || 0);\n  const detectedAt = asString(incident?.detectedAt || sourceEvent?.occurredAt, new Date().toISOString());\n  return [\n    \"CLIO security anomaly alert\",\n    `Incident: ${asString(incident?.incidentCode, \"-\")} | ${asString(incident?.title, \"-\")}`,\n    `Severity: ${asString(incident?.severity, \"-\")}`,\n    `Rule: ${ruleId}`,\n    `Detected At: ${detectedAt}`,\n    `Actor: ${actor}`,\n    `Source IP: ${sourceIp}`,\n    `Request Path: ${requestPath}`,\n    `Observed Count: ${observedCount > 0 ? observedCount : \"-\"}`,\n    `Summary: ${asString(incident?.summary || detection?.summary, \"-\")}`,\n    `Action URL: ${asString(incident?.actionUrl, \"/incident-management\")}`,\n  ].join(\"\\n\");\n}\n\nfunction buildIncidentAlertHtml(text) {\n  const escaped = String(text || \"\")\n    .replaceAll(\"&\", \"&amp;\")\n    .replaceAll(\"<\", \"&lt;\")\n    .replaceAll(\">\", \"&gt;\");\n  return `<pre style=\"font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; white-space:pre-wrap;\">${escaped}</pre>`;\n}\n\nasync function sendEmailViaResend({ recipients, subject, text, html }) {\n  const apiKey = asString(process.env.RESEND_API_KEY);\n  const fromAddress = asString(process.env.CLIO_EMAIL_FROM);\n  if (!apiKey || !fromAddress || !apiKey.startsWith(\"re_\")) {\n    throw new Error(\"email_provider_not_configured\");\n  }\n\n  const response = await fetch(`${RESEND_API_BASE}/emails`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${apiKey}`,\n    },\n    body: JSON.stringify({\n      from: fromAddress,\n      to: recipients,\n      subject,\n      text,\n      html,\n    }),\n  });\n\n  const payload = await response.json().catch(() => ({}));\n  if (!response.ok) {\n    const message =\n      asString(payload?.message) ||\n      asString(payload?.error?.message) ||\n      \"email_delivery_failed\";\n    throw new Error(`email_delivery_failed:${message}`);\n  }\n\n  return {\n    provider: \"resend\",\n    status: \"sent\",\n    messageId: asString(payload?.id, `resend-${Date.now()}`),\n    recipientCount: recipients.length,\n  };\n}\n\nfunction sendEmailViaConsole({ recipients, subject, text }) {\n  if (parseBooleanEnv(\"CLIO_ALLOW_CONSOLE_EMAIL\", true) || process.env.NODE_ENV !== \"production\") {\n    console.info(\"[CLIO:SecurityAlert:Email]\", {\n      recipients,\n      subject,\n      text,\n    });\n  }\n  return {\n    provider: \"console\",\n    status: \"simulated\",\n    recipientCount: recipients.length,\n  };\n}\n\nasync function dispatchEmailAlerts({ recipients, subject, text, html }) {\n  const safeRecipients = dedupe(asArray(recipients).map(normalizeEmail).filter(Boolean));\n  if (safeRecipients.length === 0) {\n    return {\n      provider: \"none\",\n      status: \"skipped\",\n      reason: \"no_recipients\",\n      recipientCount: 0,\n    };\n  }\n\n  const provider = resolveAlertEmailProvider();\n  if (provider === \"none\") {\n    return {\n      provider,\n      status: \"skipped\",\n      reason: \"provider_disabled\",\n      recipientCount: 0,\n    };\n  }\n  if (provider === \"firebase\") {\n    return {\n      provider,\n      status: \"skipped\",\n      reason: \"firebase_not_supported_for_custom_alert_email\",\n      recipientCount: 0,\n    };\n  }\n  if (provider === \"console\") {\n    return sendEmailViaConsole({\n      recipients: safeRecipients,\n      subject,\n      text,\n    });\n  }\n  if (provider === \"resend\") {\n    return await sendEmailViaResend({\n      recipients: safeRecipients,\n      subject,\n      text,\n      html,\n    });\n  }\n\n  return {\n    provider,\n    status: \"skipped\",\n    reason: \"unsupported_provider\",\n    recipientCount: 0,\n  };\n}\n\nasync function sendSmsViaTwilio({ recipients, body }) {\n  const accountSid = asString(process.env.TWILIO_ACCOUNT_SID);\n  const authToken = asString(process.env.TWILIO_AUTH_TOKEN);\n  const fromNumber = asString(process.env.TWILIO_FROM_NUMBER);\n  if (!accountSid || !authToken || !fromNumber) {\n    throw new Error(\"twilio_not_configured\");\n  }\n\n  const authHeader = Buffer.from(`${accountSid}:${authToken}`, \"utf8\").toString(\"base64\");\n  const requests = recipients.map(async (to) => {\n    const form = new URLSearchParams();\n    form.set(\"To\", to);\n    form.set(\"From\", fromNumber);\n    form.set(\"Body\", body);\n    const response = await fetch(`${TWILIO_API_BASE}/Accounts/${encodeURIComponent(accountSid)}/Messages.json`, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Basic ${authHeader}`,\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n      body: form.toString(),\n    });\n    const payload = await response.json().catch(() => ({}));\n    if (!response.ok) {\n      const message = asString(payload?.message, \"sms_delivery_failed\");\n      throw new Error(`twilio_delivery_failed:${message}`);\n    }\n    return {\n      to,\n      sid: asString(payload?.sid),\n    };\n  });\n\n  const settled = await Promise.allSettled(requests);\n  const delivered = settled\n    .filter((item) => item.status === \"fulfilled\")\n    .map((item) => item.value);\n  const failed = settled\n    .filter((item) => item.status === \"rejected\")\n    .map((item) => asString(item.reason?.message || \"sms_delivery_failed\"));\n\n  return {\n    provider: \"twilio\",\n    status: failed.length > 0 ? (delivered.length > 0 ? \"partial\" : \"failed\") : \"sent\",\n    deliveredCount: delivered.length,\n    recipientCount: recipients.length,\n    delivered,\n    failed,\n  };\n}\n\nfunction sendSmsViaConsole({ recipients, body }) {\n  if (process.env.NODE_ENV !== \"production\") {\n    console.info(\"[CLIO:SecurityAlert:SMS]\", {\n      recipients,\n      body,\n    });\n  }\n  return {\n    provider: \"console\",\n    status: \"simulated\",\n    deliveredCount: recipients.length,\n    recipientCount: recipients.length,\n    delivered: recipients.map((to) => ({ to, sid: `console-${Date.now()}` })),\n    failed: [],\n  };\n}\n\nasync function dispatchSmsAlerts({ recipients, body }) {\n  const safeRecipients = dedupe(asArray(recipients).map(normalizePhone).filter(Boolean));\n  if (safeRecipients.length === 0) {\n    return {\n      provider: \"none\",\n      status: \"skipped\",\n      reason: \"no_recipients\",\n      deliveredCount: 0,\n      recipientCount: 0,\n      failed: [],\n    };\n  }\n\n  const provider = resolveAlertSmsProvider();\n  if (provider === \"none\") {\n    return {\n      provider,\n      status: \"skipped\",\n      reason: \"provider_disabled\",\n      deliveredCount: 0,\n      recipientCount: safeRecipients.length,\n      failed: [],\n    };\n  }\n  if (provider === \"console\") {\n    return sendSmsViaConsole({\n      recipients: safeRecipients,\n      body,\n    });\n  }\n  if (provider === \"twilio\") {\n    return await sendSmsViaTwilio({\n      recipients: safeRecipients,\n      body,\n    });\n  }\n\n  return {\n    provider,\n    status: \"skipped\",\n    reason: \"unsupported_provider\",\n    deliveredCount: 0,\n    recipientCount: safeRecipients.length,\n    failed: [],\n  };\n}\n\nfunction getConfiguredWebhookTargets() {\n  const generic = parseCsvList(process.env.CLIO_SECURITY_WEBHOOK_URLS).map((url) => ({\n    label: \"security-webhook\",\n    url,\n    token: asString(process.env.CLIO_SECURITY_WEBHOOK_TOKEN),\n  }));\n  const siemUrl = asString(process.env.CLIO_SIEM_WEBHOOK_URL);\n  const edrUrl = asString(process.env.CLIO_EDR_WEBHOOK_URL);\n  const targets = [...generic];\n  if (siemUrl) {\n    targets.push({\n      label: \"siem\",\n      url: siemUrl,\n      token: asString(process.env.CLIO_SIEM_WEBHOOK_TOKEN),\n    });\n  }\n  if (edrUrl) {\n    targets.push({\n      label: \"edr\",\n      url: edrUrl,\n      token: asString(process.env.CLIO_EDR_WEBHOOK_TOKEN),\n    });\n  }\n  return targets.filter((target) => asString(target.url));\n}\n\nasync function postWebhook({ url, label, token, payload, timeoutMs }) {\n  const controller = new AbortController();\n  const timer = setTimeout(() => controller.abort(), timeoutMs);\n  try {\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      \"X-CLIO-Source\": \"security-detection\",\n      \"X-CLIO-Target\": label,\n    };\n    if (token) {\n      headers.Authorization = `Bearer ${token}`;\n    }\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(payload),\n      signal: controller.signal,\n    });\n    const body = await response.text().catch(() => \"\");\n    return {\n      label,\n      url,\n      ok: response.ok,\n      status: response.status,\n      body: asString(body),\n    };\n  } catch (error) {\n    return {\n      label,\n      url,\n      ok: false,\n      status: 0,\n      body: asString(error?.message, \"webhook_delivery_failed\"),\n    };\n  } finally {\n    clearTimeout(timer);\n  }\n}\n\nasync function dispatchWebhooks(payload) {\n  const targets = getConfiguredWebhookTargets();\n  if (targets.length === 0) {\n    return {\n      status: \"skipped\",\n      targets: [],\n      successCount: 0,\n    };\n  }\n\n  const timeoutMs = Number.parseInt(asString(process.env.CLIO_SECURITY_WEBHOOK_TIMEOUT_MS, \"5000\"), 10) || 5000;\n  const results = await Promise.all(\n    targets.map((target) =>\n      postWebhook({\n        ...target,\n        payload,\n        timeoutMs: Math.max(1000, Math.min(20000, timeoutMs)),\n      }),\n    ),\n  );\n  const successCount = results.filter((item) => item.ok).length;\n  return {\n    status: successCount === results.length ? \"sent\" : successCount > 0 ? \"partial\" : \"failed\",\n    targets: results,\n    successCount,\n  };\n}\n\nexport async function dispatchSecurityIncidentAlerts({\n  incident,\n  detection,\n  sourceEvent,\n  emailRecipients = [],\n  smsRecipients = [],\n} = {}) {\n  const recipients = resolveSecurityAlertRecipients(emailRecipients);\n  const smsTargets = resolveSmsRecipients(smsRecipients);\n  const subject = buildIncidentAlertSubject({ incident, detection });\n  const text = buildIncidentAlertText({ incident, detection, sourceEvent });\n  const html = buildIncidentAlertHtml(text);\n\n  const [emailResult, smsResult, webhookResult] = await Promise.all([\n    dispatchEmailAlerts({\n      recipients,\n      subject,\n      text,\n      html,\n    }).catch((error) => ({\n      provider: resolveAlertEmailProvider(),\n      status: \"failed\",\n      reason: asString(error?.message, \"email_delivery_failed\"),\n      recipientCount: recipients.length,\n    })),\n    dispatchSmsAlerts({\n      recipients: smsTargets,\n      body: `${subject}\\n${text}`.slice(0, 1200),\n    }).catch((error) => ({\n      provider: resolveAlertSmsProvider(),\n      status: \"failed\",\n      reason: asString(error?.message, \"sms_delivery_failed\"),\n      deliveredCount: 0,\n      recipientCount: smsTargets.length,\n      failed: [asString(error?.message, \"sms_delivery_failed\")],\n    })),\n    dispatchWebhooks({\n      eventType: \"clio.security.incident\",\n      generatedAt: new Date().toISOString(),\n      incident,\n      detection,\n      sourceEvent: {\n        id: asString(sourceEvent?.id),\n        module: asString(sourceEvent?.module),\n        activityName: asString(sourceEvent?.activityName),\n        status: asString(sourceEvent?.status),\n        occurredAt: asString(sourceEvent?.occurredAt),\n        sourceIp: asString(sourceEvent?.metadata?.sourceIp || sourceEvent?.sourceIp),\n        requestPath: asString(sourceEvent?.metadata?.requestPath || sourceEvent?.requestPath),\n      },\n    }),\n  ]);\n\n  return {\n    subject,\n    email: emailResult,\n    sms: smsResult,\n    webhooks: webhookResult,\n    recipients,\n    smsRecipients: smsTargets,\n  };\n}\n\nexport function resolveSecurityAlertEmailRecipients(explicitRecipients = []) {\n  return resolveSecurityAlertRecipients(explicitRecipients);\n}\n","import {\n  createIncidentRecordBackend,\n  listIncidentRecordsBackend,\n  updateIncidentRecordBackend,\n} from \"@/lib/hris-backend\";\nimport {\n  addDoc,\n  collection,\n  deleteDoc,\n  doc,\n  getDocs,\n  limit as queryLimit,\n  orderBy,\n  query,\n  updateDoc,\n} from \"firebase/firestore/lite\";\nimport { getFirestoreDb, isFirestoreEnabled } from \"@/lib/firebase\";\nimport {\n  createInAppNotificationsBulk,\n  resolveIncidentStakeholderRecipients,\n} from \"@/lib/security-notifications\";\nimport {\n  dispatchSecurityIncidentAlerts,\n  resolveSecurityAlertEmailRecipients,\n} from \"@/lib/security-alert-delivery\";\n\nconst EVENT_COUNTER_WINDOWS = new Map();\nconst INCIDENT_COOLDOWN_CACHE = new Map();\nconst MAX_COUNTER_BUCKET_SIZE = 256;\nconst DEFAULT_SYSTEM_ACTOR = \"system@gmail.com\";\nlet IDS_RETRY_DRAIN_PROMISE = null;\n\nconst PERMISSION_DENIED_REASONS = new Set([\n  \"missing_permission\",\n  \"role_not_allowed\",\n  \"ownership_validation_failed\",\n  \"unauthorized\",\n  \"account_not_active\",\n  \"session_role_mismatch\",\n  \"session_version_mismatch\",\n]);\n\nfunction nowIso() {\n  return new Date().toISOString();\n}\n\nfunction asString(value, fallback = \"\") {\n  const normalized = String(value || \"\").trim();\n  return normalized || fallback;\n}\n\nfunction asObject(value) {\n  if (value && typeof value === \"object\" && !Array.isArray(value)) {\n    return value;\n  }\n  return {};\n}\n\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [];\n}\n\nfunction normalizeText(value) {\n  return asString(value).toLowerCase();\n}\n\nfunction normalizeEmail(value) {\n  return asString(value).toLowerCase();\n}\n\nfunction normalizeIp(value) {\n  const ip = asString(value).toLowerCase();\n  return ip || \"unknown\";\n}\n\nfunction toTimeMs(value) {\n  const timestamp = new Date(value || \"\").getTime();\n  return Number.isNaN(timestamp) ? null : timestamp;\n}\n\nfunction parseBooleanEnv(name, fallbackValue = false) {\n  const raw = normalizeText(process.env[name]);\n  if (!raw) {\n    return fallbackValue;\n  }\n  return raw === \"true\" || raw === \"1\" || raw === \"yes\";\n}\n\nfunction parseIntegerEnv(name, fallbackValue, { min = 1, max = Number.MAX_SAFE_INTEGER } = {}) {\n  const parsed = Number.parseInt(asString(process.env[name]), 10);\n  if (!Number.isFinite(parsed)) {\n    return fallbackValue;\n  }\n  return Math.min(max, Math.max(min, parsed));\n}\n\nfunction getDetectionRetryQueueCollectionName() {\n  return asString(process.env.CLIO_FIRESTORE_IDS_RETRY_COLLECTION, \"clio_ids_retry_queue\");\n}\n\nfunction getDetectionDeadLetterCollectionName() {\n  return asString(process.env.CLIO_FIRESTORE_IDS_DEAD_LETTER_COLLECTION, \"clio_ids_dead_letter\");\n}\n\nfunction getDetectionQueueDb() {\n  if (!isFirestoreEnabled()) {\n    return null;\n  }\n  return getFirestoreDb();\n}\n\nfunction getDetectionConfig() {\n  return {\n    enabled: parseBooleanEnv(\"CLIO_IDS_ENABLED\", true),\n    authFailureThreshold: parseIntegerEnv(\"CLIO_IDS_AUTH_FAILURE_THRESHOLD\", 5, { min: 2, max: 30 }),\n    authFailureWindowMinutes: parseIntegerEnv(\"CLIO_IDS_AUTH_FAILURE_WINDOW_MINUTES\", 10, { min: 1, max: 120 }),\n    permissionDeniedThreshold: parseIntegerEnv(\"CLIO_IDS_PERMISSION_DENIED_THRESHOLD\", 3, { min: 2, max: 20 }),\n    permissionDeniedWindowMinutes: parseIntegerEnv(\"CLIO_IDS_PERMISSION_DENIED_WINDOW_MINUTES\", 15, { min: 1, max: 120 }),\n    exportSpikeThreshold: parseIntegerEnv(\"CLIO_IDS_EXPORT_SPIKE_THRESHOLD\", 4, { min: 2, max: 20 }),\n    exportSpikeWindowMinutes: parseIntegerEnv(\"CLIO_IDS_EXPORT_SPIKE_WINDOW_MINUTES\", 20, { min: 1, max: 180 }),\n    piiAccessSpikeThreshold: parseIntegerEnv(\"CLIO_IDS_PII_ACCESS_SPIKE_THRESHOLD\", 12, { min: 4, max: 80 }),\n    piiAccessSpikeWindowMinutes: parseIntegerEnv(\"CLIO_IDS_PII_ACCESS_SPIKE_WINDOW_MINUTES\", 15, { min: 1, max: 180 }),\n    incidentCooldownMinutes: parseIntegerEnv(\"CLIO_IDS_INCIDENT_COOLDOWN_MINUTES\", 15, { min: 1, max: 360 }),\n    maxRecipientCount: parseIntegerEnv(\"CLIO_IDS_MAX_RECIPIENTS\", 20, { min: 1, max: 100 }),\n    systemActorEmail: normalizeEmail(process.env.CLIO_IDS_SYSTEM_ACTOR_EMAIL) || DEFAULT_SYSTEM_ACTOR,\n    appBaseUrl: asString(process.env.CLIO_APP_BASE_URL, \"http://localhost:3000\").replace(/\\/+$/, \"\"),\n    retryEnabled: parseBooleanEnv(\"CLIO_IDS_RETRY_ENABLED\", true),\n    retryBatchSize: parseIntegerEnv(\"CLIO_IDS_RETRY_BATCH_SIZE\", 8, { min: 1, max: 32 }),\n    retryMaxAttempts: parseIntegerEnv(\"CLIO_IDS_RETRY_MAX_ATTEMPTS\", 5, { min: 1, max: 20 }),\n    retryBaseBackoffSeconds: parseIntegerEnv(\"CLIO_IDS_RETRY_BASE_BACKOFF_SECONDS\", 30, {\n      min: 5,\n      max: 3600,\n    }),\n    retryMaxBackoffSeconds: parseIntegerEnv(\"CLIO_IDS_RETRY_MAX_BACKOFF_SECONDS\", 1800, {\n      min: 30,\n      max: 24 * 3600,\n    }),\n    retryCollectionName: getDetectionRetryQueueCollectionName(),\n    deadLetterCollectionName: getDetectionDeadLetterCollectionName(),\n  };\n}\n\nfunction pruneCounterWindow(values, currentTimeMs, windowMs) {\n  const cutoff = currentTimeMs - windowMs;\n  return values.filter((value) => value >= cutoff).slice(-MAX_COUNTER_BUCKET_SIZE);\n}\n\nfunction incrementCounterWindow(key, timestampMs, windowMs) {\n  const normalizedKey = asString(key);\n  if (!normalizedKey) {\n    return 0;\n  }\n  const safeTimestamp = Number.isFinite(timestampMs) ? timestampMs : Date.now();\n  const existing = EVENT_COUNTER_WINDOWS.get(normalizedKey) || [];\n  const pruned = pruneCounterWindow(existing, safeTimestamp, windowMs);\n  pruned.push(safeTimestamp);\n  EVENT_COUNTER_WINDOWS.set(normalizedKey, pruned);\n  return pruned.length;\n}\n\nfunction cleanupIncidentCooldown(nowMs) {\n  const current = Number.isFinite(nowMs) ? nowMs : Date.now();\n  for (const [key, value] of INCIDENT_COOLDOWN_CACHE.entries()) {\n    if (!Number.isFinite(value) || value <= current) {\n      INCIDENT_COOLDOWN_CACHE.delete(key);\n    }\n  }\n}\n\nfunction isInIncidentCooldown(fingerprint, nowMs) {\n  cleanupIncidentCooldown(nowMs);\n  const expiresAt = INCIDENT_COOLDOWN_CACHE.get(fingerprint);\n  return Number.isFinite(expiresAt) && expiresAt > nowMs;\n}\n\nfunction rememberIncidentCooldown(fingerprint, nowMs, minutes) {\n  const ttlMs = Math.max(1, Number(minutes || 1)) * 60 * 1000;\n  INCIDENT_COOLDOWN_CACHE.set(fingerprint, nowMs + ttlMs);\n}\n\nfunction shouldSkipEvent(entry) {\n  const metadata = asObject(entry?.metadata);\n  if (metadata.skipAnomalyDetection === true || metadata.autoGenerated === true) {\n    return true;\n  }\n\n  const moduleName = normalizeText(entry?.module);\n  const requestPath = normalizeText(metadata.requestPath || entry?.requestPath);\n  if (moduleName.includes(\"incident management\")) {\n    return true;\n  }\n  if (requestPath.startsWith(\"/api/notifications\")) {\n    return true;\n  }\n  return false;\n}\n\nfunction buildFingerprint(ruleId, entry, detection, nowMs, windowMinutes) {\n  const actor = normalizeEmail(entry?.performedBy);\n  const sourceIp = normalizeIp(entry?.metadata?.sourceIp || entry?.sourceIp);\n  const moduleName = normalizeText(entry?.module || \"\");\n  const target = normalizeEmail(detection?.affectedEmployeeEmail || entry?.metadata?.employeeEmail || \"\");\n  const bucket = Math.floor(nowMs / (Math.max(1, Number(windowMinutes || 1)) * 60 * 1000));\n  return [asString(ruleId), actor || \"unknown\", sourceIp, moduleName || \"module\", target || \"none\", bucket].join(\"|\");\n}\n\nfunction chooseSeverity(baseSeverity, observedCount, threshold) {\n  const severity = normalizeText(baseSeverity);\n  if (severity === \"critical\") {\n    return \"Critical\";\n  }\n  const safeThreshold = Math.max(1, Number(threshold || 1));\n  if (observedCount >= safeThreshold * 2) {\n    return \"Critical\";\n  }\n  if (severity === \"high\") {\n    return \"High\";\n  }\n  if (severity === \"medium\") {\n    return \"Medium\";\n  }\n  return \"Low\";\n}\n\nfunction extractEventContext(entry) {\n  const metadata = asObject(entry?.metadata);\n  return {\n    actorEmail: normalizeEmail(entry?.performedBy),\n    status: normalizeText(entry?.status),\n    moduleName: normalizeText(entry?.module),\n    activityName: normalizeText(entry?.activityName),\n    reason: normalizeText(metadata.reason),\n    requestPath: normalizeText(metadata.requestPath || entry?.requestPath),\n    requestMethod: normalizeText(metadata.requestMethod || entry?.requestMethod),\n    sourceIp: normalizeIp(metadata.sourceIp || entry?.sourceIp),\n    sensitivity: normalizeText(entry?.sensitivity),\n    targetEmployeeEmail: normalizeEmail(metadata.targetEmployeeEmail || metadata.employeeEmail || metadata.affectedEmployeeEmail),\n    ownerEmail: normalizeEmail(metadata.ownerEmail),\n    occurredAtMs: toTimeMs(entry?.occurredAt) || Date.now(),\n  };\n}\n\nfunction isDeniedStatus(status) {\n  return status === \"failed\" || status === \"rejected\";\n}\n\nfunction detectAuthFailureSpike(entry, context, config) {\n  if (!context.moduleName.includes(\"authentication\") || !isDeniedStatus(context.status)) {\n    return null;\n  }\n\n  const key = `auth-fail:${context.sourceIp || context.actorEmail || \"unknown\"}`;\n  const count = incrementCounterWindow(\n    key,\n    context.occurredAtMs,\n    config.authFailureWindowMinutes * 60 * 1000,\n  );\n  if (count < config.authFailureThreshold) {\n    return null;\n  }\n\n  const severity = chooseSeverity(\"high\", count, config.authFailureThreshold);\n  return {\n    ruleId: \"AUTH_BRUTE_FORCE\",\n    incidentType: \"Credential Compromise\",\n    severity,\n    restrictedPiiInvolved: false,\n    observedCount: count,\n    windowMinutes: config.authFailureWindowMinutes,\n    affectedEmployeeEmail: context.actorEmail,\n    title: \"Repeated authentication failures detected\",\n    summary: `Detected ${count} failed/rejected authentication events from ${context.sourceIp} within ${config.authFailureWindowMinutes} minute(s).`,\n    tags: [\"authentication\", \"brute-force\", \"ids\"],\n  };\n}\n\nfunction detectPermissionDeniedSpike(entry, context, config) {\n  const isPermissionDenied =\n    isDeniedStatus(context.status) &&\n    (PERMISSION_DENIED_REASONS.has(context.reason) ||\n      context.activityName.includes(\"permission\") ||\n      context.activityName.includes(\"ownership\") ||\n      context.activityName.includes(\"forbidden\"));\n  if (!isPermissionDenied) {\n    return null;\n  }\n\n  const key = `permission-denied:${context.actorEmail || context.sourceIp || \"unknown\"}`;\n  const count = incrementCounterWindow(\n    key,\n    context.occurredAtMs,\n    config.permissionDeniedWindowMinutes * 60 * 1000,\n  );\n  if (count < config.permissionDeniedThreshold) {\n    return null;\n  }\n\n  const piiModule =\n    context.moduleName.includes(\"employee records\") ||\n    context.moduleName.includes(\"performance\") ||\n    context.moduleName.includes(\"attendance\");\n  const severity = chooseSeverity(piiModule ? \"high\" : \"medium\", count, config.permissionDeniedThreshold);\n  return {\n    ruleId: \"UNAUTHORIZED_ACCESS_ATTEMPT\",\n    incidentType: \"Unauthorized Access\",\n    severity,\n    restrictedPiiInvolved: piiModule,\n    observedCount: count,\n    windowMinutes: config.permissionDeniedWindowMinutes,\n    affectedEmployeeEmail: context.targetEmployeeEmail || context.actorEmail,\n    title: \"Repeated unauthorized access attempts detected\",\n    summary: `Detected ${count} permission/ownership denials for actor ${context.actorEmail || \"unknown\"} within ${config.permissionDeniedWindowMinutes} minute(s).`,\n    tags: [\"authorization\", \"idor\", \"least-privilege\", \"ids\"],\n  };\n}\n\nfunction detectExportSpike(entry, context, config) {\n  const isExportActivity =\n    context.moduleName.includes(\"export\") ||\n    context.requestPath.includes(\"/api/hris/exports\") ||\n    context.activityName.includes(\"export\");\n  if (!isExportActivity) {\n    return null;\n  }\n\n  if (!(context.status === \"approved\" || context.status === \"completed\")) {\n    return null;\n  }\n\n  const key = `export-spike:${context.actorEmail || context.sourceIp || \"unknown\"}`;\n  const count = incrementCounterWindow(\n    key,\n    context.occurredAtMs,\n    config.exportSpikeWindowMinutes * 60 * 1000,\n  );\n  if (count < config.exportSpikeThreshold) {\n    return null;\n  }\n\n  const severity = chooseSeverity(\"high\", count, config.exportSpikeThreshold);\n  return {\n    ruleId: \"MASS_EXPORT_ACTIVITY\",\n    incidentType: \"Data Exposure\",\n    severity,\n    restrictedPiiInvolved: true,\n    observedCount: count,\n    windowMinutes: config.exportSpikeWindowMinutes,\n    affectedEmployeeEmail: context.targetEmployeeEmail || \"\",\n    title: \"Mass export activity detected\",\n    summary: `Detected ${count} export-related actions by ${context.actorEmail || context.sourceIp} within ${config.exportSpikeWindowMinutes} minute(s).`,\n    tags: [\"export\", \"dlp\", \"ids\"],\n  };\n}\n\nfunction detectPiiAccessSpike(entry, context, config) {\n  const isPiiRead =\n    context.sensitivity === \"sensitive\" &&\n    context.moduleName.includes(\"employee records\") &&\n    (context.activityName.includes(\"view\") || context.activityName.includes(\"list\")) &&\n    (context.status === \"completed\" || context.status === \"approved\");\n  if (!isPiiRead) {\n    return null;\n  }\n\n  const key = `pii-read:${context.actorEmail || context.sourceIp || \"unknown\"}`;\n  const count = incrementCounterWindow(\n    key,\n    context.occurredAtMs,\n    config.piiAccessSpikeWindowMinutes * 60 * 1000,\n  );\n  if (count < config.piiAccessSpikeThreshold) {\n    return null;\n  }\n\n  const severity = chooseSeverity(\"medium\", count, config.piiAccessSpikeThreshold);\n  return {\n    ruleId: \"PII_ACCESS_VOLUME_SPIKE\",\n    incidentType: \"Policy Violation\",\n    severity,\n    restrictedPiiInvolved: true,\n    observedCount: count,\n    windowMinutes: config.piiAccessSpikeWindowMinutes,\n    affectedEmployeeEmail: context.targetEmployeeEmail || \"\",\n    title: \"Sensitive PII access spike detected\",\n    summary: `Detected ${count} sensitive employee-record read actions in ${config.piiAccessSpikeWindowMinutes} minute(s).`,\n    tags: [\"pii\", \"privacy\", \"monitoring\", \"ids\"],\n  };\n}\n\nfunction detectSuspiciousEvent(entry, context, config) {\n  const rules = [\n    detectAuthFailureSpike,\n    detectPermissionDeniedSpike,\n    detectExportSpike,\n    detectPiiAccessSpike,\n  ];\n\n  for (const detect of rules) {\n    const match = detect(entry, context, config);\n    if (match) {\n      return match;\n    }\n  }\n  return null;\n}\n\nfunction toNotificationTitle(incident, detection) {\n  return asString(incident?.title || detection?.title, \"Security anomaly detected\");\n}\n\nfunction toNotificationMessage(incident, detection) {\n  const severity = asString(incident?.severity || detection?.severity, \"Medium\");\n  const code = asString(incident?.incidentCode, \"INCIDENT\");\n  const summary = asString(incident?.summary || detection?.summary, \"Review incident workbench for containment.\");\n  return `[${severity}] ${code}: ${summary}`;\n}\n\nfunction parseRoleEmails(value) {\n  return asString(value)\n    .split(\",\")\n    .map((item) => normalizeEmail(item))\n    .filter(Boolean);\n}\n\nfunction resolveOwnerEmail(entry, detection) {\n  const preferredOwner =\n    normalizeEmail(process.env.CLIO_GRC_ALERT_EMAIL) ||\n    parseRoleEmails(process.env.GRC_EMAILS)[0] ||\n    parseRoleEmails(process.env.SUPER_ADMIN_EMAILS)[0];\n  if (preferredOwner) {\n    return preferredOwner;\n  }\n  return normalizeEmail(detection?.affectedEmployeeEmail || entry?.metadata?.ownerEmail || entry?.performedBy || DEFAULT_SYSTEM_ACTOR);\n}\n\nasync function resolveAlertRecipients(entry, detection, incident, config) {\n  const owner = resolveOwnerEmail(entry, detection) || normalizeEmail(incident?.ownerEmail);\n  const resolved = await resolveIncidentStakeholderRecipients({\n    ownerEmail: owner,\n    affectedEmployeeEmail: normalizeEmail(detection?.affectedEmployeeEmail),\n    actorEmail: normalizeEmail(entry?.performedBy),\n    includeAffectedEmployee: true,\n    includeActor: true,\n  });\n  const withExplicitSecurityRecipients = resolveSecurityAlertEmailRecipients(resolved);\n  return withExplicitSecurityRecipients.slice(0, config.maxRecipientCount);\n}\n\nfunction buildActionUrl(config, incidentId) {\n  if (!incidentId) {\n    return \"/incident-management\";\n  }\n  return `/incident-management?incident=${encodeURIComponent(incidentId)}`;\n}\n\nfunction buildAbsoluteActionUrl(config, actionPath) {\n  const base = asString(config?.appBaseUrl, \"http://localhost:3000\").replace(/\\/+$/, \"\");\n  const path = asString(actionPath, \"/incident-management\");\n  if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n    return path;\n  }\n  return `${base}${path.startsWith(\"/\") ? path : `/${path}`}`;\n}\n\nfunction getRetryDelaySeconds(attempt, config) {\n  const safeAttempt = Math.max(1, Number(attempt || 1));\n  const baseSeconds = Math.max(5, Number(config?.retryBaseBackoffSeconds || 30));\n  const maxSeconds = Math.max(baseSeconds, Number(config?.retryMaxBackoffSeconds || 1800));\n  return Math.min(maxSeconds, baseSeconds * Math.pow(2, Math.max(0, safeAttempt - 1)));\n}\n\nfunction buildRetryQueueEntry({\n  entry,\n  detection,\n  fingerprint,\n  errorMessage,\n  config,\n  attempts = 1,\n  source = \"live\",\n  queuedAtIso = nowIso(),\n}) {\n  const safeAttempts = Math.max(1, Number(attempts || 1));\n  const delaySeconds = getRetryDelaySeconds(safeAttempts, config);\n  const nextAttemptAt = new Date(Date.now() + delaySeconds * 1000).toISOString();\n  return {\n    status: \"pending\",\n    source: asString(source, \"live\"),\n    attempts: safeAttempts,\n    maxAttempts: Math.max(1, Number(config?.retryMaxAttempts || 5)),\n    nextAttemptAt,\n    lastError: asString(errorMessage, \"ids_processing_failed\"),\n    fingerprint: asString(fingerprint),\n    entry: asObject(entry),\n    detection: asObject(detection),\n    createdAt: queuedAtIso,\n    updatedAt: queuedAtIso,\n  };\n}\n\nasync function enqueueDetectionRetryWorkItem({\n  entry,\n  detection,\n  fingerprint,\n  errorMessage,\n  config,\n  attempts = 1,\n  source = \"live\",\n}) {\n  if (!config?.retryEnabled) {\n    return {\n      queued: false,\n      reason: \"retry_disabled\",\n    };\n  }\n\n  const db = getDetectionQueueDb();\n  if (!db) {\n    return {\n      queued: false,\n      reason: \"retry_queue_unavailable\",\n    };\n  }\n\n  const now = nowIso();\n  const payload = buildRetryQueueEntry({\n    entry,\n    detection,\n    fingerprint,\n    errorMessage,\n    config,\n    attempts,\n    source,\n    queuedAtIso: now,\n  });\n  const ref = await addDoc(collection(db, config.retryCollectionName), payload);\n  return {\n    queued: true,\n    retryRecordId: ref.id,\n    attempts: payload.attempts,\n    nextAttemptAt: payload.nextAttemptAt,\n  };\n}\n\nasync function listDueRetryQueueRecords(config, { batchSize } = {}) {\n  const db = getDetectionQueueDb();\n  if (!db) {\n    return [];\n  }\n\n  const limitValue = Math.max(1, Number(batchSize || config?.retryBatchSize || 8));\n  const scanLimit = Math.max(limitValue * 3, 16);\n  const snapshot = await getDocs(\n    query(\n      collection(db, config.retryCollectionName),\n      orderBy(\"nextAttemptAt\", \"asc\"),\n      queryLimit(scanLimit),\n    ),\n  );\n  const nowMs = Date.now();\n  return snapshot.docs\n    .map((docSnapshot) => ({\n      id: docSnapshot.id,\n      ...(docSnapshot.data() || {}),\n    }))\n    .filter((row) => normalizeText(row?.status || \"pending\") === \"pending\")\n    .filter((row) => {\n      const nextAttemptMs = toTimeMs(row?.nextAttemptAt);\n      return !Number.isFinite(nextAttemptMs) || nextAttemptMs <= nowMs;\n    })\n    .slice(0, limitValue);\n}\n\nasync function moveRetryRecordToDeadLetter(config, record, reason) {\n  const db = getDetectionQueueDb();\n  if (!db) {\n    return null;\n  }\n\n  const payload = {\n    ...record,\n    status: \"dead-letter\",\n    deadLetteredAt: nowIso(),\n    deadLetterReason: asString(reason, \"ids_retry_exhausted\"),\n    originalRetryRecordId: asString(record?.id),\n  };\n  const ref = await addDoc(collection(db, config.deadLetterCollectionName), payload);\n  return ref.id;\n}\n\nasync function updateRetryQueueRecord(config, recordId, patch) {\n  const db = getDetectionQueueDb();\n  if (!db) {\n    return;\n  }\n  await updateDoc(doc(db, config.retryCollectionName, recordId), {\n    ...patch,\n    updatedAt: nowIso(),\n  });\n}\n\nasync function deleteRetryQueueRecord(config, recordId) {\n  const db = getDetectionQueueDb();\n  if (!db) {\n    return;\n  }\n  await deleteDoc(doc(db, config.retryCollectionName, recordId));\n}\n\nasync function hasDuplicateIncident(fingerprint, nowMs, config) {\n  if (isInIncidentCooldown(fingerprint, nowMs)) {\n    return true;\n  }\n\n  let rows = [];\n  try {\n    rows = await listIncidentRecordsBackend();\n  } catch {\n    rows = [];\n  }\n\n  const cooldownMs = config.incidentCooldownMinutes * 60 * 1000;\n  const duplicate = asArray(rows).some((row) => {\n    const currentFingerprint = asString(row?.detectionFingerprint);\n    if (!currentFingerprint || currentFingerprint !== fingerprint) {\n      return false;\n    }\n    const status = normalizeText(row?.status);\n    if (status === \"resolved\" || status === \"closed\") {\n      return false;\n    }\n    const detectedAtMs = toTimeMs(row?.detectedAt || row?.createdAt);\n    if (!Number.isFinite(detectedAtMs)) {\n      return true;\n    }\n    return detectedAtMs >= nowMs - cooldownMs;\n  });\n\n  return duplicate;\n}\n\nasync function createAutoIncident(entry, detection, config, fingerprint, nowMs) {\n  const occurredAt = asString(entry?.occurredAt, nowIso());\n  const ownerEmail = resolveOwnerEmail(entry, detection);\n  const actorEmail = config.systemActorEmail || DEFAULT_SYSTEM_ACTOR;\n  const sourceMetadata = asObject(entry?.metadata);\n  const payload = {\n    title: detection.title,\n    summary: detection.summary,\n    incidentType: detection.incidentType,\n    severity: detection.severity,\n    status: \"Open\",\n    restrictedPiiInvolved: Boolean(detection.restrictedPiiInvolved),\n    affectedEmployeeEmail: normalizeEmail(detection.affectedEmployeeEmail || sourceMetadata.targetEmployeeEmail || \"\"),\n    ownerEmail,\n    detectedAt: occurredAt,\n    escalationRequired: true,\n    containmentStatus: \"Not Started\",\n    impactAssessmentStatus: \"Pending\",\n    regulatoryNotificationRequired: Boolean(detection.restrictedPiiInvolved),\n    documentationRetained: true,\n    classificationStandard: \"CLIO-IDS-V1\",\n    notes: [\n      `Auto-generated by CLIO IDS rule: ${detection.ruleId}`,\n      `Observed count: ${Number(detection.observedCount || 0)}`,\n      `Window: ${Number(detection.windowMinutes || 0)} minute(s)`,\n      `Source event: ${asString(entry?.id, \"N/A\")} | ${asString(entry?.module, \"System\")} | ${asString(entry?.activityName, \"Activity\")}`,\n      `Source IP: ${asString(sourceMetadata.sourceIp || entry?.sourceIp, \"unknown\")}`,\n      `Request: ${asString(sourceMetadata.requestMethod || entry?.requestMethod, \"GET\")} ${asString(sourceMetadata.requestPath || entry?.requestPath, \"unknown\")}`,\n    ].join(\"\\n\"),\n    autoGenerated: true,\n    detectionRuleId: detection.ruleId,\n    detectionFingerprint: fingerprint,\n    detectionWindowStart: new Date(nowMs - detection.windowMinutes * 60 * 1000).toISOString(),\n    detectionWindowEnd: new Date(nowMs).toISOString(),\n    sourceSystem: \"CLIO_IDS\",\n    sourceEventId: asString(entry?.id),\n    sourceEventModule: asString(entry?.module),\n    sourceEventPath: asString(sourceMetadata.requestPath || entry?.requestPath),\n    sourceIp: asString(sourceMetadata.sourceIp || entry?.sourceIp),\n    alertRecipients: [],\n    actionUrl: \"/incident-management\",\n  };\n\n  const created = await createIncidentRecordBackend(payload, actorEmail);\n  rememberIncidentCooldown(fingerprint, nowMs, config.incidentCooldownMinutes);\n  return created;\n}\n\nasync function createInAppIncidentNotifications({\n  incident,\n  detection,\n  recipients,\n  actionUrl,\n  actorEmail,\n}) {\n  const notifications = recipients.map((recipientEmail) => ({\n    recipientEmail,\n    title: toNotificationTitle(incident, detection),\n    message: toNotificationMessage(incident, detection),\n    severity: normalizeText(incident?.severity || detection?.severity || \"medium\"),\n    type: \"security-anomaly\",\n    module: \"Incident Management\",\n    actionUrl,\n    status: \"unread\",\n    createdBy: actorEmail,\n    metadata: {\n      incidentId: asString(incident?.id || incident?.recordId),\n      incidentCode: asString(incident?.incidentCode),\n      detectionRuleId: asString(detection?.ruleId),\n      autoGenerated: true,\n    },\n  }));\n  return await createInAppNotificationsBulk(notifications);\n}\n\nasync function executeDetectionWorkflow({\n  entry,\n  detection,\n  config,\n  fingerprint,\n  nowMs,\n}) {\n  const duplicate = await hasDuplicateIncident(fingerprint, nowMs, config);\n  if (duplicate) {\n    return {\n      detected: true,\n      duplicate: true,\n      detection,\n      fingerprint,\n    };\n  }\n\n  const incident = await createAutoIncident(entry, detection, config, fingerprint, nowMs);\n  const actionUrl = buildActionUrl(config, incident?.id || incident?.recordId);\n  const absoluteActionUrl = buildAbsoluteActionUrl(config, actionUrl);\n  const recipients = await resolveAlertRecipients(entry, detection, incident, config);\n  const inAppNotifications = await createInAppIncidentNotifications({\n    incident,\n    detection,\n    recipients,\n    actionUrl,\n    actorEmail: config.systemActorEmail,\n  });\n  const deliverySummary = await dispatchSecurityIncidentAlerts({\n    incident: {\n      ...incident,\n      actionUrl: absoluteActionUrl,\n    },\n    detection,\n    sourceEvent: entry,\n    emailRecipients: recipients,\n  });\n\n  const patchPayload = {\n    alertRecipients: recipients,\n    alertDispatchSummary: deliverySummary,\n    externalIntegrations: {\n      webhooks: deliverySummary?.webhooks || {},\n    },\n    lastAlertDispatchAt: nowIso(),\n  };\n  await updateIncidentRecordBackend(incident.id, patchPayload, config.systemActorEmail).catch(() => null);\n\n  return {\n    detected: true,\n    duplicate: false,\n    detection,\n    incidentRecord: incident,\n    fingerprint,\n    recipients,\n    inAppNotificationCount: inAppNotifications.length,\n    deliverySummary,\n  };\n}\n\nfunction hasForcedDetectionPayload(value) {\n  return Boolean(value && typeof value === \"object\" && !Array.isArray(value));\n}\n\nasync function processSingleRetryQueueRecord(config, row) {\n  const recordId = asString(row?.id);\n  if (!recordId) {\n    return { processed: false, reason: \"missing_retry_record_id\" };\n  }\n\n  const attempts = Math.max(1, Number(row?.attempts || 1));\n  const maxAttempts = Math.max(1, Number(row?.maxAttempts || config.retryMaxAttempts || 5));\n  const entry = asObject(row?.entry);\n  const detection = asObject(row?.detection);\n  const fingerprint = asString(row?.fingerprint);\n  if (!fingerprint || !asString(detection?.ruleId) || (!asString(entry?.activityName) && !asString(entry?.module))) {\n    await moveRetryRecordToDeadLetter(config, row, \"invalid_retry_payload\");\n    await deleteRetryQueueRecord(config, recordId);\n    return { processed: false, deadLettered: true, reason: \"invalid_retry_payload\" };\n  }\n\n  const result = await processAuditEventForSecurityDetections(entry, {\n    forcedDetection: detection,\n    forcedFingerprint: fingerprint,\n    skipQueueOnError: true,\n    disableQueueDrain: true,\n  });\n\n  if (!result?.failed) {\n    await deleteRetryQueueRecord(config, recordId);\n    return {\n      processed: true,\n      duplicate: Boolean(result?.duplicate),\n      detected: Boolean(result?.detected),\n    };\n  }\n\n  const nextAttempts = attempts + 1;\n  const errorMessage = asString(result?.error, \"ids_processing_failed\");\n  if (nextAttempts > maxAttempts) {\n    await moveRetryRecordToDeadLetter(config, {\n      ...row,\n      attempts: nextAttempts,\n      maxAttempts,\n      lastError: errorMessage,\n    }, errorMessage);\n    await deleteRetryQueueRecord(config, recordId);\n    return {\n      processed: false,\n      deadLettered: true,\n      reason: errorMessage,\n    };\n  }\n\n  const nextAttemptAt = new Date(Date.now() + getRetryDelaySeconds(nextAttempts, config) * 1000).toISOString();\n  await updateRetryQueueRecord(config, recordId, {\n    attempts: nextAttempts,\n    maxAttempts,\n    nextAttemptAt,\n    lastError: errorMessage,\n    status: \"pending\",\n  });\n\n  return {\n    processed: false,\n    retried: true,\n    reason: errorMessage,\n    nextAttemptAt,\n  };\n}\n\nexport async function drainSecurityDetectionRetryQueue({ reason = \"manual\", batchSize } = {}) {\n  const config = getDetectionConfig();\n  if (!config.enabled || !config.retryEnabled) {\n    return {\n      processedCount: 0,\n      reason: !config.enabled ? \"ids_disabled\" : \"retry_disabled\",\n    };\n  }\n\n  if (IDS_RETRY_DRAIN_PROMISE) {\n    return IDS_RETRY_DRAIN_PROMISE;\n  }\n\n  IDS_RETRY_DRAIN_PROMISE = (async () => {\n    const dueRecords = await listDueRetryQueueRecords(config, {\n      batchSize: Number(batchSize || config.retryBatchSize || 8),\n    });\n    let processedCount = 0;\n    let deadLetterCount = 0;\n    let failedCount = 0;\n\n    for (const row of dueRecords) {\n      try {\n        const result = await processSingleRetryQueueRecord(config, row);\n        if (result?.processed) {\n          processedCount += 1;\n        }\n        if (result?.deadLettered) {\n          deadLetterCount += 1;\n        }\n      } catch {\n        failedCount += 1;\n      }\n    }\n\n    return {\n      reason: asString(reason, \"manual\"),\n      processedCount,\n      deadLetterCount,\n      failedCount,\n      dueCount: dueRecords.length,\n    };\n  })();\n\n  try {\n    return await IDS_RETRY_DRAIN_PROMISE;\n  } finally {\n    IDS_RETRY_DRAIN_PROMISE = null;\n  }\n}\n\nexport async function processAuditEventForSecurityDetections(entry, options = {}) {\n  const config = getDetectionConfig();\n  if (!config.enabled) {\n    return {\n      detected: false,\n      reason: \"ids_disabled\",\n    };\n  }\n\n  if (!entry || typeof entry !== \"object\") {\n    return {\n      detected: false,\n      reason: \"invalid_audit_entry\",\n    };\n  }\n\n  if (!options?.disableQueueDrain && config.retryEnabled) {\n    void drainSecurityDetectionRetryQueue({ reason: \"audit-event\" }).catch(() => null);\n  }\n\n  const forcedDetection = hasForcedDetectionPayload(options?.forcedDetection)\n    ? options.forcedDetection\n    : null;\n  if (!forcedDetection && shouldSkipEvent(entry)) {\n    return {\n      detected: false,\n      reason: \"event_skipped\",\n    };\n  }\n\n  const context = extractEventContext(entry);\n  const detection = forcedDetection || detectSuspiciousEvent(entry, context, config);\n  if (!detection) {\n    return {\n      detected: false,\n      reason: \"no_rule_match\",\n    };\n  }\n\n  const nowMs = context.occurredAtMs || Date.now();\n  const fingerprint =\n    asString(options?.forcedFingerprint) ||\n    buildFingerprint(\n      detection.ruleId,\n      entry,\n      detection,\n      nowMs,\n      detection.windowMinutes || config.incidentCooldownMinutes,\n    );\n\n  try {\n    return await executeDetectionWorkflow({\n      entry,\n      detection,\n      config,\n      fingerprint,\n      nowMs,\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? asString(error.message, \"ids_processing_failed\") : \"ids_processing_failed\";\n    if (options?.skipQueueOnError) {\n      return {\n        detected: true,\n        duplicate: false,\n        failed: true,\n        detection,\n        fingerprint,\n        reason: \"processing_failed\",\n        error: errorMessage,\n      };\n    }\n\n    const queueResult = await enqueueDetectionRetryWorkItem({\n      entry,\n      detection,\n      fingerprint,\n      errorMessage,\n      config,\n      attempts: 1,\n      source: \"live\",\n    });\n    return {\n      detected: true,\n      duplicate: false,\n      failed: true,\n      queuedForRetry: Boolean(queueResult?.queued),\n      retryRecordId: asString(queueResult?.retryRecordId),\n      detection,\n      fingerprint,\n      reason: \"processing_failed\",\n      error: errorMessage,\n    };\n  }\n}\n"],"names":[],"mappings":"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"}