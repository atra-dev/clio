{"version":3,"sources":["../../../../src/lib/hris-backend.js","../../../../src/lib/invite-delivery.js","../../../../src/lib/security-notifications.js","../../../../src/lib/security-alert-delivery.js","../../../../src/lib/security-detection.js"],"sourcesContent":["import {\r\n  addDoc,\r\n  collection,\r\n  deleteField,\r\n  deleteDoc,\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  query,\r\n  updateDoc,\r\n  where,\r\n} from \"firebase/firestore/lite\";\r\nimport { getFirestoreDb, isFirestoreEnabled } from \"@/lib/firebase\";\r\nimport {\r\n  archiveUserAccount,\r\n  getLoginAccount,\r\n  inviteUserAccount,\r\n  listUserAccounts,\r\n  purgeDueArchivedUserAccounts,\r\n  revokeInviteById,\r\n  updateUserAccountRole,\r\n  updateUserAccountStatus,\r\n} from \"@/lib/user-accounts\";\r\nimport { deliverInviteEmail } from \"@/lib/invite-delivery\";\r\nimport { formatEmployeeName } from \"@/lib/name-utils\";\r\nimport { listAuditEvents } from \"@/lib/audit-log\";\r\n\r\nconst MAX_AUDIT_TRAIL_ITEMS = 80;\r\nconst DEFAULT_ARCHIVE_RETENTION_YEARS = 5;\r\nconst MAX_LIFECYCLE_CHECKLIST_ITEMS = 32;\r\nconst MAX_LIFECYCLE_EVIDENCE_ITEMS = 80;\r\nconst MAX_INCIDENT_EVIDENCE_ITEMS = 50;\r\nconst MAX_INCIDENT_FORENSIC_SAMPLES = 8;\r\nconst MAX_REFERENCE_LABEL_LENGTH = 72;\r\nconst MAX_REFERENCE_CATALOG_ITEMS = 256;\r\nconst ALLOWED_REFERENCE_KINDS = new Set([\"role\", \"department\"]);\r\nconst SYSTEM_REFERENCE_ROLES = [\r\n  { value: \"SUPER_ADMIN\", label: \"Super Admin\" },\r\n  { value: \"GRC\", label: \"GRC\" },\r\n  { value: \"HR\", label: \"HR\" },\r\n  { value: \"EA\", label: \"EA\" },\r\n  { value: \"EMPLOYEE_L1\", label: \"Employee (L1)\" },\r\n  { value: \"EMPLOYEE_L2\", label: \"Employee (L2)\" },\r\n  { value: \"EMPLOYEE_L3\", label: \"Employee (L3)\" },\r\n];\r\nconst SYSTEM_REFERENCE_DEPARTMENTS = [\r\n  \"Governance, Risk, and Compliance (GRC)\",\r\n  \"Research and Development (R&D)\",\r\n  \"Cyber Security Operations Center (CSOC)\",\r\n  \"Threat Intelligence (TI)\",\r\n];\r\nconst LIFECYCLE_ROLE_ALIAS = new Map([\r\n  [\"SUPER_ADMIN\", \"SUPER_ADMIN\"],\r\n  [\"SUPERADMIN\", \"SUPER_ADMIN\"],\r\n  [\"ADMIN\", \"SUPER_ADMIN\"],\r\n  [\"GRC\", \"GRC\"],\r\n  [\"HR\", \"HR\"],\r\n  [\"EA\", \"EA\"],\r\n  [\"EMPLOYEE\", \"EMPLOYEE_L1\"],\r\n  [\"EMPLOYEE_L1\", \"EMPLOYEE_L1\"],\r\n  [\"EMPLOYEE_L2\", \"EMPLOYEE_L2\"],\r\n  [\"EMPLOYEE_L3\", \"EMPLOYEE_L3\"],\r\n  [\"L1\", \"EMPLOYEE_L1\"],\r\n  [\"L2\", \"EMPLOYEE_L2\"],\r\n  [\"L3\", \"EMPLOYEE_L3\"],\r\n]);\r\n\r\nconst LIFECYCLE_WORKFLOW_TEMPLATES = {\r\n  onboarding: {\r\n    type: \"onboarding\",\r\n    category: \"Onboarding\",\r\n    stages: [\"Initiated\", \"Document Verification\", \"Access Provisioning\", \"Activation\"],\r\n    checklist: [\r\n      { id: \"profile-intake\", label: \"Collect employee profile and contacts\", required: true, slaHours: 12 },\r\n      { id: \"contract-check\", label: \"Validate contract and onboarding requirements\", required: true, slaHours: 24 },\r\n      { id: \"account-activation\", label: \"Activate employee account\", required: true, slaHours: 48 },\r\n    ],\r\n    approverRoles: [\"HR\", \"GRC\"],\r\n    slaHours: 72,\r\n  },\r\n  \"role-change\": {\r\n    type: \"role-change\",\r\n    category: \"Role Change\",\r\n    stages: [\"Initiated\", \"Approval Review\", \"Role Sync\", \"Completed\"],\r\n    checklist: [\r\n      { id: \"movement-justification\", label: \"Attach role-change justification\", required: true, slaHours: 24 },\r\n      { id: \"effective-date-review\", label: \"Validate effective date and scope\", required: true, slaHours: 24 },\r\n      { id: \"permission-sync\", label: \"Apply role and permission sync\", required: true, slaHours: 48 },\r\n    ],\r\n    approverRoles: [\"HR\", \"GRC\"],\r\n    slaHours: 96,\r\n  },\r\n  disciplinary: {\r\n    type: \"disciplinary\",\r\n    category: \"Disciplinary\",\r\n    stages: [\"Case Opened\", \"Investigation\", \"Decision\", \"Closed\"],\r\n    checklist: [\r\n      { id: \"incident-report\", label: \"Record incident report\", required: true, slaHours: 24 },\r\n      { id: \"evidence-review\", label: \"Attach and review case evidence\", required: true, slaHours: 48 },\r\n      { id: \"decision-log\", label: \"Finalize disciplinary decision\", required: true, slaHours: 72 },\r\n    ],\r\n    approverRoles: [\"HR\", \"GRC\"],\r\n    slaHours: 120,\r\n  },\r\n  offboarding: {\r\n    type: \"offboarding\",\r\n    category: \"Offboarding\",\r\n    stages: [\"Initiated\", \"Clearance\", \"Access Revocation\", \"Archived\"],\r\n    checklist: [\r\n      { id: \"clearance-init\", label: \"Start employee clearance checklist\", required: true, slaHours: 12 },\r\n      { id: \"access-revoked\", label: \"Disable account and revoke access\", required: true, slaHours: 24 },\r\n      { id: \"archive-records\", label: \"Archive employee records\", required: true, slaHours: 48 },\r\n    ],\r\n    approverRoles: [\"HR\", \"GRC\"],\r\n    slaHours: 72,\r\n  },\r\n};\r\n\r\nconst LIFECYCLE_PRIVILEGED_TARGET_ROLES = new Set([\"SUPER_ADMIN\", \"GRC\", \"HR\", \"EA\"]);\r\nconst LIFECYCLE_ASSIGNABLE_BY_PRIVILEGED = new Set([\"EMPLOYEE_L1\", \"EMPLOYEE_L2\", \"EMPLOYEE_L3\"]);\r\nconst LIFECYCLE_ASSIGNABLE_BY_GRC = new Set([\"GRC\", \"HR\", \"EA\", \"EMPLOYEE_L1\", \"EMPLOYEE_L2\", \"EMPLOYEE_L3\"]);\r\nconst LIFECYCLE_REQUIRED_EVIDENCE_RULES = {\r\n  disciplinary: [\r\n    {\r\n      id: \"incident-report\",\r\n      label: \"Incident Report\",\r\n      keywords: [\"incident\", \"report\"],\r\n    },\r\n    {\r\n      id: \"notice-to-explain\",\r\n      label: \"Notice to Explain / Written Explanation\",\r\n      keywords: [\"notice\", \"explain\", \"written explanation\", \"explanation\"],\r\n    },\r\n    {\r\n      id: \"decision-memo\",\r\n      label: \"Decision Memo\",\r\n      keywords: [\"decision\", \"memo\"],\r\n    },\r\n  ],\r\n  offboarding: [\r\n    {\r\n      id: \"resignation-termination\",\r\n      label: \"Resignation / Termination Document\",\r\n      keywords: [\"resignation\", \"termination\", \"termination notice\"],\r\n    },\r\n    {\r\n      id: \"clearance-form\",\r\n      label: \"Clearance Form\",\r\n      keywords: [\"clearance\"],\r\n    },\r\n    {\r\n      id: \"handover-exit\",\r\n      label: \"Handover / Exit Checklist\",\r\n      keywords: [\"handover\", \"exit checklist\", \"exit interview\", \"knowledge transfer\"],\r\n    },\r\n  ],\r\n};\r\nconst INCIDENT_SEVERITY_LEVELS = [\"Low\", \"High\"];\r\nconst INCIDENT_STATUS_VALUES = [\"Open\", \"Containment\", \"Investigating\", \"Escalated\", \"Regulatory Review\", \"Resolved\", \"Closed\"];\r\nconst INCIDENT_CONTAINMENT_STATUS_VALUES = [\"Not Started\", \"In Progress\", \"Contained\"];\r\nconst INCIDENT_IMPACT_STATUS_VALUES = [\"Pending\", \"In Progress\", \"Completed\"];\r\nconst INCIDENT_TYPE_VALUES = [\r\n  \"Unauthorized Access\",\r\n  \"Data Exposure\",\r\n  \"Credential Compromise\",\r\n  \"Insider Misuse\",\r\n  \"Malware / Ransomware\",\r\n  \"Policy Violation\",\r\n  \"System Misconfiguration\",\r\n  \"Other\",\r\n];\r\nconst DEFAULT_INCIDENT_EVIDENCE_MAX_BYTES = 10 * 1024 * 1024;\r\nconst DEFAULT_INCIDENT_EVIDENCE_ALLOWED_EXTENSIONS = new Set([\r\n  \"pdf\",\r\n  \"png\",\r\n  \"jpg\",\r\n  \"jpeg\",\r\n  \"webp\",\r\n  \"doc\",\r\n  \"docx\",\r\n  \"xls\",\r\n  \"xlsx\",\r\n  \"csv\",\r\n  \"txt\",\r\n]);\r\nconst DEFAULT_INCIDENT_EVIDENCE_ALLOWED_MIME_TYPES = new Set([\r\n  \"application/pdf\",\r\n  \"image/png\",\r\n  \"image/jpeg\",\r\n  \"image/webp\",\r\n  \"application/msword\",\r\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\r\n  \"application/vnd.ms-excel\",\r\n  \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\r\n  \"text/csv\",\r\n  \"text/plain\",\r\n]);\r\n\r\nfunction env(name, fallback) {\r\n  const value = String(process.env[name] || \"\").trim();\r\n  return value || fallback;\r\n}\r\n\r\nfunction parseBooleanEnv(name, fallbackValue = false) {\r\n  const raw = String(process.env[name] || \"\")\r\n    .trim()\r\n    .toLowerCase();\r\n  if (!raw) {\r\n    return fallbackValue;\r\n  }\r\n  return raw === \"true\" || raw === \"1\" || raw === \"yes\";\r\n}\r\n\r\nfunction parseCsvSet(value, fallbackSet) {\r\n  const normalized = String(value || \"\")\r\n    .split(\",\")\r\n    .map((item) => String(item || \"\").trim().toLowerCase())\r\n    .filter(Boolean);\r\n  if (normalized.length === 0) {\r\n    return new Set([...fallbackSet]);\r\n  }\r\n  return new Set(normalized);\r\n}\r\n\r\nfunction parseIntegerEnv(name, fallbackValue, { min = 1, max = Number.MAX_SAFE_INTEGER } = {}) {\r\n  const parsed = Number.parseInt(String(process.env[name] || \"\").trim(), 10);\r\n  if (!Number.isFinite(parsed)) {\r\n    return fallbackValue;\r\n  }\r\n  return Math.min(max, Math.max(min, parsed));\r\n}\r\n\r\nfunction getIncidentEvidenceValidationConfig() {\r\n  return {\r\n    maxBytes: parseIntegerEnv(\"CLIO_INCIDENT_EVIDENCE_MAX_BYTES\", DEFAULT_INCIDENT_EVIDENCE_MAX_BYTES, {\r\n      min: 128 * 1024,\r\n      max: 50 * 1024 * 1024,\r\n    }),\r\n    allowedExtensions: parseCsvSet(\r\n      process.env.CLIO_INCIDENT_EVIDENCE_ALLOWED_EXTENSIONS,\r\n      DEFAULT_INCIDENT_EVIDENCE_ALLOWED_EXTENSIONS,\r\n    ),\r\n    allowedMimeTypes: parseCsvSet(\r\n      process.env.CLIO_INCIDENT_EVIDENCE_ALLOWED_MIME_TYPES,\r\n      DEFAULT_INCIDENT_EVIDENCE_ALLOWED_MIME_TYPES,\r\n    ),\r\n  };\r\n}\r\n\r\nfunction isInviteDeliveryRequired() {\r\n  const defaultRequired = process.env.NODE_ENV === \"production\";\r\n  return parseBooleanEnv(\"CLIO_REQUIRE_EMAIL_DELIVERY\", defaultRequired);\r\n}\r\n\r\nfunction extractDeliveryErrorInfo(reason) {\r\n  const normalized = String(reason || \"\").trim();\r\n  if (normalized.startsWith(\"email_delivery_failed:\")) {\r\n    return {\r\n      code: \"email_delivery_failed\",\r\n      providerMessage: normalized.slice(\"email_delivery_failed:\".length).trim(),\r\n    };\r\n  }\r\n\r\n  return {\r\n    code: normalized || \"email_delivery_failed\",\r\n    providerMessage: \"\",\r\n  };\r\n}\r\n\r\nfunction nowIso() {\r\n  return new Date().toISOString();\r\n}\r\n\r\nfunction addYearsToIso(isoTimestamp, years) {\r\n  const base = new Date(isoTimestamp);\r\n  if (Number.isNaN(base.getTime())) {\r\n    const fallback = new Date();\r\n    fallback.setUTCFullYear(fallback.getUTCFullYear() + years);\r\n    return fallback.toISOString();\r\n  }\r\n  base.setUTCFullYear(base.getUTCFullYear() + years);\r\n  return base.toISOString();\r\n}\r\n\r\nfunction getArchiveRetentionYears() {\r\n  const raw = Number.parseInt(String(process.env.CLIO_RETENTION_YEARS || \"\").trim(), 10);\r\n  if (!Number.isFinite(raw) || raw < 1) {\r\n    return DEFAULT_ARCHIVE_RETENTION_YEARS;\r\n  }\r\n  return Math.min(raw, 25);\r\n}\r\n\r\nfunction asString(value, fallback = \"\") {\r\n  const normalized = String(value ?? \"\").trim();\r\n  return normalized || fallback;\r\n}\r\n\r\nfunction normalizeText(value) {\r\n  return String(value || \"\")\r\n    .trim()\r\n    .toLowerCase();\r\n}\r\n\r\nfunction normalizeEmail(value) {\r\n  return String(value || \"\").trim().toLowerCase();\r\n}\r\n\r\nfunction normalizeRoleKey(value) {\r\n  return String(value || \"\")\r\n    .trim()\r\n    .toUpperCase()\r\n    .replace(/[^A-Z0-9]+/g, \"_\")\r\n    .replace(/^_+|_+$/g, \"\");\r\n}\r\n\r\nfunction normalizeReferenceKind(value) {\r\n  const normalized = String(value || \"\")\r\n    .trim()\r\n    .toLowerCase();\r\n  return ALLOWED_REFERENCE_KINDS.has(normalized) ? normalized : \"\";\r\n}\r\n\r\nfunction normalizeReferenceLabel(value) {\r\n  return String(value || \"\")\r\n    .trim()\r\n    .replace(/\\s+/g, \" \");\r\n}\r\n\r\nfunction normalizeDepartmentKey(value) {\r\n  return String(value || \"\")\r\n    .trim()\r\n    .toLowerCase()\r\n    .replace(/[^a-z0-9]+/g, \"-\")\r\n    .replace(/^-+|-+$/g, \"\");\r\n}\r\n\r\nfunction normalizeReferenceKey(kind, value) {\r\n  const normalizedKind = normalizeReferenceKind(kind);\r\n  if (!normalizedKind) {\r\n    return \"\";\r\n  }\r\n  if (normalizedKind === \"role\") {\r\n    return normalizeRoleKey(value);\r\n  }\r\n  return normalizeDepartmentKey(value);\r\n}\r\n\r\nfunction buildSystemReferenceCatalog() {\r\n  const roles = SYSTEM_REFERENCE_ROLES.map((entry) => {\r\n    const value = asString(entry.value);\r\n    const label = asString(entry.label, value);\r\n    const key = normalizeReferenceKey(\"role\", value || label);\r\n    return {\r\n      id: `system-role-${key}`,\r\n      kind: \"role\",\r\n      key,\r\n      value,\r\n      label,\r\n      isSystem: true,\r\n      createdAt: \"\",\r\n      updatedAt: \"\",\r\n    };\r\n  });\r\n\r\n  const departments = SYSTEM_REFERENCE_DEPARTMENTS.map((entry) => {\r\n    const label = asString(entry);\r\n    const key = normalizeReferenceKey(\"department\", label);\r\n    return {\r\n      id: `system-department-${key}`,\r\n      kind: \"department\",\r\n      key,\r\n      value: label,\r\n      label,\r\n      isSystem: true,\r\n      createdAt: \"\",\r\n      updatedAt: \"\",\r\n    };\r\n  });\r\n\r\n  return {\r\n    roles,\r\n    departments,\r\n  };\r\n}\r\n\r\nfunction sortReferenceCatalogItems(items) {\r\n  return [...items].sort((left, right) => {\r\n    if (Boolean(left?.isSystem) !== Boolean(right?.isSystem)) {\r\n      return left?.isSystem ? -1 : 1;\r\n    }\r\n    return String(left?.label || \"\").localeCompare(String(right?.label || \"\"), undefined, {\r\n      sensitivity: \"base\",\r\n    });\r\n  });\r\n}\r\n\r\nfunction asArray(value) {\r\n  return Array.isArray(value) ? value : [];\r\n}\r\n\r\nfunction asObject(value, fallback = {}) {\r\n  if (value && typeof value === \"object\" && !Array.isArray(value)) {\r\n    return value;\r\n  }\r\n  return fallback;\r\n}\r\n\r\nfunction asBoolean(value, fallback = false) {\r\n  if (typeof value === \"boolean\") {\r\n    return value;\r\n  }\r\n  if (typeof value === \"number\") {\r\n    return value !== 0;\r\n  }\r\n  if (typeof value === \"string\") {\r\n    const normalized = value.trim().toLowerCase();\r\n    if (!normalized) {\r\n      return fallback;\r\n    }\r\n    if ([\"true\", \"1\", \"yes\", \"y\", \"on\"].includes(normalized)) {\r\n      return true;\r\n    }\r\n    if ([\"false\", \"0\", \"no\", \"n\", \"off\"].includes(normalized)) {\r\n      return false;\r\n    }\r\n  }\r\n  return fallback;\r\n}\r\n\r\nfunction normalizeEmployeeDocumentsPayload(documents, { actorEmail, now } = {}) {\r\n  const fallbackActor = normalizeEmail(actorEmail) || \"system@gmail.com\";\r\n  const fallbackAt = asString(now, nowIso());\r\n  return asArray(documents)\r\n    .map((entry, index) => {\r\n      const source = asObject(entry, {});\r\n      const uploadedAt = asString(source.uploadedAt, fallbackAt);\r\n      const uploadedBy = normalizeEmail(source.uploadedBy || fallbackActor) || fallbackActor;\r\n      const sizeRaw = Number(source.sizeBytes);\r\n      return {\r\n        id: asString(source.id),\r\n        name: asString(source.name, \"Employee Document\"),\r\n        type: asString(source.type, \"General\"),\r\n        ref: asString(source.ref),\r\n        storagePath: asString(source.storagePath),\r\n        contentType: asString(source.contentType),\r\n        sizeBytes: Number.isFinite(sizeRaw) && sizeRaw >= 0 ? sizeRaw : 0,\r\n        uploadedAt,\r\n        uploadedBy,\r\n        order: Number.isFinite(Number(source.order)) ? Number(source.order) : index,\r\n      };\r\n    })\r\n    .filter((entry) => entry.ref || entry.name);\r\n}\r\n\r\nasync function listEmployeeDocumentSubcollectionById(recordId, { db } = {}) {\r\n  const normalizedId = asString(recordId);\r\n  if (!normalizedId) {\r\n    return [];\r\n  }\r\n\r\n  const database = db || getDbOrThrow();\r\n  const employeesCollection = getCollectionName(\"employees\");\r\n  const subcollectionName = getEmployeeDocumentsSubcollectionName();\r\n  const snapshot = await getDocs(collection(database, employeesCollection, normalizedId, subcollectionName));\r\n  return snapshot.docs\r\n    .map((item, index) => {\r\n      const payload = normalizeEmployeeDocumentsPayload([item.data()], {\r\n        now: nowIso(),\r\n      })[0];\r\n      if (!payload) {\r\n        return null;\r\n      }\r\n      return {\r\n        ...payload,\r\n        id: item.id,\r\n        recordId: item.id,\r\n        order: Number.isFinite(Number(payload.order)) ? Number(payload.order) : index,\r\n      };\r\n    })\r\n    .filter(Boolean)\r\n    .sort((left, right) => {\r\n      const leftTime = new Date(left.uploadedAt || 0).getTime();\r\n      const rightTime = new Date(right.uploadedAt || 0).getTime();\r\n      if (Number.isFinite(leftTime) && Number.isFinite(rightTime) && rightTime !== leftTime) {\r\n        return rightTime - leftTime;\r\n      }\r\n      return Number(left.order || 0) - Number(right.order || 0);\r\n    });\r\n}\r\n\r\nasync function deleteEmployeeDocumentSubcollectionById(recordId, { db } = {}) {\r\n  const normalizedId = asString(recordId);\r\n  if (!normalizedId) {\r\n    return 0;\r\n  }\r\n\r\n  const database = db || getDbOrThrow();\r\n  const employeesCollection = getCollectionName(\"employees\");\r\n  const subcollectionName = getEmployeeDocumentsSubcollectionName();\r\n  const snapshot = await getDocs(collection(database, employeesCollection, normalizedId, subcollectionName));\r\n  let removed = 0;\r\n  for (const item of snapshot.docs) {\r\n    await deleteDoc(item.ref);\r\n    removed += 1;\r\n  }\r\n  return removed;\r\n}\r\n\r\nasync function replaceEmployeeDocumentSubcollectionById(recordId, documents, { actorEmail, db } = {}) {\r\n  const normalizedId = asString(recordId);\r\n  if (!normalizedId) {\r\n    throw new Error(\"invalid_record_id\");\r\n  }\r\n\r\n  const database = db || getDbOrThrow();\r\n  const employeesCollection = getCollectionName(\"employees\");\r\n  const subcollectionName = getEmployeeDocumentsSubcollectionName();\r\n  const collectionRef = collection(database, employeesCollection, normalizedId, subcollectionName);\r\n  const normalizedDocuments = normalizeEmployeeDocumentsPayload(documents, {\r\n    actorEmail,\r\n    now: nowIso(),\r\n  });\r\n\r\n  await deleteEmployeeDocumentSubcollectionById(normalizedId, { db: database });\r\n  const created = [];\r\n  for (const item of normalizedDocuments) {\r\n    const payload = {\r\n      name: item.name,\r\n      type: item.type,\r\n      ref: item.ref,\r\n      storagePath: item.storagePath,\r\n      contentType: item.contentType,\r\n      sizeBytes: item.sizeBytes,\r\n      uploadedAt: item.uploadedAt,\r\n      uploadedBy: item.uploadedBy,\r\n      order: item.order,\r\n    };\r\n    const createdRef = await addDoc(collectionRef, payload);\r\n    created.push({\r\n      ...payload,\r\n      id: createdRef.id,\r\n      recordId: createdRef.id,\r\n    });\r\n  }\r\n\r\n  return created\r\n    .sort((left, right) => new Date(right.uploadedAt || 0).getTime() - new Date(left.uploadedAt || 0).getTime())\r\n    .map((item, index) => ({\r\n      ...item,\r\n      order: Number.isFinite(Number(item.order)) ? Number(item.order) : index,\r\n    }));\r\n}\r\n\r\nfunction resolveEmployeeDocumentsForResponse(record, subcollectionDocs = []) {\r\n  if (Array.isArray(subcollectionDocs) && subcollectionDocs.length > 0) {\r\n    return subcollectionDocs;\r\n  }\r\n  return normalizeEmployeeDocumentsPayload(record?.documents, {\r\n    actorEmail: record?.updatedBy || record?.createdBy,\r\n    now: record?.updatedAt || record?.createdAt || nowIso(),\r\n  });\r\n}\r\n\r\nfunction withEmployeeDocuments(record, documents = []) {\r\n  const normalized = Array.isArray(documents) ? documents : [];\r\n  return {\r\n    ...record,\r\n    documents: normalized,\r\n    documentsCount: normalized.length,\r\n  };\r\n}\r\n\r\nasync function resolveAndMigrateEmployeeDocuments(record, { db } = {}) {\r\n  if (!record?.id) {\r\n    return [];\r\n  }\r\n\r\n  const documentsFromSubcollection = await listEmployeeDocumentSubcollectionById(record.id, { db });\r\n  if (documentsFromSubcollection.length > 0) {\r\n    return documentsFromSubcollection;\r\n  }\r\n\r\n  const legacyDocuments = resolveEmployeeDocumentsForResponse(record, []);\r\n  if (legacyDocuments.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  const migrated = await replaceEmployeeDocumentSubcollectionById(record.id, legacyDocuments, {\r\n    actorEmail: record.updatedBy || record.createdBy,\r\n    db,\r\n  });\r\n  await clearLegacyEmployeeDocumentsField(record.id, {\r\n    documentsCount: migrated.length,\r\n    db,\r\n  });\r\n  return migrated;\r\n}\r\n\r\nasync function clearLegacyEmployeeDocumentsField(recordId, { documentsCount, db } = {}) {\r\n  const normalizedId = asString(recordId);\r\n  if (!normalizedId) {\r\n    return;\r\n  }\r\n\r\n  const database = db || getDbOrThrow();\r\n  const patch = {\r\n    documents: deleteField(),\r\n  };\r\n  if (Number.isFinite(Number(documentsCount))) {\r\n    patch.documentsCount = Math.max(0, Number(documentsCount));\r\n  }\r\n  await updateDoc(doc(database, getCollectionName(\"employees\"), normalizedId), patch);\r\n}\r\n\r\nfunction toEmployeeDocumentMergeKey(document) {\r\n  const storagePath = asString(document?.storagePath);\r\n  if (storagePath) {\r\n    return `path:${storagePath}`;\r\n  }\r\n  const ref = asString(document?.ref);\r\n  if (ref) {\r\n    return `ref:${ref}`;\r\n  }\r\n  return `fallback:${asString(document?.name)}|${Number.isFinite(Number(document?.sizeBytes)) ? Number(document.sizeBytes) : 0}|${asString(\r\n    document?.uploadedAt,\r\n  )}`;\r\n}\r\n\r\nfunction mergeEmployeeDocuments(existingDocuments, incomingDocuments) {\r\n  const merged = [];\r\n  const seen = new Set();\r\n  let addedCount = 0;\r\n\r\n  const pushUnique = (entry, trackAdded = false) => {\r\n    const normalized = normalizeEmployeeDocumentsPayload([entry], {\r\n      actorEmail: entry?.uploadedBy,\r\n      now: entry?.uploadedAt,\r\n    })[0];\r\n    if (!normalized) {\r\n      return;\r\n    }\r\n    const key = toEmployeeDocumentMergeKey(normalized);\r\n    if (seen.has(key)) {\r\n      return;\r\n    }\r\n    seen.add(key);\r\n    merged.push(normalized);\r\n    if (trackAdded) {\r\n      addedCount += 1;\r\n    }\r\n  };\r\n\r\n  asArray(existingDocuments).forEach((entry) => pushUnique(entry, false));\r\n  asArray(incomingDocuments).forEach((entry) => pushUnique(entry, true));\r\n\r\n  return {\r\n    merged,\r\n    addedCount,\r\n  };\r\n}\r\n\r\nfunction toOnboardingEvidenceDocuments(evidence, actorEmail) {\r\n  const now = nowIso();\r\n  const mapped = asArray(evidence).map((item) => {\r\n    const source = asObject(item, {});\r\n    return {\r\n      id: asString(source.id),\r\n      name: asString(source.name, \"Onboarding Document\"),\r\n      type: asString(source.type, \"Onboarding\"),\r\n      ref: asString(source.ref),\r\n      storagePath: asString(source.storagePath),\r\n      contentType: asString(source.contentType),\r\n      sizeBytes: Number.isFinite(Number(source.sizeBytes)) ? Number(source.sizeBytes) : 0,\r\n      uploadedAt: asString(source.uploadedAt, now),\r\n      uploadedBy: asString(source.uploadedBy, actorEmail),\r\n    };\r\n  });\r\n  return normalizeEmployeeDocumentsPayload(mapped, {\r\n    actorEmail,\r\n    now,\r\n  });\r\n}\r\n\r\nasync function syncOnboardingEvidenceToEmployeeDocuments(record, actorEmail) {\r\n  const category = asString(record?.category).toLowerCase();\r\n  if (!category.includes(\"onboarding\")) {\r\n    return {\r\n      synced: false,\r\n      addedCount: 0,\r\n    };\r\n  }\r\n\r\n  const employeeEmail = normalizeEmail(record?.employeeEmail);\r\n  if (!employeeEmail) {\r\n    return {\r\n      synced: false,\r\n      addedCount: 0,\r\n    };\r\n  }\r\n\r\n  const onboardingDocuments = toOnboardingEvidenceDocuments(record?.evidence, actorEmail);\r\n  if (onboardingDocuments.length === 0) {\r\n    return {\r\n      synced: false,\r\n      addedCount: 0,\r\n    };\r\n  }\r\n\r\n  const employeeRows = await listCollectionRecords(getCollectionName(\"employees\"), {\r\n    filterField: \"email\",\r\n    filterValue: employeeEmail,\r\n  });\r\n  const employeeRecord = employeeRows[0];\r\n  if (!employeeRecord?.id) {\r\n    return {\r\n      synced: false,\r\n      addedCount: 0,\r\n    };\r\n  }\r\n\r\n  const existingDocuments = await resolveAndMigrateEmployeeDocuments(employeeRecord);\r\n  const { merged, addedCount } = mergeEmployeeDocuments(existingDocuments, onboardingDocuments);\r\n  if (addedCount <= 0) {\r\n    return {\r\n      synced: false,\r\n      addedCount: 0,\r\n    };\r\n  }\r\n\r\n  const syncedDocuments = await replaceEmployeeDocumentSubcollectionById(employeeRecord.id, merged, {\r\n    actorEmail,\r\n  });\r\n  await clearLegacyEmployeeDocumentsField(employeeRecord.id, {\r\n    documentsCount: syncedDocuments.length,\r\n  });\r\n\r\n  return {\r\n    synced: true,\r\n    addedCount,\r\n    documentsCount: syncedDocuments.length,\r\n    employeeRecordId: employeeRecord.id,\r\n  };\r\n}\r\n\r\nasync function collectOnboardingEvidenceDocumentsByEmployeeEmail(employeeEmail, actorEmail) {\r\n  const normalizedEmail = normalizeEmail(employeeEmail);\r\n  if (!normalizedEmail) {\r\n    return [];\r\n  }\r\n\r\n  const lifecycleRows = await listCollectionRecords(getCollectionName(\"lifecycle\"), {\r\n    filterField: \"employeeEmail\",\r\n    filterValue: normalizedEmail,\r\n  });\r\n\r\n  const onboardingEvidenceDocuments = lifecycleRows\r\n    .filter((row) => asString(row?.category).toLowerCase().includes(\"onboarding\"))\r\n    .flatMap((row) => toOnboardingEvidenceDocuments(row?.evidence, actorEmail));\r\n\r\n  return mergeEmployeeDocuments([], onboardingEvidenceDocuments).merged;\r\n}\r\n\r\nfunction composeEmployeeName({ firstName, middleName, lastName, suffix, fallback }) {\r\n  return formatEmployeeName({\r\n    firstName: asString(firstName),\r\n    middleName: asString(middleName),\r\n    lastName: asString(lastName),\r\n    suffix: asString(suffix),\r\n    fallback: asString(fallback),\r\n    fallbackLabel: \"Employee\",\r\n  });\r\n}\r\n\r\nfunction normalizeLifecycleType(value) {\r\n  const normalized = String(value || \"\")\r\n    .trim()\r\n    .toLowerCase();\r\n  if (!normalized) {\r\n    return \"onboarding\";\r\n  }\r\n  if (normalized.includes(\"role\") || normalized.includes(\"promotion\")) {\r\n    return \"role-change\";\r\n  }\r\n  if (normalized.includes(\"disciplin\")) {\r\n    return \"disciplinary\";\r\n  }\r\n  if (normalized.includes(\"offboard\") || normalized.includes(\"resign\") || normalized.includes(\"terminate\")) {\r\n    return \"offboarding\";\r\n  }\r\n  if (normalized.includes(\"onboard\")) {\r\n    return \"onboarding\";\r\n  }\r\n  return \"onboarding\";\r\n}\r\n\r\nfunction getLifecycleTemplateByCategory(category) {\r\n  const type = normalizeLifecycleType(category);\r\n  return LIFECYCLE_WORKFLOW_TEMPLATES[type] || LIFECYCLE_WORKFLOW_TEMPLATES.onboarding;\r\n}\r\n\r\nfunction addHoursToIso(isoValue, hours) {\r\n  const timestamp = Number.isFinite(Number(hours)) ? Number(hours) : 0;\r\n  const base = new Date(isoValue || nowIso());\r\n  if (Number.isNaN(base.getTime())) {\r\n    return nowIso();\r\n  }\r\n  base.setTime(base.getTime() + Math.max(0, timestamp) * 60 * 60 * 1000);\r\n  return base.toISOString();\r\n}\r\n\r\nfunction normalizeRoleId(value) {\r\n  return String(value || \"\")\r\n    .trim()\r\n    .toUpperCase()\r\n    .replace(/[^A-Z0-9_]+/g, \"\");\r\n}\r\n\r\nfunction normalizeDecision(value) {\r\n  const normalized = String(value || \"\")\r\n    .trim()\r\n    .toLowerCase();\r\n  if (normalized === \"approve\" || normalized === \"approved\") {\r\n    return \"approved\";\r\n  }\r\n  if (normalized === \"reject\" || normalized === \"rejected\") {\r\n    return \"rejected\";\r\n  }\r\n  return \"\";\r\n}\r\n\r\nfunction buildChecklistFromTemplate(template, { atIso }) {\r\n  return asArray(template?.checklist)\r\n    .slice(0, MAX_LIFECYCLE_CHECKLIST_ITEMS)\r\n    .map((task, index) => {\r\n      const id = asString(task?.id, `task-${index + 1}`);\r\n      const slaHours = Number.parseInt(String(task?.slaHours || \"\"), 10);\r\n      return {\r\n        id,\r\n        label: asString(task?.label, id),\r\n        required: task?.required !== false,\r\n        status: \"Pending\",\r\n        dueAt: addHoursToIso(atIso, Number.isFinite(slaHours) && slaHours > 0 ? slaHours : 24),\r\n        completedAt: \"\",\r\n        completedBy: \"\",\r\n      };\r\n    });\r\n}\r\n\r\nfunction mergeChecklistWithTemplate(baseChecklist, templateChecklist) {\r\n  const existing = new Map();\r\n  asArray(baseChecklist).forEach((task) => {\r\n    const key = asString(task?.id);\r\n    if (key) {\r\n      existing.set(key, task);\r\n    }\r\n  });\r\n\r\n  return templateChecklist.map((task) => {\r\n    const previous = existing.get(task.id);\r\n    if (!previous) {\r\n      return task;\r\n    }\r\n    return {\r\n      ...task,\r\n      status: asString(previous.status, task.status),\r\n      dueAt: asString(previous.dueAt, task.dueAt),\r\n      completedAt: asString(previous.completedAt),\r\n      completedBy: asString(previous.completedBy),\r\n    };\r\n  });\r\n}\r\n\r\nfunction buildApprovalChain(requiredRoles, existingChain) {\r\n  const existingByRole = new Map();\r\n  asArray(existingChain).forEach((entry) => {\r\n    const role = normalizeRoleId(entry?.role);\r\n    if (role) {\r\n      existingByRole.set(role, entry);\r\n    }\r\n  });\r\n\r\n  return requiredRoles.map((role, index) => {\r\n    const previous = existingByRole.get(role);\r\n    return {\r\n      order: index + 1,\r\n      role,\r\n      status: asString(previous?.status, \"Pending\"),\r\n      decidedAt: asString(previous?.decidedAt),\r\n      decidedBy: asString(previous?.decidedBy),\r\n      note: asString(previous?.note),\r\n    };\r\n  });\r\n}\r\n\r\nfunction resolveApprovalState(approvalChain) {\r\n  const chain = asArray(approvalChain);\r\n  if (chain.length === 0) {\r\n    return \"Not Required\";\r\n  }\r\n  if (chain.some((step) => normalizeText(step?.status) === \"rejected\")) {\r\n    return \"Rejected\";\r\n  }\r\n  if (chain.length > 0 && chain.every((step) => normalizeText(step?.status) === \"approved\")) {\r\n    return \"Approved\";\r\n  }\r\n  return \"Pending\";\r\n}\r\n\r\nfunction summarizeChecklistProgress(checklist) {\r\n  const requiredTasks = checklist.filter((task) => task.required !== false);\r\n  const completedRequired = requiredTasks.filter((task) => normalizeText(task.status) === \"completed\").length;\r\n  const totalRequired = requiredTasks.length;\r\n  return {\r\n    completedRequired,\r\n    totalRequired,\r\n    percent: totalRequired === 0 ? 0 : Math.round((completedRequired / totalRequired) * 100),\r\n  };\r\n}\r\n\r\nfunction isLifecycleFinalStatusForEvidence(workflowType, statusValue) {\r\n  const workflow = normalizeText(workflowType);\r\n  const status = normalizeText(statusValue);\r\n  if (!workflow || !status) {\r\n    return false;\r\n  }\r\n\r\n  if (workflow === \"disciplinary\") {\r\n    return status.includes(\"approved\") || status.includes(\"completed\");\r\n  }\r\n\r\n  if (workflow === \"offboarding\") {\r\n    return (\r\n      status.includes(\"approved\") ||\r\n      status.includes(\"completed\") ||\r\n      status.includes(\"access revoked\") ||\r\n      status.includes(\"revoked\") ||\r\n      status.includes(\"resign\") ||\r\n      status.includes(\"terminated\")\r\n    );\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction summarizeLifecycleRequiredEvidence(workflowType, evidenceItems = []) {\r\n  const normalizedWorkflowType = normalizeText(workflowType);\r\n  const requiredRules = asArray(LIFECYCLE_REQUIRED_EVIDENCE_RULES[normalizedWorkflowType]);\r\n  if (requiredRules.length === 0) {\r\n    return {\r\n      required: [],\r\n      matched: [],\r\n      missing: [],\r\n      complete: true,\r\n    };\r\n  }\r\n\r\n  const normalizedEvidence = asArray(evidenceItems).map((entry) => {\r\n    const source = asObject(entry, {});\r\n    return normalizeText([source.name, source.type, source.note].filter(Boolean).join(\" \"));\r\n  });\r\n\r\n  const matched = [];\r\n  const missing = [];\r\n\r\n  requiredRules.forEach((rule) => {\r\n    const keywords = asArray(rule?.keywords).map((item) => normalizeText(item)).filter(Boolean);\r\n    const isMatch = normalizedEvidence.some((evidenceText) => keywords.some((keyword) => evidenceText.includes(keyword)));\r\n    const detail = {\r\n      id: asString(rule?.id),\r\n      label: asString(rule?.label),\r\n    };\r\n    if (isMatch) {\r\n      matched.push(detail);\r\n    } else {\r\n      missing.push(detail);\r\n    }\r\n  });\r\n\r\n  return {\r\n    required: requiredRules.map((rule) => ({\r\n      id: asString(rule?.id),\r\n      label: asString(rule?.label),\r\n    })),\r\n    matched,\r\n    missing,\r\n    complete: missing.length === 0,\r\n  };\r\n}\r\n\r\nfunction sanitizeWorkflowStageIndex(stageIndex, stagesLength) {\r\n  const parsed = Number.parseInt(String(stageIndex ?? \"\"), 10);\r\n  if (!Number.isFinite(parsed)) {\r\n    return 0;\r\n  }\r\n  return Math.max(0, Math.min(parsed, Math.max(0, stagesLength - 1)));\r\n}\r\n\r\nfunction resolveRequiredApproverRoles() {\r\n  return [];\r\n}\r\n\r\nfunction validateLifecycleTargetRolePermission({ actorRole, targetRole }) {\r\n  if (!targetRole) {\r\n    return;\r\n  }\r\n\r\n  const normalizedActorRole = normalizeRoleId(actorRole);\r\n  const normalizedTargetRole = normalizeRoleId(targetRole);\r\n\r\n  if (normalizedActorRole === \"SUPER_ADMIN\") {\r\n    return;\r\n  }\r\n\r\n  if (normalizedActorRole === \"GRC\") {\r\n    if (normalizedTargetRole === \"SUPER_ADMIN\") {\r\n      throw new Error(\"forbidden_target_role\");\r\n    }\r\n    if (!LIFECYCLE_ASSIGNABLE_BY_GRC.has(normalizedTargetRole)) {\r\n      throw new Error(\"invalid_target_role\");\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (normalizedActorRole === \"HR\" || normalizedActorRole === \"EA\") {\r\n    if (!LIFECYCLE_ASSIGNABLE_BY_PRIVILEGED.has(normalizedTargetRole)) {\r\n      throw new Error(\"forbidden_target_role\");\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (LIFECYCLE_PRIVILEGED_TARGET_ROLES.has(normalizedTargetRole)) {\r\n    throw new Error(\"forbidden_target_role\");\r\n  }\r\n\r\n  if (!LIFECYCLE_ASSIGNABLE_BY_PRIVILEGED.has(normalizedTargetRole)) {\r\n    throw new Error(\"invalid_target_role\");\r\n  }\r\n}\r\n\r\nfunction buildInitialLifecycleWorkflow({\r\n  template,\r\n  baseWorkflow,\r\n  requiredApprovers,\r\n  atIso,\r\n  actorEmail,\r\n}) {\r\n  const templateChecklist = buildChecklistFromTemplate(template, { atIso });\r\n  const checklist = mergeChecklistWithTemplate(baseWorkflow?.checklist, templateChecklist);\r\n  const approvalChain = buildApprovalChain(requiredApprovers, baseWorkflow?.approvalChain);\r\n  const stages = asArray(template?.stages).map((stage) => asString(stage)).filter(Boolean);\r\n  const stageIndex = sanitizeWorkflowStageIndex(baseWorkflow?.stageIndex ?? 0, stages.length);\r\n  const stage = asString(stages[stageIndex], \"Initiated\");\r\n  const stageHistory = appendTrail(baseWorkflow?.stageHistory, {\r\n    at: atIso,\r\n    by: actorEmail,\r\n    stage,\r\n  });\r\n  const progress = summarizeChecklistProgress(checklist);\r\n\r\n  return {\r\n    type: asString(template?.type, \"onboarding\"),\r\n    stageIndex,\r\n    stage,\r\n    stages,\r\n    checklist,\r\n    stageHistory,\r\n    approvalChain,\r\n    approvalState: resolveApprovalState(approvalChain),\r\n    progress,\r\n    slaDueAt: asString(baseWorkflow?.slaDueAt, addHoursToIso(atIso, Number.parseInt(String(template?.slaHours || 72), 10))),\r\n    slaBreached: false,\r\n    updatedAt: atIso,\r\n  };\r\n}\r\n\r\nfunction applyLifecycleWorkflowAction({\r\n  workflow,\r\n  evidence,\r\n  action,\r\n  actorEmail,\r\n  atIso,\r\n}) {\r\n  const nextWorkflow = {\r\n    ...workflow,\r\n    checklist: asArray(workflow.checklist).map((task) => ({ ...task })),\r\n    stageHistory: asArray(workflow.stageHistory).map((entry) => ({ ...entry })),\r\n  };\r\n  let nextEvidence = asArray(evidence).map((item) => ({ ...item }));\r\n  const actionType = normalizeText(action?.type);\r\n\r\n  if (!actionType) {\r\n    return {\r\n      workflow: nextWorkflow,\r\n      evidence: nextEvidence,\r\n    };\r\n  }\r\n\r\n  if (actionType === \"toggle-task\") {\r\n    const taskId = asString(action?.taskId);\r\n    if (!taskId) {\r\n      throw new Error(\"invalid_workflow_action\");\r\n    }\r\n\r\n    let matched = false;\r\n    nextWorkflow.checklist = nextWorkflow.checklist.map((task) => {\r\n      if (task.id !== taskId) {\r\n        return task;\r\n      }\r\n      matched = true;\r\n      const completed = Boolean(action?.completed);\r\n      return {\r\n        ...task,\r\n        status: completed ? \"Completed\" : \"Pending\",\r\n        completedAt: completed ? atIso : \"\",\r\n        completedBy: completed ? actorEmail : \"\",\r\n      };\r\n    });\r\n    if (!matched) {\r\n      throw new Error(\"invalid_workflow_action\");\r\n    }\r\n  } else if (actionType === \"set-stage\") {\r\n    const nextIndex = sanitizeWorkflowStageIndex(action?.stageIndex, asArray(nextWorkflow.stages).length);\r\n    const nextStage = asString(nextWorkflow.stages?.[nextIndex], nextWorkflow.stage);\r\n    nextWorkflow.stageIndex = nextIndex;\r\n    nextWorkflow.stage = nextStage;\r\n    nextWorkflow.stageHistory = appendTrail(nextWorkflow.stageHistory, {\r\n      at: atIso,\r\n      by: actorEmail,\r\n      stage: nextStage,\r\n      action: \"stage-update\",\r\n    });\r\n  } else if (actionType === \"add-evidence\") {\r\n    const evidenceEntry = asObject(action?.evidence, null);\r\n    if (!evidenceEntry) {\r\n      throw new Error(\"invalid_workflow_action\");\r\n    }\r\n    const evidenceId = asString(evidenceEntry.id, `evidence-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`);\r\n    nextEvidence = [\r\n      ...nextEvidence,\r\n      {\r\n        id: evidenceId,\r\n        name: asString(evidenceEntry.name, \"Evidence File\"),\r\n        ref: asString(evidenceEntry.ref),\r\n        storagePath: asString(evidenceEntry.storagePath),\r\n        contentType: asString(evidenceEntry.contentType),\r\n        sizeBytes: Number.isFinite(Number(evidenceEntry.sizeBytes)) ? Number(evidenceEntry.sizeBytes) : 0,\r\n        uploadedAt: asString(evidenceEntry.uploadedAt, atIso),\r\n        uploadedBy: asString(evidenceEntry.uploadedBy, actorEmail),\r\n        note: asString(evidenceEntry.note),\r\n      },\r\n    ].slice(-MAX_LIFECYCLE_EVIDENCE_ITEMS);\r\n  } else if (actionType === \"remove-evidence\") {\r\n    const evidenceId = asString(action?.evidenceId);\r\n    if (!evidenceId) {\r\n      throw new Error(\"invalid_workflow_action\");\r\n    }\r\n    nextEvidence = nextEvidence.filter((item) => asString(item?.id) !== evidenceId);\r\n  } else {\r\n    throw new Error(\"invalid_workflow_action\");\r\n  }\r\n\r\n  const progress = summarizeChecklistProgress(nextWorkflow.checklist);\r\n  nextWorkflow.progress = progress;\r\n  nextWorkflow.updatedAt = atIso;\r\n  nextWorkflow.slaBreached =\r\n    Boolean(nextWorkflow.slaDueAt) &&\r\n    new Date(nextWorkflow.slaDueAt).getTime() < new Date(atIso).getTime() &&\r\n    progress.completedRequired < progress.totalRequired;\r\n\r\n  return {\r\n    workflow: nextWorkflow,\r\n    evidence: nextEvidence,\r\n  };\r\n}\r\n\r\nfunction applyApprovalDecision({\r\n  workflow,\r\n  actorRole,\r\n  actorEmail,\r\n  decision,\r\n  note,\r\n  atIso,\r\n}) {\r\n  const normalizedDecision = normalizeDecision(decision);\r\n  if (!normalizedDecision) {\r\n    throw new Error(\"invalid_approval_decision\");\r\n  }\r\n\r\n  const chain = asArray(workflow?.approvalChain).map((step) => ({ ...step }));\r\n  const pendingIndex = chain.findIndex((step) => normalizeText(step?.status) === \"pending\");\r\n  if (pendingIndex < 0) {\r\n    throw new Error(\"no_pending_approval_step\");\r\n  }\r\n\r\n  const actorRoleId = normalizeRoleId(actorRole);\r\n  const expectedRole = normalizeRoleId(chain[pendingIndex]?.role);\r\n  if (!actorRoleId || actorRoleId !== expectedRole) {\r\n    throw new Error(\"approval_not_allowed_for_role\");\r\n  }\r\n\r\n  chain[pendingIndex] = {\r\n    ...chain[pendingIndex],\r\n    status: normalizedDecision === \"approved\" ? \"Approved\" : \"Rejected\",\r\n    decidedAt: atIso,\r\n    decidedBy: actorEmail,\r\n    note: asString(note),\r\n  };\r\n\r\n  if (normalizedDecision === \"rejected\") {\r\n    return {\r\n      workflow: {\r\n        ...workflow,\r\n        approvalChain: chain,\r\n        approvalState: \"Rejected\",\r\n        updatedAt: atIso,\r\n      },\r\n      status: \"Rejected\",\r\n    };\r\n  }\r\n\r\n  const approvalState = resolveApprovalState(chain);\r\n  const nextWorkflow = {\r\n    ...workflow,\r\n    approvalChain: chain,\r\n    approvalState,\r\n    updatedAt: atIso,\r\n  };\r\n\r\n  const nextStatus = approvalState === \"Approved\" ? \"Approved\" : asString(workflow?.status, \"Pending Approval\");\r\n  return {\r\n    workflow: nextWorkflow,\r\n    status: nextStatus,\r\n  };\r\n}\r\n\r\nfunction appendTrail(currentValue, entry) {\r\n  const trail = [...asArray(currentValue), entry];\r\n  if (trail.length <= MAX_AUDIT_TRAIL_ITEMS) {\r\n    return trail;\r\n  }\r\n  return trail.slice(trail.length - MAX_AUDIT_TRAIL_ITEMS);\r\n}\r\n\r\nfunction byRecentUpdated(a, b) {\r\n  return new Date(b.updatedAt || b.createdAt || 0).getTime() - new Date(a.updatedAt || a.createdAt || 0).getTime();\r\n}\r\n\r\nfunction getCollectionName(key) {\r\n  const map = {\r\n    employees: env(\"CLIO_FIRESTORE_EMPLOYEES_COLLECTION\", \"employees\"),\r\n    lifecycle: env(\"CLIO_FIRESTORE_LIFECYCLE_COLLECTION\", \"employment_lifecycle\"),\r\n    attendance: env(\"CLIO_FIRESTORE_ATTENDANCE_COLLECTION\", \"attendance\"),\r\n    leave: env(\"CLIO_FIRESTORE_LEAVE_COLLECTION\", \"leave_requests\"),\r\n    performance: env(\"CLIO_FIRESTORE_PERFORMANCE_COLLECTION\", \"performance_records\"),\r\n    templates: env(\"CLIO_FIRESTORE_TEMPLATES_COLLECTION\", \"document_templates\"),\r\n    exports: env(\"CLIO_FIRESTORE_EXPORTS_COLLECTION\", \"export_requests\"),\r\n    incidents: env(\"CLIO_FIRESTORE_INCIDENTS_COLLECTION\", \"security_incidents\"),\r\n    settingsReference: env(\"CLIO_FIRESTORE_SETTINGS_REFERENCE_COLLECTION\", \"settings_reference_data\"),\r\n  };\r\n  return map[key] || key;\r\n}\r\n\r\nfunction getEmployeeDocumentsSubcollectionName() {\r\n  return env(\"CLIO_FIRESTORE_EMPLOYEE_DOCUMENTS_SUBCOLLECTION\", \"documents\");\r\n}\r\n\r\nfunction getDbOrThrow() {\r\n  if (!isFirestoreEnabled()) {\r\n    throw new Error(\"firestore_not_configured\");\r\n  }\r\n  const db = getFirestoreDb();\r\n  if (!db) {\r\n    throw new Error(\"firestore_not_configured\");\r\n  }\r\n  return db;\r\n}\r\n\r\nasync function listCollectionRecords(collectionName, { filterField, filterValue } = {}) {\r\n  const db = getDbOrThrow();\r\n  const ref = collection(db, collectionName);\r\n  let snapshot;\r\n  if (filterField && typeof filterValue === \"string\" && filterValue.trim()) {\r\n    snapshot = await getDocs(query(ref, where(filterField, \"==\", filterValue.trim())));\r\n  } else {\r\n    snapshot = await getDocs(ref);\r\n  }\r\n\r\n  return snapshot.docs\r\n    .map((item) => ({\r\n      ...item.data(),\r\n      id: item.id,\r\n      recordId: item.id,\r\n    }))\r\n    .sort(byRecentUpdated);\r\n}\r\n\r\nasync function getCollectionRecordById(collectionName, recordId) {\r\n  const db = getDbOrThrow();\r\n  const normalizedId = asString(recordId);\r\n  if (!normalizedId) {\r\n    throw new Error(\"invalid_record_id\");\r\n  }\r\n\r\n  const ref = doc(db, collectionName, normalizedId);\r\n  const snapshot = await getDoc(ref);\r\n  if (!snapshot.exists()) {\r\n    return null;\r\n  }\r\n  return {\r\n    ...snapshot.data(),\r\n    id: snapshot.id,\r\n    recordId: snapshot.id,\r\n  };\r\n}\r\n\r\nasync function createCollectionRecord(collectionName, payload) {\r\n  const db = getDbOrThrow();\r\n  const ref = await addDoc(collection(db, collectionName), payload);\r\n  return {\r\n    ...payload,\r\n    id: ref.id,\r\n    recordId: ref.id,\r\n  };\r\n}\r\n\r\nasync function updateCollectionRecord(collectionName, recordId, payload) {\r\n  const db = getDbOrThrow();\r\n  const normalizedId = asString(recordId);\r\n  if (!normalizedId) {\r\n    throw new Error(\"invalid_record_id\");\r\n  }\r\n\r\n  const ref = doc(db, collectionName, normalizedId);\r\n  const snapshot = await getDoc(ref);\r\n  if (!snapshot.exists()) {\r\n    return null;\r\n  }\r\n\r\n  const current = snapshot.data() || {};\r\n  const next = {\r\n    ...current,\r\n    ...payload,\r\n  };\r\n  await updateDoc(ref, next);\r\n  return {\r\n    ...next,\r\n    id: snapshot.id,\r\n    recordId: snapshot.id,\r\n  };\r\n}\r\n\r\nasync function updateCollectionRecordsByField(collectionName, filterField, filterValue, buildPatch) {\r\n  const db = getDbOrThrow();\r\n  const normalized = asString(filterValue);\r\n  if (!normalized) {\r\n    return 0;\r\n  }\r\n\r\n  const snapshot = await getDocs(\r\n    query(collection(db, collectionName), where(filterField, \"==\", normalized)),\r\n  );\r\n\r\n  let updatedCount = 0;\r\n  for (const recordSnapshot of snapshot.docs) {\r\n    const current = recordSnapshot.data() || {};\r\n    const patch = buildPatch(current, recordSnapshot.id);\r\n    if (!patch || typeof patch !== \"object\" || Object.keys(patch).length === 0) {\r\n      continue;\r\n    }\r\n    await updateDoc(doc(db, collectionName, recordSnapshot.id), patch);\r\n    updatedCount += 1;\r\n  }\r\n\r\n  return updatedCount;\r\n}\r\n\r\nasync function deleteCollectionRecord(collectionName, recordId) {\r\n  const db = getDbOrThrow();\r\n  const normalizedId = asString(recordId);\r\n  if (!normalizedId) {\r\n    throw new Error(\"invalid_record_id\");\r\n  }\r\n\r\n  const ref = doc(db, collectionName, normalizedId);\r\n  const snapshot = await getDoc(ref);\r\n  if (!snapshot.exists()) {\r\n    return null;\r\n  }\r\n\r\n  await deleteDoc(ref);\r\n  return {\r\n    ...snapshot.data(),\r\n    id: snapshot.id,\r\n    recordId: snapshot.id,\r\n  };\r\n}\r\n\r\nfunction toReferenceCatalogItem(raw, kind) {\r\n  const normalizedKind = normalizeReferenceKind(kind || raw?.kind);\r\n  if (!normalizedKind) {\r\n    return null;\r\n  }\r\n\r\n  const valueSource = asString(raw?.value || raw?.label);\r\n  const labelSource = asString(raw?.label || raw?.value);\r\n  const value = valueSource || labelSource;\r\n  const label = labelSource || valueSource;\r\n  const key = normalizeReferenceKey(normalizedKind, value || label);\r\n  if (!value || !label || !key) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    id: asString(raw?.id || raw?.recordId),\r\n    kind: normalizedKind,\r\n    key,\r\n    value,\r\n    label,\r\n    isSystem: Boolean(raw?.isSystem),\r\n    createdAt: asString(raw?.createdAt),\r\n    updatedAt: asString(raw?.updatedAt),\r\n  };\r\n}\r\n\r\nexport async function listSettingsReferenceCatalogBackend() {\r\n  const collectionName = getCollectionName(\"settingsReference\");\r\n  const baseCatalog = buildSystemReferenceCatalog();\r\n  const rows = (await listCollectionRecords(collectionName)).slice(0, MAX_REFERENCE_CATALOG_ITEMS);\r\n\r\n  const roleByKey = new Map(baseCatalog.roles.map((item) => [item.key, item]));\r\n  const departmentByKey = new Map(baseCatalog.departments.map((item) => [item.key, item]));\r\n\r\n  rows.forEach((row) => {\r\n    const item = toReferenceCatalogItem(row);\r\n    if (!item) {\r\n      return;\r\n    }\r\n\r\n    if (item.kind === \"role\") {\r\n      if (!roleByKey.has(item.key)) {\r\n        roleByKey.set(item.key, item);\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (!departmentByKey.has(item.key)) {\r\n      departmentByKey.set(item.key, item);\r\n    }\r\n  });\r\n\r\n  return {\r\n    roles: sortReferenceCatalogItems([...roleByKey.values()]),\r\n    departments: sortReferenceCatalogItems([...departmentByKey.values()]),\r\n  };\r\n}\r\n\r\nexport async function createSettingsReferenceItemBackend({ kind, label }, actorEmail) {\r\n  const normalizedKind = normalizeReferenceKind(kind);\r\n  if (!normalizedKind) {\r\n    throw new Error(\"invalid_reference_kind\");\r\n  }\r\n\r\n  const normalizedLabel = normalizeReferenceLabel(label);\r\n  if (!normalizedLabel || normalizedLabel.length > MAX_REFERENCE_LABEL_LENGTH) {\r\n    throw new Error(\"invalid_reference_label\");\r\n  }\r\n\r\n  const key = normalizeReferenceKey(normalizedKind, normalizedLabel);\r\n  if (!key) {\r\n    throw new Error(\"invalid_reference_label\");\r\n  }\r\n\r\n  const catalog = await listSettingsReferenceCatalogBackend();\r\n  const targetRows = normalizedKind === \"role\" ? catalog.roles : catalog.departments;\r\n  const alreadyExists = targetRows.some((entry) => entry.key === key);\r\n  if (alreadyExists) {\r\n    throw new Error(\"duplicate_reference_value\");\r\n  }\r\n\r\n  const timestamp = nowIso();\r\n  const payload = {\r\n    kind: normalizedKind,\r\n    key,\r\n    value: normalizedLabel,\r\n    label: normalizedLabel,\r\n    isSystem: false,\r\n    createdAt: timestamp,\r\n    createdBy: actorEmail,\r\n    updatedAt: timestamp,\r\n    updatedBy: actorEmail,\r\n  };\r\n\r\n  const created = await createCollectionRecord(getCollectionName(\"settingsReference\"), payload);\r\n  const item = toReferenceCatalogItem(created, normalizedKind);\r\n  if (!item) {\r\n    throw new Error(\"invalid_reference_label\");\r\n  }\r\n  return item;\r\n}\r\n\r\nexport async function deleteSettingsReferenceItemBackend({ kind, recordId }) {\r\n  const normalizedKind = normalizeReferenceKind(kind);\r\n  if (!normalizedKind) {\r\n    throw new Error(\"invalid_reference_kind\");\r\n  }\r\n\r\n  const normalizedRecordId = asString(recordId);\r\n  if (!normalizedRecordId || normalizedRecordId.startsWith(\"system-\")) {\r\n    throw new Error(\"immutable_reference_item\");\r\n  }\r\n\r\n  const current = await getCollectionRecordById(getCollectionName(\"settingsReference\"), normalizedRecordId);\r\n  if (!current) {\r\n    return null;\r\n  }\r\n\r\n  const currentKind = normalizeReferenceKind(current.kind);\r\n  if (!currentKind || currentKind !== normalizedKind || current.isSystem === true) {\r\n    throw new Error(\"immutable_reference_item\");\r\n  }\r\n\r\n  const deleted = await deleteCollectionRecord(getCollectionName(\"settingsReference\"), normalizedRecordId);\r\n  return toReferenceCatalogItem(deleted, normalizedKind);\r\n}\r\n\r\nfunction normalizeEmployeeWritePayload(payload, actorEmail, { base } = {}) {\r\n  const timestamp = nowIso();\r\n  const employeeEmail = normalizeEmail(payload?.email || base?.email);\r\n  if (!employeeEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const baseGovernmentIds = asObject(base?.governmentIds, {});\r\n  const incomingGovernmentIds = asObject(payload?.governmentIds, {});\r\n  const governmentIds = {\r\n    ...baseGovernmentIds,\r\n    ...incomingGovernmentIds,\r\n  };\r\n\r\n  const basePayrollInformation = asObject(base?.payrollInformation, {});\r\n  const incomingPayrollInformation = asObject(payload?.payrollInformation, {});\r\n  const payrollInformation = {\r\n    ...basePayrollInformation,\r\n    ...incomingPayrollInformation,\r\n  };\r\n\r\n  const managerEmail = normalizeEmail(payload?.managerEmail || base?.managerEmail);\r\n  const contact = asString(payload?.contact, asString(base?.contact, \"-\"));\r\n  const address = asString(payload?.address, asString(base?.address, \"-\"));\r\n  const emergencyContact = asString(payload?.emergencyContact, asString(base?.emergencyContact, \"-\"));\r\n  const govId = asString(payload?.govId, asString(base?.govId, \"Masked\"));\r\n  const firstName = asString(payload?.firstName, asString(base?.firstName, \"\"));\r\n  const middleName = asString(payload?.middleName, asString(base?.middleName, \"\"));\r\n  const lastName = asString(payload?.lastName, asString(base?.lastName, \"\"));\r\n  const suffix = asString(payload?.suffix, asString(base?.suffix, \"\"));\r\n  const legacyName = asString(payload?.name, asString(base?.name, employeeEmail));\r\n  const composedName = composeEmployeeName({\r\n    firstName,\r\n    middleName,\r\n    lastName,\r\n    suffix,\r\n    fallback: legacyName || employeeEmail,\r\n  });\r\n\r\n  if (!governmentIds.primaryId) {\r\n    governmentIds.primaryId = govId;\r\n  }\r\n\r\n  const payloadHasDocuments = Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"documents\");\r\n  const payloadDocuments = payloadHasDocuments ? asArray(payload?.documents) : null;\r\n  const baseDocumentsCountRaw = Number(base?.documentsCount);\r\n  const baseDocumentsCount = Number.isFinite(baseDocumentsCountRaw)\r\n    ? Math.max(0, baseDocumentsCountRaw)\r\n    : asArray(base?.documents).length;\r\n  const documentsCount = payloadDocuments ? payloadDocuments.length : baseDocumentsCount;\r\n\r\n  return {\r\n    employeeId: asString(payload?.employeeId, asString(base?.employeeId, `CL-${Date.now().toString().slice(-6)}`)),\r\n    name: composedName,\r\n    firstName,\r\n    middleName,\r\n    lastName,\r\n    suffix,\r\n    email: employeeEmail,\r\n    role: asString(payload?.role, asString(base?.role, \"EMPLOYEE_L1\")),\r\n    department: asString(payload?.department, asString(base?.department, \"-\")),\r\n    jobTitle: asString(payload?.jobTitle, asString(base?.jobTitle, \"-\")),\r\n    managerEmail,\r\n    hireDate: asString(payload?.hireDate, asString(base?.hireDate, \"\")),\r\n    employmentStatus: asString(payload?.employmentStatus, asString(base?.employmentStatus, \"Active Employee\")),\r\n    status: asString(payload?.status, asString(base?.status, \"Active\")),\r\n    governmentIds,\r\n    govId,\r\n    contact,\r\n    address,\r\n    emergencyContact,\r\n    contactInformation: {\r\n      primaryPhone: contact,\r\n      address,\r\n      emergencyContact,\r\n    },\r\n    payrollInformation,\r\n    payrollGroup: asString(payload?.payrollGroup, asString(base?.payrollGroup, \"-\")),\r\n    documentsCount,\r\n    classification: \"Restricted PII\",\r\n    createdAt: asString(base?.createdAt, timestamp),\r\n    createdBy: asString(base?.createdBy, actorEmail),\r\n    updatedAt: timestamp,\r\n    updatedBy: actorEmail,\r\n    activityHistory: appendTrail(base?.activityHistory, {\r\n      at: timestamp,\r\n      by: actorEmail,\r\n      action: base ? \"update\" : \"create\",\r\n    }),\r\n  };\r\n}\r\n\r\nexport async function listEmployeeRecordsBackend({ ownerEmail, includeDocuments = false } = {}) {\r\n  const rows = await listCollectionRecords(getCollectionName(\"employees\"), {\r\n    filterField: ownerEmail ? \"email\" : undefined,\r\n    filterValue: ownerEmail ? normalizeEmail(ownerEmail) : undefined,\r\n  });\r\n  if (!includeDocuments) {\r\n    return rows;\r\n  }\r\n\r\n  const enriched = await Promise.all(\r\n    rows.map(async (record) => {\r\n      const documents = await resolveAndMigrateEmployeeDocuments(record);\r\n      return withEmployeeDocuments(record, documents);\r\n    }),\r\n  );\r\n  return enriched;\r\n}\r\n\r\nexport async function getEmployeeRecordBackend(recordId, { includeDocuments = true } = {}) {\r\n  const record = await getCollectionRecordById(getCollectionName(\"employees\"), recordId);\r\n  if (!record || !includeDocuments) {\r\n    return record;\r\n  }\r\n\r\n  let documents = await resolveAndMigrateEmployeeDocuments(record);\r\n  if (documents.length === 0) {\r\n    const backfilledDocuments = await collectOnboardingEvidenceDocumentsByEmployeeEmail(\r\n      record.email,\r\n      record.updatedBy || record.createdBy,\r\n    );\r\n    if (backfilledDocuments.length > 0) {\r\n      documents = await replaceEmployeeDocumentSubcollectionById(record.id, backfilledDocuments, {\r\n        actorEmail: record.updatedBy || record.createdBy,\r\n      });\r\n      await clearLegacyEmployeeDocumentsField(record.id, {\r\n        documentsCount: documents.length,\r\n      });\r\n    }\r\n  }\r\n  return withEmployeeDocuments(record, documents);\r\n}\r\n\r\nexport async function createEmployeeRecordBackend(payload, actorEmail) {\r\n  const normalized = normalizeEmployeeWritePayload(payload, actorEmail);\r\n  const created = await createCollectionRecord(getCollectionName(\"employees\"), normalized);\r\n  const payloadDocuments = asArray(payload?.documents);\r\n  if (payloadDocuments.length === 0) {\r\n    return withEmployeeDocuments(created, []);\r\n  }\r\n\r\n  const syncedDocuments = await replaceEmployeeDocumentSubcollectionById(created.id, payloadDocuments, {\r\n    actorEmail,\r\n  });\r\n  await clearLegacyEmployeeDocumentsField(created.id, {\r\n    documentsCount: syncedDocuments.length,\r\n  });\r\n  return withEmployeeDocuments(created, syncedDocuments);\r\n}\r\n\r\nexport async function updateEmployeeRecordBackend(recordId, payload, actorEmail) {\r\n  const current = await getEmployeeRecordBackend(recordId, { includeDocuments: true });\r\n  if (!current) {\r\n    return null;\r\n  }\r\n  const payloadHasDocuments = Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"documents\");\r\n  const payloadDocuments = payloadHasDocuments ? asArray(payload?.documents) : null;\r\n  const normalized = normalizeEmployeeWritePayload(payload, actorEmail, { base: current });\r\n  const updated = await updateCollectionRecord(getCollectionName(\"employees\"), recordId, normalized);\r\n  if (!updated) {\r\n    return null;\r\n  }\r\n\r\n  if (payloadDocuments) {\r\n    const syncedDocuments = await replaceEmployeeDocumentSubcollectionById(recordId, payloadDocuments, {\r\n      actorEmail,\r\n    });\r\n    await clearLegacyEmployeeDocumentsField(recordId, {\r\n      documentsCount: syncedDocuments.length,\r\n    });\r\n    return withEmployeeDocuments(updated, syncedDocuments);\r\n  }\r\n\r\n  const documents = await resolveAndMigrateEmployeeDocuments(updated);\r\n  return withEmployeeDocuments(updated, documents);\r\n}\r\n\r\nexport async function deleteEmployeeRecordBackend(recordId) {\r\n  await deleteEmployeeDocumentSubcollectionById(recordId);\r\n  return await deleteCollectionRecord(getCollectionName(\"employees\"), recordId);\r\n}\r\n\r\nfunction normalizeLifecyclePayload(payload, actorEmail, actorRole, { base } = {}) {\r\n  const timestamp = nowIso();\r\n  const category = asString(payload?.category, asString(base?.category, \"Onboarding\"));\r\n  const employeeEmail = normalizeEmail(payload?.employeeEmail || base?.employeeEmail);\r\n  if (!employeeEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const baseDetails = asObject(base?.details, {});\r\n  const incomingDetails = asObject(payload?.details, {});\r\n  const details = {\r\n    ...baseDetails,\r\n    ...incomingDetails,\r\n  };\r\n\r\n  const template = getLifecycleTemplateByCategory(category);\r\n  const requiredApprovers = resolveRequiredApproverRoles(template, details);\r\n  const baseWorkflow = asObject(base?.workflow, {});\r\n  const workflowPatch = asObject(payload?.workflow, {});\r\n  const workflowSeed = {\r\n    ...baseWorkflow,\r\n    ...workflowPatch,\r\n  };\r\n\r\n  const workflow = buildInitialLifecycleWorkflow({\r\n    template,\r\n    baseWorkflow: workflowSeed,\r\n    requiredApprovers,\r\n    atIso: timestamp,\r\n    actorEmail,\r\n  });\r\n\r\n  const action = payload?.workflowAction && typeof payload.workflowAction === \"object\" ? payload.workflowAction : null;\r\n  const withAction = applyLifecycleWorkflowAction({\r\n    workflow,\r\n    evidence: asArray(base?.evidence),\r\n    action,\r\n    actorEmail,\r\n    atIso: timestamp,\r\n  });\r\n\r\n  const progress = summarizeChecklistProgress(withAction.workflow.checklist);\r\n  withAction.workflow.progress = progress;\r\n  withAction.workflow.slaBreached =\r\n    Boolean(withAction.workflow.slaDueAt) &&\r\n    new Date(withAction.workflow.slaDueAt).getTime() < new Date(timestamp).getTime() &&\r\n    progress.completedRequired < progress.totalRequired;\r\n  withAction.workflow.approvalState = resolveApprovalState(withAction.workflow.approvalChain);\r\n\r\n  const requestedStatus = asString(payload?.status, asString(base?.status, \"In Progress\"));\r\n  const status = requestedStatus;\r\n  const workflowType = asString(template.type, \"onboarding\");\r\n  const workflowActionType = normalizeText(action?.type);\r\n  const requiredEvidence = summarizeLifecycleRequiredEvidence(workflowType, withAction.evidence);\r\n  const mustEnforceRequiredEvidence = isLifecycleFinalStatusForEvidence(workflowType, status);\r\n  if (mustEnforceRequiredEvidence && requiredEvidence.missing.length > 0 && workflowActionType !== \"add-evidence\") {\r\n    throw new Error(\"lifecycle_required_evidence_missing\");\r\n  }\r\n\r\n  return {\r\n    employeeEmail,\r\n    employee: asString(payload?.employee, asString(base?.employee, employeeEmail || \"Unknown Employee\")),\r\n    category,\r\n    workflowType,\r\n    owner: asString(payload?.owner, asString(base?.owner, \"HR Operations\")),\r\n    details,\r\n    evidence: withAction.evidence,\r\n    requiredEvidence,\r\n    workflow: withAction.workflow,\r\n    status,\r\n    createdAt: asString(base?.createdAt, timestamp),\r\n    createdBy: asString(base?.createdBy, actorEmail),\r\n    updatedAt: timestamp,\r\n    updatedBy: actorEmail,\r\n    traceability: appendTrail(base?.traceability, {\r\n      at: timestamp,\r\n      by: actorEmail,\r\n      action: base ? \"update\" : \"create\",\r\n      category,\r\n      status,\r\n      stage: withAction.workflow.stage,\r\n      checklistProgress: withAction.workflow.progress.percent,\r\n      approvalState: withAction.workflow.approvalState,\r\n    }),\r\n  };\r\n}\r\n\r\nfunction shouldTriggerAccessRevocation(record) {\r\n  const category = asString(record?.category).toLowerCase();\r\n  const status = asString(record?.status).toLowerCase();\r\n  return (\r\n    category.includes(\"offboarding\") ||\r\n    status.includes(\"resign\") ||\r\n    status.includes(\"terminated\") ||\r\n    status.includes(\"access revoked\")\r\n  );\r\n}\r\n\r\nfunction shouldApplyLifecycleRoleSync(record) {\r\n  const category = asString(record?.category).toLowerCase();\r\n  const status = asString(record?.status).toLowerCase();\r\n  const isRoleMovement = category.includes(\"role change\") || category.includes(\"promotion\");\r\n  const isFinalized = status.includes(\"approved\") || status.includes(\"completed\");\r\n  return isRoleMovement && isFinalized;\r\n}\r\n\r\nfunction shouldApplyLifecycleArchivePolicy(record) {\r\n  const category = asString(record?.category).toLowerCase();\r\n  const status = asString(record?.status).toLowerCase();\r\n  const exitStatusDetected =\r\n    status.includes(\"resign\") || status.includes(\"terminated\") || status.includes(\"access revoked\");\r\n  const finalizedOffboarding =\r\n    category.includes(\"offboarding\") &&\r\n    (status.includes(\"approved\") || status.includes(\"completed\") || status.includes(\"revoked\"));\r\n  return exitStatusDetected || finalizedOffboarding;\r\n}\r\n\r\nfunction shouldApplyOnboardingActivation(record) {\r\n  const category = asString(record?.category).toLowerCase();\r\n  const status = asString(record?.status).toLowerCase();\r\n  const hasEmployeeEmail = Boolean(normalizeEmail(record?.employeeEmail));\r\n  const isOnboarding = category.includes(\"onboarding\");\r\n  const isFinalized = status.includes(\"approved\") || status.includes(\"completed\");\r\n  return hasEmployeeEmail && isOnboarding && isFinalized;\r\n}\r\n\r\nfunction shouldTriggerOnboardingInvite(record) {\r\n  const category = asString(record?.category).toLowerCase();\r\n  const hasEmployeeEmail = Boolean(normalizeEmail(record?.employeeEmail));\r\n  return hasEmployeeEmail && category.includes(\"onboarding\");\r\n}\r\n\r\nfunction resolveLifecycleInviteRole(record) {\r\n  const details = asObject(record?.details, {});\r\n  const roleRaw = asString(details?.roleTo || details?.role || details?.roleFrom);\r\n  if (!roleRaw) {\r\n    return \"EMPLOYEE_L1\";\r\n  }\r\n  const normalized = normalizeRoleKey(roleRaw);\r\n  if (!normalized) {\r\n    return \"EMPLOYEE_L1\";\r\n  }\r\n  return LIFECYCLE_ROLE_ALIAS.get(normalized) || normalized || \"EMPLOYEE_L1\";\r\n}\r\n\r\nasync function triggerOnboardingInvite(record, actorEmail, actorRole, { requestOrigin = \"\" } = {}) {\r\n  const normalizedEmail = normalizeEmail(record?.employeeEmail);\r\n  if (!normalizedEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const existingAccount = await getLoginAccount(normalizedEmail).catch(() => null);\r\n  const existingStatus = asString(existingAccount?.status).toLowerCase();\r\n  if (existingStatus === \"active\") {\r\n    return {\r\n      type: \"onboarding-invite-skipped\",\r\n      message: \"User account is already active. Invite was not reissued.\",\r\n      accountStatus: \"active\",\r\n    };\r\n  }\r\n\r\n  const inviteRole = resolveLifecycleInviteRole(record);\r\n  validateLifecycleTargetRolePermission({\r\n    actorRole,\r\n    targetRole: inviteRole,\r\n  });\r\n  const result = await inviteUserAccount({\r\n    email: normalizedEmail,\r\n    role: inviteRole,\r\n    invitedBy: actorEmail,\r\n  });\r\n\r\n  const enforceDelivery = isInviteDeliveryRequired();\r\n  let delivery = null;\r\n  try {\r\n    delivery = await deliverInviteEmail({\r\n      toEmail: result.user.email,\r\n      role: result.user.role,\r\n      invitedBy: actorEmail,\r\n      expiresAt: result.invite.expiresAt,\r\n      inviteToken: result.invite.token,\r\n      requestOrigin,\r\n    });\r\n  } catch (deliveryError) {\r\n    const rawReason = deliveryError instanceof Error ? deliveryError.message : \"email_delivery_failed\";\r\n    const deliveryErrorInfo = extractDeliveryErrorInfo(rawReason);\r\n    if (enforceDelivery) {\r\n      await revokeInviteById(result.invite.id).catch(() => null);\r\n      throw new Error(deliveryErrorInfo.code || \"email_delivery_failed\");\r\n    }\r\n\r\n    delivery = {\r\n      provider: \"unavailable\",\r\n      status: \"failed\",\r\n      messageId: null,\r\n      reason: deliveryErrorInfo.code || \"email_delivery_failed\",\r\n      providerMessage: deliveryErrorInfo.providerMessage || null,\r\n    };\r\n  }\r\n\r\n  return {\r\n    type: \"onboarding-invite\",\r\n    message:\r\n      delivery?.status === \"failed\"\r\n        ? \"Onboarding invite was created. Email delivery failed in test mode.\"\r\n        : delivery?.provider === \"firebase\"\r\n          ? \"Onboarding invite sent via Firebase email-link template. User must verify email to open the CLIO account, then complete SMS OTP.\"\r\n          : \"Onboarding invite sent. User must verify email to open the CLIO account, then complete SMS OTP.\",\r\n    inviteId: result.invite.id,\r\n    inviteStatus: result.invite.status,\r\n    role: result.user.role,\r\n    deliveryProvider: delivery?.provider || \"unknown\",\r\n    deliveryStatus: delivery?.status || \"unknown\",\r\n  };\r\n}\r\n\r\nfunction resolveLifecycleRoleTarget(record) {\r\n  const details = asObject(record?.details, {});\r\n  const roleToRaw = asString(details?.roleTo);\r\n  if (!roleToRaw) {\r\n    return \"\";\r\n  }\r\n\r\n  const normalized = normalizeRoleKey(roleToRaw);\r\n  return LIFECYCLE_ROLE_ALIAS.get(normalized) || \"\";\r\n}\r\n\r\nfunction resolveArchiveReasonFromLifecycle(record) {\r\n  const details = asObject(record?.details, {});\r\n  const detailReason = asString(details?.offboardingReason || details?.reason || details?.note);\r\n  if (detailReason) {\r\n    return detailReason;\r\n  }\r\n\r\n  const category = asString(record?.category);\r\n  const status = asString(record?.status);\r\n  if (category || status) {\r\n    return [category, status].filter(Boolean).join(\" - \");\r\n  }\r\n\r\n  return \"Resigned\";\r\n}\r\n\r\nfunction buildArchivePatch(current, { actorEmail, archivedAt, reason, retentionDeleteAt, trailField }) {\r\n  const patch = {\r\n    isArchived: true,\r\n    archivedAt,\r\n    archivedBy: actorEmail,\r\n    archiveReason: reason,\r\n    retentionDeleteAt,\r\n    updatedAt: archivedAt,\r\n    updatedBy: actorEmail,\r\n  };\r\n\r\n  if (trailField) {\r\n    patch[trailField] = appendTrail(current?.[trailField], {\r\n      at: archivedAt,\r\n      by: actorEmail,\r\n      action: \"archive\",\r\n      reason,\r\n    });\r\n  }\r\n\r\n  return patch;\r\n}\r\n\r\nasync function syncUserRoleByLifecycle(record, actorRole) {\r\n  const normalizedEmail = normalizeEmail(record?.employeeEmail);\r\n  if (!normalizedEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const targetRole = resolveLifecycleRoleTarget(record);\r\n  if (!targetRole) {\r\n    throw new Error(\"invalid_target_role\");\r\n  }\r\n  validateLifecycleTargetRolePermission({\r\n    actorRole,\r\n    targetRole,\r\n  });\r\n\r\n  const updated = await updateUserAccountRole({\r\n    userId: normalizedEmail,\r\n    role: targetRole,\r\n  });\r\n  if (!updated) {\r\n    throw new Error(\"role_sync_failed\");\r\n  }\r\n\r\n  return updated;\r\n}\r\n\r\nasync function syncEmployeeRecordRoleByLifecycle(record, actorEmail, actorRole) {\r\n  const normalizedEmail = normalizeEmail(record?.employeeEmail);\r\n  if (!normalizedEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const targetRole = resolveLifecycleRoleTarget(record);\r\n  if (!targetRole) {\r\n    throw new Error(\"invalid_target_role\");\r\n  }\r\n  validateLifecycleTargetRolePermission({\r\n    actorRole,\r\n    targetRole,\r\n  });\r\n\r\n  const details = asObject(record?.details, {});\r\n  const nextDepartment = asString(details?.departmentTo);\r\n  const updatedAt = nowIso();\r\n  const updatedCount = await updateCollectionRecordsByField(\r\n    getCollectionName(\"employees\"),\r\n    \"email\",\r\n    normalizedEmail,\r\n    (current) => {\r\n      const patch = {\r\n        role: targetRole,\r\n        updatedAt,\r\n        updatedBy: actorEmail,\r\n        activityHistory: appendTrail(current?.activityHistory, {\r\n          at: updatedAt,\r\n          by: actorEmail,\r\n          action: \"lifecycle-role-sync\",\r\n          role: targetRole,\r\n        }),\r\n      };\r\n      if (nextDepartment) {\r\n        patch.department = nextDepartment;\r\n      }\r\n      return patch;\r\n    },\r\n  );\r\n\r\n  return updatedCount;\r\n}\r\n\r\nasync function revokeUserAccessByEmail(email) {\r\n  const normalizedEmail = normalizeEmail(email);\r\n  if (!normalizedEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const updated = await updateUserAccountStatus({\r\n    userId: normalizedEmail,\r\n    status: \"disabled\",\r\n  });\r\n  if (!updated) {\r\n    throw new Error(\"employee_account_not_found\");\r\n  }\r\n  if (asString(updated.status).toLowerCase() !== \"disabled\") {\r\n    throw new Error(\"access_revocation_failed\");\r\n  }\r\n  return updated;\r\n}\r\n\r\nasync function activateUserAccessByEmail(email) {\r\n  const normalizedEmail = normalizeEmail(email);\r\n  if (!normalizedEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const updated = await updateUserAccountStatus({\r\n    userId: normalizedEmail,\r\n    status: \"active\",\r\n  });\r\n  if (!updated) {\r\n    throw new Error(\"employee_account_not_found\");\r\n  }\r\n  if (asString(updated.status).toLowerCase() !== \"active\") {\r\n    throw new Error(\"account_activation_failed\");\r\n  }\r\n  return updated;\r\n}\r\n\r\nasync function activateEmployeeRecordByEmail(record, actorEmail) {\r\n  const normalizedEmail = normalizeEmail(record?.employeeEmail);\r\n  if (!normalizedEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const details = asObject(record?.details, {});\r\n  const employeeId = asString(details?.employeeId || details?.employeeNumber);\r\n  const firstName = asString(details?.firstName);\r\n  const middleName = asString(details?.middleName);\r\n  const lastName = asString(details?.lastName);\r\n  const suffix = asString(details?.suffix);\r\n  const startDate = asString(details?.startDate);\r\n  const roleRaw = asString(details?.roleTo || details?.role || details?.roleFrom);\r\n  const roleNormalized = normalizeRoleKey(roleRaw);\r\n  const roleValue = LIFECYCLE_ROLE_ALIAS.get(roleNormalized) || roleNormalized || \"EMPLOYEE_L1\";\r\n  const departmentValue = asString(details?.departmentTo || details?.department);\r\n  const displayName = composeEmployeeName({\r\n    firstName,\r\n    middleName,\r\n    lastName,\r\n    suffix,\r\n    fallback: asString(record?.employee, normalizedEmail),\r\n  });\r\n  const updatedAt = nowIso();\r\n  const updatedCount = await updateCollectionRecordsByField(getCollectionName(\"employees\"), \"email\", normalizedEmail, (current) => {\r\n    const patch = {\r\n      status: \"Active\",\r\n      employmentStatus: \"Active Employee\",\r\n      isArchived: false,\r\n      updatedAt,\r\n      updatedBy: actorEmail,\r\n      activityHistory: appendTrail(current?.activityHistory, {\r\n        at: updatedAt,\r\n        by: actorEmail,\r\n        action: \"lifecycle-onboarding-sync\",\r\n        status: \"Active\",\r\n      }),\r\n    };\r\n    if (employeeId) {\r\n      patch.employeeId = employeeId;\r\n    }\r\n    if (firstName) {\r\n      patch.firstName = firstName;\r\n    }\r\n    if (middleName) {\r\n      patch.middleName = middleName;\r\n    }\r\n    if (lastName) {\r\n      patch.lastName = lastName;\r\n    }\r\n    if (suffix) {\r\n      patch.suffix = suffix;\r\n    }\r\n    if (displayName) {\r\n      patch.name = displayName;\r\n    }\r\n    if (departmentValue) {\r\n      patch.department = departmentValue;\r\n    }\r\n    if (roleValue) {\r\n      patch.role = roleValue;\r\n    }\r\n    if (startDate) {\r\n      patch.hireDate = startDate;\r\n    }\r\n    return patch;\r\n  });\r\n\r\n  if (updatedCount > 0) {\r\n    return updatedCount;\r\n  }\r\n\r\n  const createdPayload = normalizeEmployeeWritePayload(\r\n    {\r\n      employeeId,\r\n      email: normalizedEmail,\r\n      name: displayName,\r\n      firstName,\r\n      middleName,\r\n      lastName,\r\n      suffix,\r\n      role: roleValue || \"EMPLOYEE_L1\",\r\n      department: departmentValue || \"-\",\r\n      hireDate: startDate || \"\",\r\n      status: \"Active\",\r\n      employmentStatus: \"Active Employee\",\r\n    },\r\n    actorEmail,\r\n  );\r\n  await createCollectionRecord(getCollectionName(\"employees\"), createdPayload);\r\n  return 1;\r\n}\r\n\r\nasync function archiveEmployeeDataByEmail(record, actorEmail) {\r\n  const normalizedEmail = normalizeEmail(record?.employeeEmail);\r\n  if (!normalizedEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const archivedAt = nowIso();\r\n  const retentionDeleteAt = addYearsToIso(archivedAt, getArchiveRetentionYears());\r\n  const reason = resolveArchiveReasonFromLifecycle(record);\r\n\r\n  const userArchive = await archiveUserAccount({\r\n    userId: normalizedEmail,\r\n    archivedBy: actorEmail,\r\n    reason,\r\n    retentionDeleteAt,\r\n  });\r\n\r\n  const employeesArchived = await updateCollectionRecordsByField(getCollectionName(\"employees\"), \"email\", normalizedEmail, (current) => ({\r\n    ...buildArchivePatch(current, {\r\n      actorEmail,\r\n      archivedAt,\r\n      reason,\r\n      retentionDeleteAt,\r\n      trailField: \"activityHistory\",\r\n    }),\r\n    status: \"Archived\",\r\n    employmentStatus: \"Resigned\",\r\n  }));\r\n\r\n  const lifecycleArchived = await updateCollectionRecordsByField(getCollectionName(\"lifecycle\"), \"employeeEmail\", normalizedEmail, (current) => ({\r\n    ...buildArchivePatch(current, {\r\n      actorEmail,\r\n      archivedAt,\r\n      reason,\r\n      retentionDeleteAt,\r\n      trailField: \"traceability\",\r\n    }),\r\n    archiveStatus: \"Archived\",\r\n  }));\r\n\r\n  const attendanceArchived = await updateCollectionRecordsByField(getCollectionName(\"attendance\"), \"employeeEmail\", normalizedEmail, (current) => ({\r\n    ...buildArchivePatch(current, {\r\n      actorEmail,\r\n      archivedAt,\r\n      reason,\r\n      retentionDeleteAt,\r\n      trailField: \"modificationTrail\",\r\n    }),\r\n    archiveStatus: \"Archived\",\r\n  }));\r\n\r\n  const leaveArchived = await updateCollectionRecordsByField(getCollectionName(\"leave\"), \"employeeEmail\", normalizedEmail, (current) => ({\r\n    ...buildArchivePatch(current, {\r\n      actorEmail,\r\n      archivedAt,\r\n      reason,\r\n      retentionDeleteAt,\r\n      trailField: \"modificationTrail\",\r\n    }),\r\n    archiveStatus: \"Archived\",\r\n  }));\r\n\r\n  const performanceArchived = await updateCollectionRecordsByField(getCollectionName(\"performance\"), \"employeeEmail\", normalizedEmail, (current) => ({\r\n    ...buildArchivePatch(current, {\r\n      actorEmail,\r\n      archivedAt,\r\n      reason,\r\n      retentionDeleteAt,\r\n      trailField: \"traceability\",\r\n    }),\r\n    archiveStatus: \"Archived\",\r\n  }));\r\n\r\n  const exportsArchived = await updateCollectionRecordsByField(getCollectionName(\"exports\"), \"requestedBy\", normalizedEmail, (current) => ({\r\n    ...buildArchivePatch(current, {\r\n      actorEmail,\r\n      archivedAt,\r\n      reason,\r\n      retentionDeleteAt,\r\n      trailField: \"history\",\r\n    }),\r\n    archiveStatus: \"Archived\",\r\n  }));\r\n\r\n  return {\r\n    archivedAt,\r\n    retentionDeleteAt,\r\n    reason,\r\n    userStatus: userArchive?.status || \"disabled\",\r\n    counts: {\r\n      employees: employeesArchived,\r\n      lifecycle: lifecycleArchived,\r\n      attendance: attendanceArchived,\r\n      leave: leaveArchived,\r\n      performance: performanceArchived,\r\n      exports: exportsArchived,\r\n    },\r\n  };\r\n}\r\n\r\nasync function applyLifecycleAutomations(record, actorEmail, actorRole) {\r\n  const effects = [];\r\n  if (shouldApplyOnboardingActivation(record)) {\r\n    const activatedAccount = await activateUserAccessByEmail(record.employeeEmail);\r\n    const activatedEmployeeRecords = await activateEmployeeRecordByEmail(record, actorEmail);\r\n    effects.push({\r\n      type: \"onboarding-activation\",\r\n      message: \"User account and employee profile activated.\",\r\n      accountStatus: activatedAccount?.status || \"active\",\r\n      employeeRecordsUpdated: activatedEmployeeRecords,\r\n    });\r\n  }\r\n  if (shouldApplyLifecycleRoleSync(record)) {\r\n    const employeeRecordsUpdated = await syncEmployeeRecordRoleByLifecycle(record, actorEmail, actorRole);\r\n    const account = await syncUserRoleByLifecycle(record, actorRole);\r\n    effects.push({\r\n      type: \"role-sync\",\r\n      message: `Role synchronized to ${account?.role || \"target role\"}.`,\r\n      role: account?.role || null,\r\n      employeeRecordsUpdated,\r\n    });\r\n  }\r\n  if (shouldTriggerAccessRevocation(record)) {\r\n    const account = await revokeUserAccessByEmail(record.employeeEmail);\r\n    effects.push({\r\n      type: \"access-revocation\",\r\n      message: \"User account access revoked.\",\r\n      accountStatus: account?.status || \"disabled\",\r\n    });\r\n  }\r\n  if (shouldApplyLifecycleArchivePolicy(record)) {\r\n    const archiveResult = await archiveEmployeeDataByEmail(record, actorEmail);\r\n    effects.push({\r\n      type: \"archive-policy\",\r\n      message: `Employee data archived until ${archiveResult.retentionDeleteAt}.`,\r\n      retentionDeleteAt: archiveResult.retentionDeleteAt,\r\n      archivedAt: archiveResult.archivedAt,\r\n      counts: archiveResult.counts,\r\n    });\r\n  }\r\n  return effects;\r\n}\r\n\r\nexport async function listLifecycleRecordsBackend() {\r\n  return await listCollectionRecords(getCollectionName(\"lifecycle\"));\r\n}\r\n\r\nexport async function getLifecycleRecordBackend(recordId) {\r\n  return await getCollectionRecordById(getCollectionName(\"lifecycle\"), recordId);\r\n}\r\n\r\nexport async function createLifecycleRecordBackend(payload, actorEmail, actorRole = \"\", { requestOrigin = \"\" } = {}) {\r\n  const normalized = normalizeLifecyclePayload(payload, actorEmail, actorRole);\r\n  const effects = [];\r\n  if (shouldTriggerOnboardingInvite(normalized)) {\r\n    const inviteEffect = await triggerOnboardingInvite(normalized, actorEmail, actorRole, {\r\n      requestOrigin,\r\n    });\r\n    if (inviteEffect) {\r\n      effects.push(inviteEffect);\r\n    }\r\n  }\r\n  const automationEffects = await applyLifecycleAutomations(normalized, actorEmail, actorRole);\r\n  effects.push(...automationEffects);\r\n\r\n  const created = await createCollectionRecord(getCollectionName(\"lifecycle\"), {\r\n    ...normalized,\r\n    lastAutomationEffects: effects,\r\n    lastAutomationAt: nowIso(),\r\n    lastAutomationBy: actorEmail,\r\n  });\r\n\r\n  await syncOnboardingEvidenceToEmployeeDocuments(created, actorEmail).catch(() => null);\r\n\r\n  return {\r\n    record: created,\r\n    effects,\r\n  };\r\n}\r\n\r\nexport async function updateLifecycleRecordBackend(recordId, payload, actorEmail, actorRole = \"\") {\r\n  const current = await getLifecycleRecordBackend(recordId);\r\n  if (!current) {\r\n    return null;\r\n  }\r\n  const normalized = normalizeLifecyclePayload(payload, actorEmail, actorRole, { base: current });\r\n  const effects = await applyLifecycleAutomations(normalized, actorEmail, actorRole);\r\n\r\n  const updated = await updateCollectionRecord(getCollectionName(\"lifecycle\"), recordId, {\r\n    ...normalized,\r\n    lastAutomationEffects: effects,\r\n    lastAutomationAt: nowIso(),\r\n    lastAutomationBy: actorEmail,\r\n  });\r\n\r\n  await syncOnboardingEvidenceToEmployeeDocuments(updated, actorEmail).catch(() => null);\r\n\r\n  return {\r\n    record: updated,\r\n    effects,\r\n  };\r\n}\r\n\r\nexport async function forceOffboardLifecycleRecordBackend(recordId, actorEmail, reason, actorRole = \"\") {\r\n  return await updateLifecycleRecordBackend(\r\n    recordId,\r\n    {\r\n      category: \"Offboarding\",\r\n      status: \"Access Revoked\",\r\n      details: {\r\n        offboardingReason: asString(reason, \"Resignation\"),\r\n      },\r\n    },\r\n    actorEmail,\r\n    actorRole,\r\n  );\r\n}\r\n\r\nexport async function approveLifecycleRecordBackend(\r\n  recordId,\r\n  { decision, note } = {},\r\n  actorEmail,\r\n  actorRole = \"\",\r\n) {\r\n  const current = await getLifecycleRecordBackend(recordId);\r\n  if (!current) {\r\n    return null;\r\n  }\r\n\r\n  const timestamp = nowIso();\r\n  const baseWorkflow = asObject(current.workflow, {});\r\n  const approvalResult = applyApprovalDecision({\r\n    workflow: baseWorkflow,\r\n    actorRole,\r\n    actorEmail,\r\n    decision,\r\n    note,\r\n    atIso: timestamp,\r\n  });\r\n\r\n  const normalized = normalizeLifecyclePayload(\r\n    {\r\n      status: approvalResult.status,\r\n      workflow: approvalResult.workflow,\r\n    },\r\n    actorEmail,\r\n    actorRole,\r\n    { base: current },\r\n  );\r\n\r\n  const effects = await applyLifecycleAutomations(normalized, actorEmail, actorRole);\r\n  const updated = await updateCollectionRecord(getCollectionName(\"lifecycle\"), recordId, {\r\n    ...normalized,\r\n    lastAutomationEffects: effects,\r\n    lastAutomationAt: nowIso(),\r\n    lastAutomationBy: actorEmail,\r\n  });\r\n\r\n  await syncOnboardingEvidenceToEmployeeDocuments(updated, actorEmail).catch(() => null);\r\n\r\n  return {\r\n    record: updated,\r\n    effects,\r\n  };\r\n}\r\n\r\nfunction normalizeAttendancePayload(payload, actorEmail, { base } = {}) {\r\n  const timestamp = nowIso();\r\n  const employeeEmail = normalizeEmail(payload?.employeeEmail || base?.employeeEmail);\r\n  if (!employeeEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const next = {\r\n    employeeEmail,\r\n    employee: asString(payload?.employee, asString(base?.employee, employeeEmail)),\r\n    date: asString(payload?.date, asString(base?.date, timestamp.slice(0, 10))),\r\n    checkIn: asString(payload?.checkIn, asString(base?.checkIn, \"-\")),\r\n    checkOut: asString(payload?.checkOut, asString(base?.checkOut, \"-\")),\r\n    status: asString(payload?.status, asString(base?.status, \"Recorded\")),\r\n    reason: asString(payload?.reason, asString(base?.reason, \"\")),\r\n    createdAt: asString(base?.createdAt, timestamp),\r\n    createdBy: asString(base?.createdBy, actorEmail),\r\n    updatedAt: timestamp,\r\n    updatedBy: actorEmail,\r\n  };\r\n\r\n  next.modificationTrail = appendTrail(base?.modificationTrail, {\r\n    at: timestamp,\r\n    by: actorEmail,\r\n    action: base ? \"update\" : \"create\",\r\n    status: next.status,\r\n    checkIn: next.checkIn,\r\n    checkOut: next.checkOut,\r\n    reason: next.reason,\r\n  });\r\n\r\n  return next;\r\n}\r\n\r\nfunction normalizeLeavePayload(payload, actorEmail, { base } = {}) {\r\n  const timestamp = nowIso();\r\n  const employeeEmail = normalizeEmail(payload?.employeeEmail || base?.employeeEmail);\r\n  if (!employeeEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  const status = asString(payload?.status, asString(base?.status, \"Pending\"));\r\n  const next = {\r\n    employeeEmail,\r\n    employee: asString(payload?.employee, asString(base?.employee, employeeEmail)),\r\n    leaveType: asString(payload?.leaveType, asString(base?.leaveType, \"Leave\")),\r\n    startDate: asString(payload?.startDate, asString(base?.startDate, \"\")),\r\n    endDate: asString(payload?.endDate, asString(base?.endDate, \"\")),\r\n    reason: asString(payload?.reason, asString(base?.reason, \"\")),\r\n    status,\r\n    approver: asString(payload?.approver, asString(base?.approver, \"\")),\r\n    approvalNote: asString(payload?.approvalNote, asString(base?.approvalNote, \"\")),\r\n    createdAt: asString(base?.createdAt, timestamp),\r\n    createdBy: asString(base?.createdBy, actorEmail),\r\n    updatedAt: timestamp,\r\n    updatedBy: actorEmail,\r\n  };\r\n\r\n  next.modificationTrail = appendTrail(base?.modificationTrail, {\r\n    at: timestamp,\r\n    by: actorEmail,\r\n    action: base ? \"update\" : \"create\",\r\n    status,\r\n    leaveType: next.leaveType,\r\n  });\r\n\r\n  return next;\r\n}\r\n\r\nexport async function listAttendanceLogsBackend({ ownerEmail } = {}) {\r\n  return await listCollectionRecords(getCollectionName(\"attendance\"), {\r\n    filterField: ownerEmail ? \"employeeEmail\" : undefined,\r\n    filterValue: ownerEmail ? normalizeEmail(ownerEmail) : undefined,\r\n  });\r\n}\r\n\r\nexport async function getAttendanceLogBackend(recordId) {\r\n  return await getCollectionRecordById(getCollectionName(\"attendance\"), recordId);\r\n}\r\n\r\nexport async function createAttendanceLogBackend(payload, actorEmail) {\r\n  const normalized = normalizeAttendancePayload(payload, actorEmail);\r\n  return await createCollectionRecord(getCollectionName(\"attendance\"), normalized);\r\n}\r\n\r\nexport async function updateAttendanceLogBackend(recordId, payload, actorEmail) {\r\n  const current = await getAttendanceLogBackend(recordId);\r\n  if (!current) {\r\n    return null;\r\n  }\r\n  const normalized = normalizeAttendancePayload(payload, actorEmail, { base: current });\r\n  return await updateCollectionRecord(getCollectionName(\"attendance\"), recordId, normalized);\r\n}\r\n\r\nexport async function listLeaveRequestsBackend({ ownerEmail } = {}) {\r\n  return await listCollectionRecords(getCollectionName(\"leave\"), {\r\n    filterField: ownerEmail ? \"employeeEmail\" : undefined,\r\n    filterValue: ownerEmail ? normalizeEmail(ownerEmail) : undefined,\r\n  });\r\n}\r\n\r\nexport async function getLeaveRequestBackend(recordId) {\r\n  return await getCollectionRecordById(getCollectionName(\"leave\"), recordId);\r\n}\r\n\r\nexport async function createLeaveRequestBackend(payload, actorEmail) {\r\n  const normalized = normalizeLeavePayload(payload, actorEmail);\r\n  return await createCollectionRecord(getCollectionName(\"leave\"), normalized);\r\n}\r\n\r\nexport async function updateLeaveRequestBackend(recordId, payload, actorEmail) {\r\n  const current = await getLeaveRequestBackend(recordId);\r\n  if (!current) {\r\n    return null;\r\n  }\r\n  const normalized = normalizeLeavePayload(payload, actorEmail, { base: current });\r\n  return await updateCollectionRecord(getCollectionName(\"leave\"), recordId, normalized);\r\n}\r\n\r\nfunction normalizePerformancePayload(payload, actorEmail, { base } = {}) {\r\n  const timestamp = nowIso();\r\n  const employeeEmail = normalizeEmail(payload?.employeeEmail || base?.employeeEmail);\r\n  if (!employeeEmail) {\r\n    throw new Error(\"invalid_employee_email\");\r\n  }\r\n\r\n  return {\r\n    employeeEmail,\r\n    employee: asString(payload?.employee, asString(base?.employee, employeeEmail)),\r\n    period: asString(payload?.period, asString(base?.period, \"\")),\r\n    kpiScore: asString(payload?.kpiScore, asString(base?.kpiScore, \"\")),\r\n    evaluationForm: payload?.evaluationForm ?? base?.evaluationForm ?? {},\r\n    reviewHistory: asArray(payload?.reviewHistory ?? base?.reviewHistory),\r\n    promotionJustification: asString(payload?.promotionJustification, asString(base?.promotionJustification, \"\")),\r\n    reviewer: asString(payload?.reviewer, asString(base?.reviewer, \"\")),\r\n    rating: asString(payload?.rating, asString(base?.rating, \"\")),\r\n    status: asString(payload?.status, asString(base?.status, \"Draft\")),\r\n    createdAt: asString(base?.createdAt, timestamp),\r\n    createdBy: asString(base?.createdBy, actorEmail),\r\n    updatedAt: timestamp,\r\n    updatedBy: actorEmail,\r\n    traceability: appendTrail(base?.traceability, {\r\n      at: timestamp,\r\n      by: actorEmail,\r\n      action: base ? \"update\" : \"create\",\r\n      period: asString(payload?.period, asString(base?.period, \"\")),\r\n    }),\r\n  };\r\n}\r\n\r\nexport async function listPerformanceRecordsBackend({ ownerEmail } = {}) {\r\n  return await listCollectionRecords(getCollectionName(\"performance\"), {\r\n    filterField: ownerEmail ? \"employeeEmail\" : undefined,\r\n    filterValue: ownerEmail ? normalizeEmail(ownerEmail) : undefined,\r\n  });\r\n}\r\n\r\nexport async function getPerformanceRecordBackend(recordId) {\r\n  return await getCollectionRecordById(getCollectionName(\"performance\"), recordId);\r\n}\r\n\r\nexport async function createPerformanceRecordBackend(payload, actorEmail) {\r\n  const normalized = normalizePerformancePayload(payload, actorEmail);\r\n  return await createCollectionRecord(getCollectionName(\"performance\"), normalized);\r\n}\r\n\r\nexport async function updatePerformanceRecordBackend(recordId, payload, actorEmail) {\r\n  const current = await getPerformanceRecordBackend(recordId);\r\n  if (!current) {\r\n    return null;\r\n  }\r\n  const normalized = normalizePerformancePayload(payload, actorEmail, { base: current });\r\n  return await updateCollectionRecord(getCollectionName(\"performance\"), recordId, normalized);\r\n}\r\n\r\nfunction normalizeTemplatePayload(payload, actorEmail, { base } = {}) {\r\n  const timestamp = nowIso();\r\n  const version = asString(payload?.version, asString(base?.version, \"v1.0\"));\r\n  const templateName = asString(payload?.templateName, asString(base?.templateName));\r\n  if (!templateName) {\r\n    throw new Error(\"invalid_template_name\");\r\n  }\r\n\r\n  const previousVersionEntry = base\r\n    ? {\r\n        version: asString(base.version, \"v1.0\"),\r\n        changedAt: timestamp,\r\n        changedBy: actorEmail,\r\n        note: asString(payload?.changeNote, \"Template updated\"),\r\n      }\r\n    : null;\r\n\r\n  const currentHistory = asArray(base?.versionHistory);\r\n  const nextHistory = previousVersionEntry ? appendTrail(currentHistory, previousVersionEntry) : currentHistory;\r\n\r\n  const modificationLog = appendTrail(base?.modificationLog, {\r\n    at: timestamp,\r\n    by: actorEmail,\r\n    action: base ? \"update\" : \"upload\",\r\n    version,\r\n  });\r\n\r\n  return {\r\n    templateName,\r\n    category: asString(payload?.category, asString(base?.category, \"HR Template\")),\r\n    classification: asString(payload?.classification, asString(base?.classification, \"Restricted PII\")),\r\n    documentType: asString(payload?.documentType, asString(base?.documentType, \"Template\")),\r\n    tags: asArray(payload?.tags ?? base?.tags),\r\n    version,\r\n    status: asString(payload?.status, asString(base?.status, \"Active\")),\r\n    contentRef: asString(payload?.contentRef, asString(base?.contentRef, \"\")),\r\n    acknowledgments: asArray(payload?.acknowledgments ?? base?.acknowledgments),\r\n    usageLogs: asArray(payload?.usageLogs ?? base?.usageLogs),\r\n    versionHistory: nextHistory,\r\n    modificationLog,\r\n    createdAt: asString(base?.createdAt, timestamp),\r\n    createdBy: asString(base?.createdBy, actorEmail),\r\n    updatedAt: timestamp,\r\n    updatedBy: actorEmail,\r\n  };\r\n}\r\n\r\nexport async function listDocumentTemplatesBackend() {\r\n  return await listCollectionRecords(getCollectionName(\"templates\"));\r\n}\r\n\r\nexport async function getDocumentTemplateBackend(recordId) {\r\n  return await getCollectionRecordById(getCollectionName(\"templates\"), recordId);\r\n}\r\n\r\nexport async function createDocumentTemplateBackend(payload, actorEmail) {\r\n  const normalized = normalizeTemplatePayload(payload, actorEmail);\r\n  return await createCollectionRecord(getCollectionName(\"templates\"), normalized);\r\n}\r\n\r\nexport async function updateDocumentTemplateBackend(recordId, payload, actorEmail) {\r\n  const current = await getDocumentTemplateBackend(recordId);\r\n  if (!current) {\r\n    return null;\r\n  }\r\n  const normalized = normalizeTemplatePayload(payload, actorEmail, { base: current });\r\n  return await updateCollectionRecord(getCollectionName(\"templates\"), recordId, normalized);\r\n}\r\n\r\nexport async function deleteDocumentTemplateBackend(recordId, actorEmail) {\r\n  const current = await getDocumentTemplateBackend(recordId);\r\n  if (!current) {\r\n    return null;\r\n  }\r\n  return await updateCollectionRecord(getCollectionName(\"templates\"), recordId, {\r\n    ...current,\r\n    status: \"Archived\",\r\n    archivedAt: nowIso(),\r\n    archivedBy: actorEmail,\r\n    updatedAt: nowIso(),\r\n    updatedBy: actorEmail,\r\n    modificationLog: appendTrail(current.modificationLog, {\r\n      at: nowIso(),\r\n      by: actorEmail,\r\n      action: \"archive\",\r\n      version: asString(current.version, \"v1.0\"),\r\n    }),\r\n  });\r\n}\r\n\r\nfunction normalizeExportRequestPayload(payload, actorEmail, { base } = {}) {\r\n  const timestamp = nowIso();\r\n  const dataset = asString(payload?.dataset, asString(base?.dataset, \"Employee Dataset\"));\r\n  if (!dataset) {\r\n    throw new Error(\"invalid_export_dataset\");\r\n  }\r\n\r\n  const format = asString(payload?.format, asString(base?.format, \"CSV\")).toUpperCase();\r\n  const requestedBy = normalizeEmail(payload?.requestedBy || base?.requestedBy || actorEmail);\r\n  const scope = asString(payload?.scope, asString(base?.scope, \"full\"));\r\n  const status = asString(payload?.status, asString(base?.status, \"Pending\"));\r\n  const estimateVolume = asString(payload?.estimateVolume, asString(base?.estimateVolume, \"0\"));\r\n  const justification = asString(payload?.justification, asString(base?.justification));\r\n\r\n  return {\r\n    dataset,\r\n    format,\r\n    requestedBy,\r\n    scope,\r\n    estimateVolume,\r\n    justification,\r\n    status,\r\n    reviewer: asString(payload?.reviewer, asString(base?.reviewer, \"\")),\r\n    reviewNote: asString(payload?.reviewNote, asString(base?.reviewNote, \"\")),\r\n    reviewedAt: asString(payload?.reviewedAt, asString(base?.reviewedAt, \"\")),\r\n    exportedAt: asString(payload?.exportedAt, asString(base?.exportedAt, \"\")),\r\n    exportedBy: asString(payload?.exportedBy, asString(base?.exportedBy, \"\")),\r\n    alert: asString(payload?.alert, asString(base?.alert, \"\")),\r\n    createdAt: asString(base?.createdAt, timestamp),\r\n    createdBy: asString(base?.createdBy, actorEmail),\r\n    updatedAt: timestamp,\r\n    updatedBy: actorEmail,\r\n    history: appendTrail(base?.history, {\r\n      at: timestamp,\r\n      by: actorEmail,\r\n      action: base ? \"update\" : \"create\",\r\n      status,\r\n    }),\r\n  };\r\n}\r\n\r\nexport async function listExportRequestsBackend({ ownerEmail } = {}) {\r\n  return await listCollectionRecords(getCollectionName(\"exports\"), {\r\n    filterField: ownerEmail ? \"requestedBy\" : undefined,\r\n    filterValue: ownerEmail ? normalizeEmail(ownerEmail) : undefined,\r\n  });\r\n}\r\n\r\nexport async function getExportRequestBackend(recordId) {\r\n  return await getCollectionRecordById(getCollectionName(\"exports\"), recordId);\r\n}\r\n\r\nexport async function createExportRequestBackend(payload, actorEmail) {\r\n  const normalized = normalizeExportRequestPayload(payload, actorEmail);\r\n  return await createCollectionRecord(getCollectionName(\"exports\"), normalized);\r\n}\r\n\r\nexport async function updateExportRequestBackend(recordId, payload, actorEmail) {\r\n  const current = await getExportRequestBackend(recordId);\r\n  if (!current) {\r\n    return null;\r\n  }\r\n  const normalized = normalizeExportRequestPayload(payload, actorEmail, { base: current });\r\n  return await updateCollectionRecord(getCollectionName(\"exports\"), recordId, normalized);\r\n}\r\n\r\nexport async function approveExportRequestBackend(recordId, actorEmail, { approved, note } = {}) {\r\n  const status = approved ? \"Approved\" : \"Rejected\";\r\n  return await updateExportRequestBackend(\r\n    recordId,\r\n    {\r\n      status,\r\n      reviewer: actorEmail,\r\n      reviewNote: asString(note, \"\"),\r\n      reviewedAt: nowIso(),\r\n    },\r\n    actorEmail,\r\n  );\r\n}\r\n\r\nexport async function markExportAsCompletedBackend(recordId, actorEmail) {\r\n  return await updateExportRequestBackend(\r\n    recordId,\r\n    {\r\n      status: \"Exported\",\r\n      exportedBy: actorEmail,\r\n      exportedAt: nowIso(),\r\n    },\r\n    actorEmail,\r\n  );\r\n}\r\n\r\nfunction normalizeIncidentSeverity(value, fallback = \"Low\") {\r\n  const normalized = asString(value, fallback).toLowerCase();\r\n  if (normalized === \"critical\") {\r\n    return \"High\";\r\n  }\r\n  if (normalized === \"medium\") {\r\n    return \"Low\";\r\n  }\r\n  const matched = INCIDENT_SEVERITY_LEVELS.find((entry) => entry.toLowerCase() === normalized);\r\n  return matched || \"Low\";\r\n}\r\n\r\nfunction normalizeIncidentStatus(value, fallback = \"Open\") {\r\n  const normalized = asString(value, fallback).toLowerCase();\r\n  const matched = INCIDENT_STATUS_VALUES.find((entry) => entry.toLowerCase() === normalized);\r\n  return matched || \"Open\";\r\n}\r\n\r\nfunction normalizeIncidentContainmentStatus(value, fallback = \"Not Started\") {\r\n  const normalized = asString(value, fallback).toLowerCase();\r\n  const matched = INCIDENT_CONTAINMENT_STATUS_VALUES.find((entry) => entry.toLowerCase() === normalized);\r\n  return matched || \"Not Started\";\r\n}\r\n\r\nfunction normalizeIncidentImpactStatus(value, fallback = \"Pending\") {\r\n  const normalized = asString(value, fallback).toLowerCase();\r\n  const matched = INCIDENT_IMPACT_STATUS_VALUES.find((entry) => entry.toLowerCase() === normalized);\r\n  return matched || \"Pending\";\r\n}\r\n\r\nfunction normalizeIncidentType(value, fallback = \"Other\") {\r\n  const normalized = asString(value, fallback).toLowerCase();\r\n  const matched = INCIDENT_TYPE_VALUES.find((entry) => entry.toLowerCase() === normalized);\r\n  return matched || \"Other\";\r\n}\r\n\r\nfunction buildIncidentCode(isoValue = nowIso()) {\r\n  const date = new Date(isoValue || nowIso());\r\n  if (Number.isNaN(date.getTime())) {\r\n    return `INC-${Date.now().toString().slice(-10)}`;\r\n  }\r\n  const yyyy = String(date.getUTCFullYear());\r\n  const mm = String(date.getUTCMonth() + 1).padStart(2, \"0\");\r\n  const dd = String(date.getUTCDate()).padStart(2, \"0\");\r\n  const hh = String(date.getUTCHours()).padStart(2, \"0\");\r\n  const mi = String(date.getUTCMinutes()).padStart(2, \"0\");\r\n  const random = Math.random().toString(36).slice(2, 5).toUpperCase();\r\n  return `INC-${yyyy}${mm}${dd}-${hh}${mi}${random}`;\r\n}\r\n\r\nfunction extractEvidenceExtension(value) {\r\n  const normalized = asString(value).toLowerCase();\r\n  if (!normalized) {\r\n    return \"\";\r\n  }\r\n  const clean = normalized.split(\"?\")[0].split(\"#\")[0];\r\n  const token = clean.split(\".\").pop() || \"\";\r\n  if (!/^[a-z0-9]{2,10}$/.test(token)) {\r\n    return \"\";\r\n  }\r\n  return token;\r\n}\r\n\r\nfunction sanitizeIncidentEvidenceDocuments(value, actorEmail, fallbackNowIso) {\r\n  const timestamp = asString(fallbackNowIso, nowIso());\r\n  const config = getIncidentEvidenceValidationConfig();\r\n  return asArray(value)\r\n    .map((entry, index) => {\r\n      const source = asObject(entry, {});\r\n      const uploadedAt = toIsoOrEmpty(source.uploadedAt || timestamp) || timestamp;\r\n      const uploadedBy = normalizeEmail(source.uploadedBy || actorEmail);\r\n      const name = asString(source.name, `Incident Evidence ${index + 1}`);\r\n      const type = asString(source.type, \"Incident Evidence\");\r\n      const ref = asString(source.ref);\r\n      const storagePath = asString(source.storagePath);\r\n      const fileExtension = extractEvidenceExtension(source.fileExtension || name || storagePath || ref);\r\n      const contentType = normalizeText(source.contentType);\r\n      const sizeBytes = Number.isFinite(Number(source.sizeBytes)) ? Number(source.sizeBytes) : 0;\r\n      const id = asString(source.id || source.recordId || storagePath || `${index + 1}`);\r\n      if (!name && !ref && !storagePath) {\r\n        return null;\r\n      }\r\n      if (fileExtension && !config.allowedExtensions.has(fileExtension)) {\r\n        throw new Error(\"invalid_incident_evidence_extension\");\r\n      }\r\n      if (contentType && !config.allowedMimeTypes.has(contentType)) {\r\n        throw new Error(\"invalid_incident_evidence_content_type\");\r\n      }\r\n      if (sizeBytes > config.maxBytes) {\r\n        throw new Error(\"invalid_incident_evidence_size\");\r\n      }\r\n      return {\r\n        id,\r\n        name: name || \"Incident Evidence\",\r\n        type: type || \"Incident Evidence\",\r\n        ref,\r\n        storagePath,\r\n        fileExtension,\r\n        contentType,\r\n        sizeBytes,\r\n        scanStatus: asString(source.scanStatus),\r\n        scanReference: asString(source.scanReference),\r\n        scannedAt: toIsoOrEmpty(source.scannedAt || \"\"),\r\n        uploadedAt,\r\n        uploadedBy: uploadedBy || actorEmail,\r\n      };\r\n    })\r\n    .filter(Boolean)\r\n    .slice(0, MAX_INCIDENT_EVIDENCE_ITEMS);\r\n}\r\n\r\nfunction sanitizeIncidentAlertOccurrences(value) {\r\n  return asArray(value)\r\n    .map((entry) => {\r\n      const source = asObject(entry, {});\r\n      const at = toIsoOrEmpty(source.at || source.occurredAt || \"\");\r\n      if (!at) {\r\n        return null;\r\n      }\r\n      return {\r\n        at,\r\n        activityName: asString(source.activityName || source.action || \"Activity\"),\r\n        module: asString(source.module || \"System\"),\r\n        sourceEventId: asString(source.sourceEventId || source.eventId || \"\"),\r\n        sourceIp: asString(source.sourceIp || \"\"),\r\n        requestPath: asString(source.requestPath || \"\"),\r\n        requestMethod: asString(source.requestMethod || \"\"),\r\n        actorEmail: normalizeEmail(source.actorEmail || source.performedBy || \"\"),\r\n        targetEmployeeEmail: normalizeEmail(source.targetEmployeeEmail || source.employeeEmail || \"\"),\r\n      };\r\n    })\r\n    .filter(Boolean)\r\n    .slice(-40);\r\n}\r\n\r\nfunction resolveIncidentEscalationLevel({ severity, restrictedPiiInvolved, executiveNotificationRequired }) {\r\n  if (severity === \"High\" || executiveNotificationRequired) {\r\n    return \"Executive\";\r\n  }\r\n  if (restrictedPiiInvolved) {\r\n    return \"GRC\";\r\n  }\r\n  return \"Operational\";\r\n}\r\n\r\nfunction resolveIncidentRegulatoryStatus({\r\n  regulatoryNotificationRequired,\r\n  regulatoryNotifiedAt,\r\n  regulatoryDueAt,\r\n  nowIsoValue = nowIso(),\r\n}) {\r\n  if (!regulatoryNotificationRequired) {\r\n    return \"Not Required\";\r\n  }\r\n  if (toTimeMs(regulatoryNotifiedAt)) {\r\n    return \"Notified\";\r\n  }\r\n  const dueAtMs = toTimeMs(regulatoryDueAt);\r\n  const nowMs = toTimeMs(nowIsoValue) || Date.now();\r\n  if (Number.isFinite(dueAtMs) && dueAtMs < nowMs) {\r\n    return \"Overdue\";\r\n  }\r\n  return \"Pending\";\r\n}\r\n\r\nfunction incidentSeverityRank(value) {\r\n  const severity = normalizeIncidentSeverity(value);\r\n  switch (severity) {\r\n    case \"High\":\r\n      return 1;\r\n    default:\r\n      return 0;\r\n  }\r\n}\r\n\r\nfunction isIncidentAccessEvent(row) {\r\n  const method = normalizeText(row?.requestMethod);\r\n  const activity = normalizeText(row?.activityName);\r\n  return method === \"get\" || activity.includes(\"viewed\") || activity.includes(\"listed\") || activity.includes(\"access\");\r\n}\r\n\r\nfunction isIncidentExportEvent(row) {\r\n  const moduleName = normalizeText(row?.module);\r\n  const path = normalizeText(row?.requestPath);\r\n  const activity = normalizeText(row?.activityName);\r\n  return moduleName.includes(\"export\") || path.includes(\"/api/hris/exports\") || activity.includes(\"export\");\r\n}\r\n\r\nfunction isIncidentDeletionEvent(row) {\r\n  const method = normalizeText(row?.requestMethod);\r\n  const activity = normalizeText(row?.activityName);\r\n  return (\r\n    method === \"delete\" ||\r\n    activity.includes(\"delete\") ||\r\n    activity.includes(\"purge\") ||\r\n    activity.includes(\"removed\") ||\r\n    activity.includes(\"archive\")\r\n  );\r\n}\r\n\r\nfunction isIncidentAdministrativeEvent(row) {\r\n  const moduleName = normalizeText(row?.module);\r\n  const method = normalizeText(row?.requestMethod);\r\n  const activity = normalizeText(row?.activityName);\r\n  return (\r\n    moduleName.includes(\"authorization\") ||\r\n    moduleName.includes(\"user management\") ||\r\n    moduleName.includes(\"access management\") ||\r\n    method === \"patch\" ||\r\n    method === \"post\" ||\r\n    activity.includes(\"approve\") ||\r\n    activity.includes(\"revok\") ||\r\n    activity.includes(\"invite\") ||\r\n    activity.includes(\"role\")\r\n  );\r\n}\r\n\r\nfunction normalizeIncidentForensicSample(row) {\r\n  const metadata = asObject(row?.metadata, {});\r\n  return {\r\n    id: asString(row?.id),\r\n    activityName: asString(row?.activityName),\r\n    module: asString(row?.module),\r\n    status: asString(row?.status),\r\n    occurredAt: asString(row?.occurredAt),\r\n    performedBy: asString(row?.performedBy),\r\n    requestMethod: asString(row?.requestMethod),\r\n    requestPath: asString(row?.requestPath),\r\n    sourceIp: asString(row?.sourceIp || metadata?.sourceIp),\r\n    userAgent: asString(row?.userAgent || metadata?.userAgent),\r\n    device: asString(metadata?.device || \"\"),\r\n    recordRef: asString(metadata?.recordRef || metadata?.recordId),\r\n    resourceLabel: asString(metadata?.resourceLabel),\r\n    employeeEmail: asString(metadata?.employeeEmail),\r\n    targetEmployeeEmail: asString(metadata?.targetEmployeeEmail || metadata?.affectedEmployeeEmail),\r\n    viewedFields: asArray(metadata?.viewedFields, []),\r\n    viewedFieldCount: Number(metadata?.viewedFieldCount || 0),\r\n    accessedDocuments: asArray(metadata?.accessedDocuments, []),\r\n    accessedDocumentCount: Number(metadata?.accessedDocumentCount || 0),\r\n    updatedFields: asArray(metadata?.updatedFields, []),\r\n    changedFields: asArray(metadata?.changedFields, []),\r\n  };\r\n}\r\n\r\nfunction incidentMatchesSubject(row, subjectEmail) {\r\n  const subject = normalizeEmail(subjectEmail);\r\n  if (!subject) {\r\n    return true;\r\n  }\r\n\r\n  const metadata = asObject(row?.metadata, {});\r\n  const candidates = [\r\n    row?.performedBy,\r\n    row?.performedByEmail,\r\n    metadata.employeeEmail,\r\n    metadata.ownerEmail,\r\n    metadata.requestedBy,\r\n    metadata.targetEmployeeEmail,\r\n    metadata.affectedEmployeeEmail,\r\n  ];\r\n  return candidates.some((value) => normalizeEmail(value) === subject);\r\n}\r\n\r\nasync function buildIncidentForensicSnapshot(record, { limit } = {}) {\r\n  const nowIsoValue = nowIso();\r\n  const windowStart = toIsoOrEmpty(record?.forensicWindowStart || record?.detectedAt) || nowIsoValue;\r\n  const windowEnd = toIsoOrEmpty(record?.forensicWindowEnd || nowIsoValue) || nowIsoValue;\r\n  const windowStartMs = toTimeMs(windowStart) || 0;\r\n  const windowEndMs = toTimeMs(windowEnd) || Date.now();\r\n  const subjectEmail = normalizeEmail(record?.affectedEmployeeEmail || record?.employeeEmail || \"\");\r\n  const safeLimit = Number.isFinite(Number(limit)) ? Number(limit) : 1800;\r\n\r\n  let rows = [];\r\n  try {\r\n    rows = await listAuditEvents({ limit: Math.max(100, Math.min(5000, safeLimit)) });\r\n  } catch {\r\n    rows = [];\r\n  }\r\n\r\n  const scopedRows = rows.filter((row) => {\r\n    const occurredAtMs = toTimeMs(row?.occurredAt || row?.loggedAt);\r\n    if (!Number.isFinite(occurredAtMs)) {\r\n      return false;\r\n    }\r\n    if (occurredAtMs < windowStartMs || occurredAtMs > windowEndMs) {\r\n      return false;\r\n    }\r\n    return incidentMatchesSubject(row, subjectEmail);\r\n  });\r\n\r\n  const buckets = {\r\n    accessLogs: [],\r\n    exportLogs: [],\r\n    administrativeActions: [],\r\n    deletionActivities: [],\r\n  };\r\n\r\n  scopedRows.forEach((row) => {\r\n    const sample = normalizeIncidentForensicSample(row);\r\n    if (isIncidentDeletionEvent(row)) {\r\n      buckets.deletionActivities.push(sample);\r\n      return;\r\n    }\r\n    if (isIncidentExportEvent(row)) {\r\n      buckets.exportLogs.push(sample);\r\n      return;\r\n    }\r\n    if (isIncidentAdministrativeEvent(row)) {\r\n      buckets.administrativeActions.push(sample);\r\n      return;\r\n    }\r\n    if (isIncidentAccessEvent(row)) {\r\n      buckets.accessLogs.push(sample);\r\n    }\r\n  });\r\n\r\n  return {\r\n    generatedAt: nowIsoValue,\r\n    windowStart,\r\n    windowEnd,\r\n    scopedSubjectEmail: subjectEmail || \"\",\r\n    totalScopedLogs: scopedRows.length,\r\n    accessLogsCount: buckets.accessLogs.length,\r\n    exportLogsCount: buckets.exportLogs.length,\r\n    administrativeActionsCount: buckets.administrativeActions.length,\r\n    deletionActivitiesCount: buckets.deletionActivities.length,\r\n    accessLogs: buckets.accessLogs.slice(0, MAX_INCIDENT_FORENSIC_SAMPLES),\r\n    exportLogs: buckets.exportLogs.slice(0, MAX_INCIDENT_FORENSIC_SAMPLES),\r\n    administrativeActions: buckets.administrativeActions.slice(0, MAX_INCIDENT_FORENSIC_SAMPLES),\r\n    deletionActivities: buckets.deletionActivities.slice(0, MAX_INCIDENT_FORENSIC_SAMPLES),\r\n  };\r\n}\r\n\r\nfunction normalizeIncidentWritePayload(payload, actorEmail, { base } = {}) {\r\n  const timestamp = nowIso();\r\n  const title = asString(payload?.title, asString(base?.title));\r\n  if (!title) {\r\n    throw new Error(\"invalid_incident_title\");\r\n  }\r\n\r\n  const detectedAt = toIsoOrEmpty(payload?.detectedAt || base?.detectedAt || timestamp) || timestamp;\r\n  const severity = normalizeIncidentSeverity(payload?.severity, asString(base?.severity, \"Low\"));\r\n  const incidentType = normalizeIncidentType(payload?.incidentType, asString(base?.incidentType, \"Other\"));\r\n  const restrictedPiiInvolved = asBoolean(payload?.restrictedPiiInvolved, asBoolean(base?.restrictedPiiInvolved, false));\r\n  const executiveNotificationRequired = asBoolean(\r\n    payload?.executiveNotificationRequired,\r\n    severity === \"High\" || asBoolean(base?.executiveNotificationRequired, false),\r\n  );\r\n  const escalationRequired = asBoolean(\r\n    payload?.escalationRequired,\r\n    executiveNotificationRequired ||\r\n      restrictedPiiInvolved ||\r\n      incidentSeverityRank(severity) >= incidentSeverityRank(\"High\") ||\r\n      asBoolean(base?.escalationRequired, false),\r\n  );\r\n  const escalationLevel = resolveIncidentEscalationLevel({\r\n    severity,\r\n    restrictedPiiInvolved,\r\n    executiveNotificationRequired,\r\n  });\r\n\r\n  const status = normalizeIncidentStatus(payload?.status, asString(base?.status, \"Open\"));\r\n  const containmentStatus = normalizeIncidentContainmentStatus(\r\n    payload?.containmentStatus,\r\n    asString(base?.containmentStatus, \"Not Started\"),\r\n  );\r\n  const impactAssessmentStatus = normalizeIncidentImpactStatus(\r\n    payload?.impactAssessmentStatus,\r\n    asString(base?.impactAssessmentStatus, \"Pending\"),\r\n  );\r\n\r\n  const regulatoryNotificationRequired = asBoolean(\r\n    payload?.regulatoryNotificationRequired,\r\n    restrictedPiiInvolved || asBoolean(base?.regulatoryNotificationRequired, false),\r\n  );\r\n  const regulatoryDueAt = regulatoryNotificationRequired\r\n    ? asString(base?.regulatoryDueAt, addHoursToIso(detectedAt, 72))\r\n    : \"\";\r\n  const regulatoryNotifiedAt = toIsoOrEmpty(payload?.regulatoryNotifiedAt || base?.regulatoryNotifiedAt || \"\");\r\n  const affectedIndividualsNotifiedAt = toIsoOrEmpty(\r\n    payload?.affectedIndividualsNotifiedAt || base?.affectedIndividualsNotifiedAt || \"\",\r\n  );\r\n  const regulatoryStatus = resolveIncidentRegulatoryStatus({\r\n    regulatoryNotificationRequired,\r\n    regulatoryNotifiedAt,\r\n    regulatoryDueAt,\r\n    nowIsoValue: timestamp,\r\n  });\r\n\r\n  const documentationRetained = asBoolean(payload?.documentationRetained, asBoolean(base?.documentationRetained, false));\r\n  const documentationRetainedAt = documentationRetained\r\n    ? toIsoOrEmpty(payload?.documentationRetainedAt || base?.documentationRetainedAt || timestamp) || timestamp\r\n    : \"\";\r\n  const executiveNotifiedAt = toIsoOrEmpty(payload?.executiveNotifiedAt || base?.executiveNotifiedAt || \"\");\r\n  const grcAlertedAt = escalationRequired\r\n    ? toIsoOrEmpty(payload?.grcAlertedAt || base?.grcAlertedAt || timestamp) || timestamp\r\n    : \"\";\r\n  const breachConfirmed = asBoolean(payload?.breachConfirmed, asBoolean(base?.breachConfirmed, false));\r\n  const breachConfirmedAt = breachConfirmed\r\n    ? toIsoOrEmpty(payload?.breachConfirmedAt || base?.breachConfirmedAt || timestamp) || timestamp\r\n    : \"\";\r\n  const breachConfirmedBy = breachConfirmed\r\n    ? normalizeEmail(payload?.breachConfirmedBy || base?.breachConfirmedBy || actorEmail)\r\n    : \"\";\r\n\r\n  const containmentStartedAt =\r\n    containmentStatus === \"In Progress\" || containmentStatus === \"Contained\"\r\n      ? toIsoOrEmpty(payload?.containmentStartedAt || base?.containmentStartedAt || timestamp) || timestamp\r\n      : toIsoOrEmpty(payload?.containmentStartedAt || base?.containmentStartedAt || \"\");\r\n  const containmentCompletedAt =\r\n    containmentStatus === \"Contained\"\r\n      ? toIsoOrEmpty(payload?.containmentCompletedAt || base?.containmentCompletedAt || timestamp) || timestamp\r\n      : toIsoOrEmpty(payload?.containmentCompletedAt || base?.containmentCompletedAt || \"\");\r\n  const impactAssessmentCompletedAt =\r\n    impactAssessmentStatus === \"Completed\"\r\n      ? toIsoOrEmpty(payload?.impactAssessmentCompletedAt || base?.impactAssessmentCompletedAt || timestamp) || timestamp\r\n      : toIsoOrEmpty(payload?.impactAssessmentCompletedAt || base?.impactAssessmentCompletedAt || \"\");\r\n\r\n  const forensicWindowStart = toIsoOrEmpty(payload?.forensicWindowStart || base?.forensicWindowStart || detectedAt) || detectedAt;\r\n  const forensicWindowEnd = toIsoOrEmpty(payload?.forensicWindowEnd || base?.forensicWindowEnd || timestamp) || timestamp;\r\n  const evidenceDocuments = sanitizeIncidentEvidenceDocuments(\r\n    Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"evidenceDocuments\")\r\n      ? payload?.evidenceDocuments\r\n      : base?.evidenceDocuments,\r\n    actorEmail,\r\n    timestamp,\r\n  );\r\n  const detectionWindowStart = toIsoOrEmpty(payload?.detectionWindowStart || base?.detectionWindowStart || \"\");\r\n  const detectionWindowEnd = toIsoOrEmpty(payload?.detectionWindowEnd || base?.detectionWindowEnd || \"\");\r\n  const detectionCorrelationKey = asString(payload?.detectionCorrelationKey, asString(base?.detectionCorrelationKey));\r\n  const alertDescription = asString(payload?.alertDescription, asString(base?.alertDescription));\r\n  const alertOccurrences = sanitizeIncidentAlertOccurrences(payload?.alertOccurrences || base?.alertOccurrences);\r\n  const alertFirstObservedAt = toIsoOrEmpty(\r\n    payload?.alertFirstObservedAt || base?.alertFirstObservedAt || detectedAt || \"\",\r\n  );\r\n  const alertLastObservedAt = toIsoOrEmpty(\r\n    payload?.alertLastObservedAt || base?.alertLastObservedAt || detectedAt || \"\",\r\n  );\r\n  const defaultOccurrenceCount = alertOccurrences.length > 0 ? alertOccurrences.length : 1;\r\n  const alertOccurrenceCount = Math.max(\r\n    1,\r\n    Number.parseInt(\r\n      String(\r\n        payload?.alertOccurrenceCount ??\r\n          base?.alertOccurrenceCount ??\r\n          defaultOccurrenceCount,\r\n      ),\r\n      10,\r\n    ) || defaultOccurrenceCount,\r\n  );\r\n  const alertRecipients = asArray(payload?.alertRecipients || base?.alertRecipients)\r\n    .map((value) => normalizeEmail(value))\r\n    .filter(Boolean)\r\n    .slice(0, 40);\r\n  const involvedEmployees = asArray(payload?.involvedEmployees || base?.involvedEmployees)\r\n    .map((value) => normalizeEmail(value))\r\n    .filter(Boolean)\r\n    .slice(0, 40);\r\n\r\n  return {\r\n    incidentCode: asString(base?.incidentCode, buildIncidentCode(detectedAt)),\r\n    title,\r\n    summary: asString(payload?.summary, asString(base?.summary)),\r\n    incidentType,\r\n    severity,\r\n    status,\r\n    restrictedPiiInvolved,\r\n    affectedEmployeeEmail: normalizeEmail(payload?.affectedEmployeeEmail || base?.affectedEmployeeEmail),\r\n    ownerEmail: normalizeEmail(payload?.ownerEmail || base?.ownerEmail || actorEmail),\r\n    department: asString(payload?.department, asString(base?.department)),\r\n    involvedEmployees,\r\n    escalationRequired,\r\n    escalationLevel,\r\n    executiveNotificationRequired,\r\n    executiveNotifiedAt,\r\n    grcAlertedAt,\r\n    containmentStatus,\r\n    containmentSummary: asString(payload?.containmentSummary, asString(base?.containmentSummary)),\r\n    containmentStartedAt,\r\n    containmentCompletedAt,\r\n    impactAssessmentStatus,\r\n    impactSummary: asString(payload?.impactSummary, asString(base?.impactSummary)),\r\n    impactAssessmentCompletedAt,\r\n    regulatoryNotificationRequired,\r\n    regulatoryDueAt,\r\n    regulatoryNotifiedAt,\r\n    affectedIndividualsNotifiedAt,\r\n    regulatoryStatus,\r\n    documentationRetained,\r\n    documentationRetainedAt,\r\n    documentationLocation: asString(payload?.documentationLocation, asString(base?.documentationLocation)),\r\n    breachConfirmed,\r\n    breachConfirmedAt,\r\n    breachConfirmedBy,\r\n    correctiveActions: asString(payload?.correctiveActions, asString(base?.correctiveActions)),\r\n    disciplinaryActions: asString(payload?.disciplinaryActions, asString(base?.disciplinaryActions)),\r\n    resolutionNotes: asString(payload?.resolutionNotes, asString(base?.resolutionNotes)),\r\n    closureApprovalStatus: asString(payload?.closureApprovalStatus, asString(base?.closureApprovalStatus, \"Pending Approval\")),\r\n    closureApprovedBy: asString(payload?.closureApprovedBy, asString(base?.closureApprovedBy)),\r\n    closureApprovedAt: toIsoOrEmpty(payload?.closureApprovedAt || base?.closureApprovedAt || \"\"),\r\n    forensicWindowStart,\r\n    forensicWindowEnd,\r\n    evidenceDocuments,\r\n    evidenceDocumentsCount: evidenceDocuments.length,\r\n    notes: asString(payload?.notes, asString(base?.notes)),\r\n    classificationStandard: asString(payload?.classificationStandard, asString(base?.classificationStandard, \"CLIO-IR-SEVERITY-V1\")),\r\n    autoGenerated: asBoolean(payload?.autoGenerated, asBoolean(base?.autoGenerated, false)),\r\n    detectionRuleId: asString(payload?.detectionRuleId, asString(base?.detectionRuleId)),\r\n    detectionFingerprint: asString(payload?.detectionFingerprint, asString(base?.detectionFingerprint)),\r\n    detectionCorrelationKey,\r\n    detectionWindowStart,\r\n    detectionWindowEnd,\r\n    alertDescription,\r\n    alertOccurrenceCount,\r\n    alertFirstObservedAt,\r\n    alertLastObservedAt,\r\n    alertOccurrences,\r\n    sourceSystem: asString(payload?.sourceSystem, asString(base?.sourceSystem)),\r\n    sourceEventId: asString(payload?.sourceEventId, asString(base?.sourceEventId)),\r\n    sourceEventModule: asString(payload?.sourceEventModule, asString(base?.sourceEventModule)),\r\n    sourceEventPath: asString(payload?.sourceEventPath, asString(base?.sourceEventPath)),\r\n    sourceIp: asString(payload?.sourceIp, asString(base?.sourceIp)),\r\n    alertRecipients,\r\n    alertDispatchSummary: asObject(payload?.alertDispatchSummary, asObject(base?.alertDispatchSummary, {})),\r\n    externalIntegrations: asObject(payload?.externalIntegrations, asObject(base?.externalIntegrations, {})),\r\n    lastAlertDispatchAt: toIsoOrEmpty(payload?.lastAlertDispatchAt || base?.lastAlertDispatchAt || \"\"),\r\n    detectedAt,\r\n    resolvedAt: toIsoOrEmpty(payload?.resolvedAt || base?.resolvedAt || (status === \"Resolved\" ? timestamp : \"\")),\r\n    closedAt: toIsoOrEmpty(payload?.closedAt || base?.closedAt || (status === \"Closed\" ? timestamp : \"\")),\r\n    createdAt: asString(base?.createdAt, timestamp),\r\n    createdBy: asString(base?.createdBy, actorEmail),\r\n    updatedAt: timestamp,\r\n    updatedBy: actorEmail,\r\n    traceability: appendTrail(base?.traceability, {\r\n      at: timestamp,\r\n      by: actorEmail,\r\n      action: base ? \"update\" : \"create\",\r\n      status,\r\n      severity,\r\n      escalationLevel,\r\n      regulatoryStatus,\r\n    }),\r\n  };\r\n}\r\n\r\nfunction withIncidentForensic(record, forensicSnapshot, actorEmail) {\r\n  const snapshot = asObject(forensicSnapshot, {});\r\n  return {\r\n    ...record,\r\n    forensicSnapshot: snapshot,\r\n    forensicSummary: {\r\n      accessLogsCount: Number(snapshot.accessLogsCount || 0),\r\n      exportLogsCount: Number(snapshot.exportLogsCount || 0),\r\n      administrativeActionsCount: Number(snapshot.administrativeActionsCount || 0),\r\n      deletionActivitiesCount: Number(snapshot.deletionActivitiesCount || 0),\r\n      totalScopedLogs: Number(snapshot.totalScopedLogs || 0),\r\n      generatedAt: asString(snapshot.generatedAt),\r\n      windowStart: asString(snapshot.windowStart),\r\n      windowEnd: asString(snapshot.windowEnd),\r\n    },\r\n    forensicLastUpdatedAt: asString(snapshot.generatedAt, nowIso()),\r\n    forensicLastUpdatedBy: actorEmail,\r\n  };\r\n}\r\n\r\nexport async function listIncidentRecordsBackend() {\r\n  return await listCollectionRecords(getCollectionName(\"incidents\"));\r\n}\r\n\r\nexport async function getIncidentRecordBackend(recordId) {\r\n  return await getCollectionRecordById(getCollectionName(\"incidents\"), recordId);\r\n}\r\n\r\nexport async function createIncidentRecordBackend(payload, actorEmail) {\r\n  const normalized = normalizeIncidentWritePayload(payload, actorEmail);\r\n  const forensicSnapshot = await buildIncidentForensicSnapshot(normalized, {\r\n    limit: Number.parseInt(env(\"CLIO_INCIDENT_FORENSIC_LOG_LIMIT\", \"1800\"), 10),\r\n  });\r\n  const withForensic = withIncidentForensic(normalized, forensicSnapshot, actorEmail);\r\n  return await createCollectionRecord(getCollectionName(\"incidents\"), withForensic);\r\n}\r\n\r\nexport async function updateIncidentRecordBackend(recordId, payload, actorEmail) {\r\n  const current = await getIncidentRecordBackend(recordId);\r\n  if (!current) {\r\n    return null;\r\n  }\r\n  const normalized = normalizeIncidentWritePayload(payload, actorEmail, { base: current });\r\n  const shouldRefreshForensic =\r\n    asBoolean(payload?.refreshForensicSnapshot, false) ||\r\n    Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"forensicWindowStart\") ||\r\n    Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"forensicWindowEnd\") ||\r\n    Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"affectedEmployeeEmail\") ||\r\n    Object.prototype.hasOwnProperty.call(asObject(payload, {}), \"detectedAt\");\r\n\r\n  const forensicSnapshot = shouldRefreshForensic\r\n    ? await buildIncidentForensicSnapshot(normalized, {\r\n        limit: Number.parseInt(env(\"CLIO_INCIDENT_FORENSIC_LOG_LIMIT\", \"1800\"), 10),\r\n      })\r\n    : asObject(current.forensicSnapshot, {});\r\n  const withForensic = withIncidentForensic(normalized, forensicSnapshot, actorEmail);\r\n  return await updateCollectionRecord(getCollectionName(\"incidents\"), recordId, withForensic);\r\n}\r\n\r\nasync function purgeCollectionByRetention(collectionName, cutoff) {\r\n  const db = getDbOrThrow();\r\n  const snapshot = await getDocs(\r\n    query(collection(db, collectionName), where(\"retentionDeleteAt\", \"<=\", cutoff)),\r\n  );\r\n  let deleted = 0;\r\n  for (const recordSnapshot of snapshot.docs) {\r\n    await deleteDoc(doc(db, collectionName, recordSnapshot.id));\r\n    deleted += 1;\r\n  }\r\n  return deleted;\r\n}\r\n\r\nasync function purgeEmployeeCollectionByRetention(cutoff) {\r\n  const db = getDbOrThrow();\r\n  const employeesCollection = getCollectionName(\"employees\");\r\n  const snapshot = await getDocs(\r\n    query(collection(db, employeesCollection), where(\"retentionDeleteAt\", \"<=\", cutoff)),\r\n  );\r\n\r\n  let deleted = 0;\r\n  for (const recordSnapshot of snapshot.docs) {\r\n    await deleteEmployeeDocumentSubcollectionById(recordSnapshot.id, { db });\r\n    await deleteDoc(doc(db, employeesCollection, recordSnapshot.id));\r\n    deleted += 1;\r\n  }\r\n  return deleted;\r\n}\r\n\r\nexport async function purgeArchivedEmployeeDataBackend({ now } = {}) {\r\n  const cutoff = asString(now, nowIso());\r\n  const deletedByCollection = {\r\n    employees: await purgeEmployeeCollectionByRetention(cutoff),\r\n    lifecycle: await purgeCollectionByRetention(getCollectionName(\"lifecycle\"), cutoff),\r\n    attendance: await purgeCollectionByRetention(getCollectionName(\"attendance\"), cutoff),\r\n    leave: await purgeCollectionByRetention(getCollectionName(\"leave\"), cutoff),\r\n    performance: await purgeCollectionByRetention(getCollectionName(\"performance\"), cutoff),\r\n    exports: await purgeCollectionByRetention(getCollectionName(\"exports\"), cutoff),\r\n  };\r\n\r\n  const deletedUsers = await purgeDueArchivedUserAccounts({ now: cutoff });\r\n  return {\r\n    cutoff,\r\n    deletedByCollection,\r\n    deletedUsers,\r\n  };\r\n}\r\n\r\nfunction toTimeMs(value) {\r\n  const timestamp = new Date(value || \"\").getTime();\r\n  return Number.isNaN(timestamp) ? null : timestamp;\r\n}\r\n\r\nfunction toIsoOrEmpty(value) {\r\n  const timestamp = toTimeMs(value);\r\n  if (!Number.isFinite(timestamp)) {\r\n    return \"\";\r\n  }\r\n  return new Date(timestamp).toISOString();\r\n}\r\n\r\nfunction clampInt(value, fallback, { min = 0, max = Number.MAX_SAFE_INTEGER } = {}) {\r\n  const parsed = Number.parseInt(String(value ?? \"\"), 10);\r\n  if (!Number.isFinite(parsed)) {\r\n    return fallback;\r\n  }\r\n  return Math.min(max, Math.max(min, parsed));\r\n}\r\n\r\nfunction deriveRetentionState(retentionDeleteAt, nowMs, dueWithinMs) {\r\n  const retentionMs = toTimeMs(retentionDeleteAt);\r\n  if (!Number.isFinite(retentionMs)) {\r\n    return {\r\n      state: \"no_retention\",\r\n      daysToDeletion: null,\r\n    };\r\n  }\r\n\r\n  const daysToDeletion = Math.ceil((retentionMs - nowMs) / (24 * 60 * 60 * 1000));\r\n  if (retentionMs <= nowMs) {\r\n    return {\r\n      state: \"due\",\r\n      daysToDeletion,\r\n    };\r\n  }\r\n\r\n  if (retentionMs <= nowMs + dueWithinMs) {\r\n    return {\r\n      state: \"due_soon\",\r\n      daysToDeletion,\r\n    };\r\n  }\r\n\r\n  return {\r\n    state: \"scheduled\",\r\n    daysToDeletion,\r\n  };\r\n}\r\n\r\nfunction getRetentionRecordLabel(moduleId, row, moduleLabel) {\r\n  const recordId = asString(row?.recordId, asString(row?.id));\r\n  if (moduleId === \"employees\") {\r\n    return asString(row?.name, asString(row?.employeeId, asString(row?.email, recordId || `${moduleLabel} Record`)));\r\n  }\r\n  if (moduleId === \"lifecycle\") {\r\n    const employee = asString(row?.employee, asString(row?.employeeEmail));\r\n    const category = asString(row?.category);\r\n    return [employee || \"Employee\", category].filter(Boolean).join(\" - \");\r\n  }\r\n  if (moduleId === \"attendance\") {\r\n    return [asString(row?.employee, \"Employee\"), asString(row?.date)].filter(Boolean).join(\" - \");\r\n  }\r\n  if (moduleId === \"leave\") {\r\n    return [asString(row?.employee, \"Employee\"), asString(row?.leaveType, \"Leave\")].filter(Boolean).join(\" - \");\r\n  }\r\n  if (moduleId === \"performance\") {\r\n    return [asString(row?.employee, \"Employee\"), asString(row?.period, \"Performance\")].filter(Boolean).join(\" - \");\r\n  }\r\n  if (moduleId === \"exports\") {\r\n    return [asString(row?.dataset, \"Export Request\"), asString(row?.format)].filter(Boolean).join(\" - \");\r\n  }\r\n  if (moduleId === \"user_accounts\") {\r\n    return asString(row?.email, recordId || \"User Account\");\r\n  }\r\n\r\n  return asString(\r\n    row?.name,\r\n    asString(row?.employee, asString(row?.dataset, asString(row?.email, recordId || `${moduleLabel} Record`))),\r\n  );\r\n}\r\n\r\nfunction toRetentionArchiveRecord({ moduleId, moduleLabel, row, nowMs, dueWithinMs }) {\r\n  const archivedAt = toIsoOrEmpty(row?.archivedAt);\r\n  const retentionDeleteAt = toIsoOrEmpty(row?.retentionDeleteAt);\r\n  const normalizedStatus = normalizeText(row?.status);\r\n  const normalizedArchiveStatus = normalizeText(row?.archiveStatus);\r\n  const isArchived = Boolean(\r\n    row?.isArchived ||\r\n      archivedAt ||\r\n      retentionDeleteAt ||\r\n      normalizedStatus === \"archived\" ||\r\n      normalizedArchiveStatus === \"archived\",\r\n  );\r\n  if (!isArchived) {\r\n    return null;\r\n  }\r\n\r\n  const recordId = asString(row?.recordId, asString(row?.id));\r\n  const retention = deriveRetentionState(retentionDeleteAt, nowMs, dueWithinMs);\r\n  const label = getRetentionRecordLabel(moduleId, row, moduleLabel);\r\n  const ownerEmail = normalizeEmail(row?.employeeEmail || row?.email || row?.requestedBy || row?.ownerEmail);\r\n  const subtitleParts = [\r\n    asString(row?.employeeId),\r\n    ownerEmail,\r\n    asString(row?.department),\r\n    asString(row?.category),\r\n  ].filter(Boolean);\r\n\r\n  return {\r\n    id: `${moduleId}:${recordId || Math.random().toString(36).slice(2, 10)}`,\r\n    moduleId,\r\n    moduleLabel,\r\n    recordId: recordId || \"\",\r\n    title: label,\r\n    subtitle: subtitleParts.join(\" | \"),\r\n    ownerEmail: ownerEmail || \"\",\r\n    status: asString(row?.status, asString(row?.archiveStatus, \"Archived\")),\r\n    archiveReason: asString(row?.archiveReason, asString(row?.reason, asString(row?.reviewNote, \"\"))),\r\n    archivedAt,\r\n    retentionDeleteAt,\r\n    daysToDeletion: retention.daysToDeletion,\r\n    deletionState: retention.state,\r\n    updatedAt: toIsoOrEmpty(row?.updatedAt),\r\n  };\r\n}\r\n\r\nfunction summarizeRetentionRecords(records, { moduleCatalog, nowMs, dueWithinDays }) {\r\n  const dueCounts = {\r\n    due: 0,\r\n    dueSoon: 0,\r\n    scheduled: 0,\r\n    noRetention: 0,\r\n  };\r\n\r\n  const moduleCounts = moduleCatalog.map((module) => ({\r\n    id: module.id,\r\n    label: module.label,\r\n    count: 0,\r\n  }));\r\n  const moduleCountById = new Map(moduleCounts.map((item) => [item.id, item]));\r\n\r\n  let nextDeletionAt = \"\";\r\n  let oldestArchivedAt = \"\";\r\n\r\n  records.forEach((record) => {\r\n    if (record.deletionState === \"due\") {\r\n      dueCounts.due += 1;\r\n    } else if (record.deletionState === \"due_soon\") {\r\n      dueCounts.dueSoon += 1;\r\n    } else if (record.deletionState === \"scheduled\") {\r\n      dueCounts.scheduled += 1;\r\n    } else {\r\n      dueCounts.noRetention += 1;\r\n    }\r\n\r\n    const moduleCount = moduleCountById.get(record.moduleId);\r\n    if (moduleCount) {\r\n      moduleCount.count += 1;\r\n    }\r\n\r\n    if (record.retentionDeleteAt) {\r\n      if (!nextDeletionAt || toTimeMs(record.retentionDeleteAt) < toTimeMs(nextDeletionAt)) {\r\n        nextDeletionAt = record.retentionDeleteAt;\r\n      }\r\n    }\r\n\r\n    if (record.archivedAt) {\r\n      if (!oldestArchivedAt || toTimeMs(record.archivedAt) < toTimeMs(oldestArchivedAt)) {\r\n        oldestArchivedAt = record.archivedAt;\r\n      }\r\n    }\r\n  });\r\n\r\n  return {\r\n    generatedAt: new Date(nowMs).toISOString(),\r\n    totalArchived: records.length,\r\n    dueNow: dueCounts.due,\r\n    dueWithinWindow: dueCounts.due + dueCounts.dueSoon,\r\n    scheduledFuture: dueCounts.scheduled,\r\n    missingRetentionDate: dueCounts.noRetention,\r\n    nextDeletionAt: nextDeletionAt || null,\r\n    oldestArchivedAt: oldestArchivedAt || null,\r\n    dueWithinDays,\r\n    moduleBreakdown: moduleCounts.sort((left, right) => right.count - left.count),\r\n  };\r\n}\r\n\r\nfunction sortRetentionRecords(records) {\r\n  const stateRank = {\r\n    due: 0,\r\n    due_soon: 1,\r\n    scheduled: 2,\r\n    no_retention: 3,\r\n  };\r\n\r\n  return [...records].sort((left, right) => {\r\n    const leftRank = stateRank[left.deletionState] ?? 9;\r\n    const rightRank = stateRank[right.deletionState] ?? 9;\r\n    if (leftRank !== rightRank) {\r\n      return leftRank - rightRank;\r\n    }\r\n\r\n    const leftRetention = toTimeMs(left.retentionDeleteAt);\r\n    const rightRetention = toTimeMs(right.retentionDeleteAt);\r\n    if (Number.isFinite(leftRetention) && Number.isFinite(rightRetention) && leftRetention !== rightRetention) {\r\n      return leftRetention - rightRetention;\r\n    }\r\n    if (Number.isFinite(leftRetention) && !Number.isFinite(rightRetention)) {\r\n      return -1;\r\n    }\r\n    if (!Number.isFinite(leftRetention) && Number.isFinite(rightRetention)) {\r\n      return 1;\r\n    }\r\n\r\n    return (toTimeMs(right.archivedAt) || 0) - (toTimeMs(left.archivedAt) || 0);\r\n  });\r\n}\r\n\r\nexport async function listRetentionArchiveSnapshotBackend({\r\n  moduleId = \"all\",\r\n  status = \"all\",\r\n  queryText = \"\",\r\n  dueWithinDays = 30,\r\n  now,\r\n} = {}) {\r\n  const normalizedModuleId = normalizeText(moduleId) || \"all\";\r\n  const normalizedStatus = normalizeText(status) || \"all\";\r\n  const normalizedQuery = normalizeText(queryText);\r\n  const retentionYears = getArchiveRetentionYears();\r\n  const safeDueWithinDays = clampInt(dueWithinDays, 30, { min: 1, max: 365 });\r\n  const nowIsoValue = toIsoOrEmpty(now) || nowIso();\r\n  const nowMs = toTimeMs(nowIsoValue) || Date.now();\r\n  const dueWithinMs = safeDueWithinDays * 24 * 60 * 60 * 1000;\r\n\r\n  const moduleCatalog = [\r\n    { id: \"employees\", label: \"Employee Records\", loader: () => listEmployeeRecordsBackend() },\r\n    { id: \"lifecycle\", label: \"Employment Lifecycle\", loader: () => listLifecycleRecordsBackend() },\r\n    { id: \"attendance\", label: \"Attendance\", loader: () => listAttendanceLogsBackend() },\r\n    { id: \"leave\", label: \"Leave Requests\", loader: () => listLeaveRequestsBackend() },\r\n    { id: \"performance\", label: \"Performance\", loader: () => listPerformanceRecordsBackend() },\r\n    { id: \"exports\", label: \"Reports & Exports\", loader: () => listExportRequestsBackend() },\r\n    { id: \"user_accounts\", label: \"User Accounts\", loader: () => listUserAccounts() },\r\n  ];\r\n\r\n  const moduleIds = new Set(moduleCatalog.map((item) => item.id));\r\n  if (normalizedModuleId !== \"all\" && !moduleIds.has(normalizedModuleId)) {\r\n    throw new Error(\"invalid_retention_module\");\r\n  }\r\n\r\n  const supportedStatusFilters = new Set([\"all\", \"due\", \"due_soon\", \"scheduled\", \"no_retention\"]);\r\n  const effectiveStatus = supportedStatusFilters.has(normalizedStatus) ? normalizedStatus : \"all\";\r\n\r\n  const loaded = await Promise.all(\r\n    moduleCatalog.map(async (module) => {\r\n      const rows = await module.loader();\r\n      return {\r\n        ...module,\r\n        rows: Array.isArray(rows) ? rows : [],\r\n      };\r\n    }),\r\n  );\r\n\r\n  const archivedRecords = loaded.flatMap((module) =>\r\n    module.rows\r\n      .map((row) =>\r\n        toRetentionArchiveRecord({\r\n          moduleId: module.id,\r\n          moduleLabel: module.label,\r\n          row,\r\n          nowMs,\r\n          dueWithinMs,\r\n        }),\r\n      )\r\n      .filter(Boolean),\r\n  );\r\n\r\n  const moduleScopedRecords =\r\n    normalizedModuleId === \"all\"\r\n      ? archivedRecords\r\n      : archivedRecords.filter((record) => record.moduleId === normalizedModuleId);\r\n\r\n  const filteredRecords = moduleScopedRecords.filter((record) => {\r\n    const byStatus = effectiveStatus === \"all\" ? true : record.deletionState === effectiveStatus;\r\n    const textBlob = normalizeText(\r\n      [\r\n        record.moduleLabel,\r\n        record.recordId,\r\n        record.title,\r\n        record.subtitle,\r\n        record.ownerEmail,\r\n        record.archiveReason,\r\n      ].join(\" \"),\r\n    );\r\n    const byQuery = normalizedQuery ? textBlob.includes(normalizedQuery) : true;\r\n    return byStatus && byQuery;\r\n  });\r\n\r\n  return {\r\n    policy: {\r\n      retentionYears,\r\n      dueWithinDays: safeDueWithinDays,\r\n      generatedAt: nowIsoValue,\r\n      moduleCatalog: moduleCatalog.map((module) => ({\r\n        id: module.id,\r\n        label: module.label,\r\n      })),\r\n    },\r\n    summary: summarizeRetentionRecords(moduleScopedRecords, {\r\n      moduleCatalog,\r\n      nowMs,\r\n      dueWithinDays: safeDueWithinDays,\r\n    }),\r\n    records: sortRetentionRecords(filteredRecords),\r\n  };\r\n}\r\n","function normalizeEmailProvider(rawValue) {\r\n  const raw = String(rawValue || \"\")\r\n    .trim()\r\n    .toLowerCase();\r\n  if (!raw) {\r\n    return \"\";\r\n  }\r\n\r\n  if (raw === \"firebase\" || raw.includes(\"firebase\")) {\r\n    return \"firebase\";\r\n  }\r\n\r\n  if (raw === \"resend\" || raw.includes(\"resend\")) {\r\n    return \"resend\";\r\n  }\r\n\r\n  if (raw === \"console\" || raw === \"dev\" || raw.includes(\"console\")) {\r\n    return \"console\";\r\n  }\r\n\r\n  return raw;\r\n}\r\n\r\nfunction getEmailProvider() {\r\n  const configured = normalizeEmailProvider(process.env.CLIO_EMAIL_PROVIDER);\r\n  if (configured) {\r\n    return configured;\r\n  }\r\n\r\n  const hasResendConfig =\r\n    String(process.env.RESEND_API_KEY || \"\").trim().startsWith(\"re_\") &&\r\n    String(process.env.CLIO_EMAIL_FROM || \"\").trim().length > 0;\r\n  if (hasResendConfig) {\r\n    return \"resend\";\r\n  }\r\n\r\n  return \"firebase\";\r\n}\r\n\r\nfunction isConsoleEmailAllowed() {\r\n  return String(process.env.CLIO_ALLOW_CONSOLE_EMAIL || \"\")\r\n    .trim()\r\n    .toLowerCase() === \"true\";\r\n}\r\n\r\nfunction normalizeBaseUrl(value) {\r\n  const raw = String(value || \"\").trim();\r\n  if (!raw) {\r\n    return \"\";\r\n  }\r\n\r\n  if (raw.startsWith(\"http://\") || raw.startsWith(\"https://\")) {\r\n    return raw.replace(/\\/+$/, \"\");\r\n  }\r\n\r\n  return `https://${raw.replace(/^\\/+/, \"\").replace(/\\/+$/, \"\")}`;\r\n}\r\n\r\nfunction assertSafeProductionBaseUrl(baseUrl) {\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    return;\r\n  }\r\n\r\n  let parsed;\r\n  try {\r\n    parsed = new URL(baseUrl);\r\n  } catch {\r\n    throw new Error(\"app_base_url_not_configured\");\r\n  }\r\n\r\n  const hostname = String(parsed.hostname || \"\").trim().toLowerCase();\r\n  const isLocalHost =\r\n    hostname === \"localhost\" ||\r\n    hostname === \"127.0.0.1\" ||\r\n    hostname === \"::1\" ||\r\n    hostname.endsWith(\".local\");\r\n\r\n  if (isLocalHost) {\r\n    throw new Error(\"unsafe_app_base_url_for_production\");\r\n  }\r\n}\r\n\r\nfunction getAppBaseUrl({ requestOrigin } = {}) {\r\n  const requestOriginUrl = normalizeBaseUrl(requestOrigin);\r\n  const firebaseAuthDomain = normalizeBaseUrl(\r\n    process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN || process.env.FIREBASE_AUTH_DOMAIN,\r\n  );\r\n  const vercelUrl = normalizeBaseUrl(\r\n    process.env.VERCEL_PROJECT_PRODUCTION_URL || process.env.VERCEL_URL,\r\n  );\r\n  const configured = normalizeBaseUrl(process.env.CLIO_APP_BASE_URL);\r\n  const publicSiteUrl = normalizeBaseUrl(process.env.NEXT_PUBLIC_APP_URL);\r\n\r\n  const candidates =\r\n    process.env.NODE_ENV === \"production\"\r\n      ? [requestOriginUrl, configured, publicSiteUrl, vercelUrl, firebaseAuthDomain]\r\n      : [requestOriginUrl, configured, publicSiteUrl, firebaseAuthDomain, vercelUrl];\r\n\r\n  for (const candidate of candidates) {\r\n    if (!candidate) {\r\n      continue;\r\n    }\r\n    assertSafeProductionBaseUrl(candidate);\r\n    return candidate;\r\n  }\r\n\r\n  throw new Error(\"app_base_url_not_configured\");\r\n}\r\n\r\nfunction getLoginPath() {\r\n  const configured = String(process.env.CLIO_LOGIN_PATH || \"\").trim();\r\n  if (!configured) {\r\n    return \"/login\";\r\n  }\r\n  return configured.startsWith(\"/\") ? configured : `/${configured}`;\r\n}\r\n\r\nfunction getInviteVerifyPath() {\r\n  const configured = String(process.env.CLIO_INVITE_VERIFY_PATH || \"\").trim();\r\n  if (!configured) {\r\n    return \"/verify-invite\";\r\n  }\r\n  return configured.startsWith(\"/\") ? configured : `/${configured}`;\r\n}\r\n\r\nfunction buildLoginUrl(baseUrl) {\r\n  return `${baseUrl}${getLoginPath()}`;\r\n}\r\n\r\nfunction buildInviteVerificationUrl(inviteToken, baseUrl) {\r\n  const path = getInviteVerifyPath();\r\n  const token = String(inviteToken || \"\").trim();\r\n  if (!token) {\r\n    throw new Error(\"invalid_invite_token\");\r\n  }\r\n  return `${baseUrl}${path}?token=${encodeURIComponent(token)}`;\r\n}\r\n\r\nfunction isDevelopmentPreviewEnabled() {\r\n  return process.env.NODE_ENV !== \"production\";\r\n}\r\n\r\nfunction escapeHtml(value) {\r\n  return String(value || \"\")\r\n    .replaceAll(\"&\", \"&amp;\")\r\n    .replaceAll(\"<\", \"&lt;\")\r\n    .replaceAll(\">\", \"&gt;\")\r\n    .replaceAll('\"', \"&quot;\")\r\n    .replaceAll(\"'\", \"&#39;\");\r\n}\r\n\r\nfunction buildEmailContent({ role, invitedBy, verifyUrl, loginUrl, expiresAt }) {\r\n  const expirationDate = new Date(expiresAt);\r\n  const readableExpiration = Number.isNaN(expirationDate.getTime())\r\n    ? expiresAt\r\n    : expirationDate.toLocaleString(\"en-US\", {\r\n        month: \"short\",\r\n        day: \"2-digit\",\r\n        year: \"numeric\",\r\n        hour: \"2-digit\",\r\n        minute: \"2-digit\",\r\n      });\r\n\r\n  const roleText = String(role || \"Employee\").trim() || \"Employee\";\r\n  const invitedByText = String(invitedBy || \"CLIO Administrator\").trim() || \"CLIO Administrator\";\r\n  const brandDomain = String(process.env.CLIO_EMAIL_BRAND_DOMAIN || \"cisoasaservice.io\").trim() || \"cisoasaservice.io\";\r\n  const safeRole = escapeHtml(roleText);\r\n  const safeInvitedBy = escapeHtml(invitedByText);\r\n  const safeVerifyUrl = escapeHtml(verifyUrl);\r\n  const safeLoginUrl = escapeHtml(loginUrl);\r\n  const safeReadableExpiration = escapeHtml(readableExpiration);\r\n  const safeBrandDomain = escapeHtml(brandDomain);\r\n\r\n  const subject = \"You're invited to verify your email and open your Clio account\";\r\n  const text = [\r\n    \"You have been invited to Clio Secured HRIS.\",\r\n    \"\",\r\n    \"To open your account, please verify your email first.\",\r\n    `Verify your Clio account: ${verifyUrl}`,\r\n    `Sign in after verification: ${loginUrl}`,\r\n    \"\",\r\n    `Assigned role: ${roleText}`,\r\n    `Invited by: ${invitedByText}`,\r\n    `Invitation expires: ${readableExpiration}`,\r\n    \"\",\r\n    \"For security, complete SMS OTP after email verification.\",\r\n    \"Use the same invited work email when signing in.\",\r\n    \"\",\r\n    `Domain: ${brandDomain}`,\r\n  ].join(\"\\n\");\r\n\r\n  return {\r\n    subject,\r\n    text,\r\n    html: [\r\n      \"<div style=\\\"font-family:Arial,sans-serif;line-height:1.6;color:#0f172a;max-width:620px\\\">\",\r\n      \"<p style=\\\"margin:0 0 12px 0\\\">Hello,</p>\",\r\n      \"<p style=\\\"margin:0 0 12px 0\\\">You have been invited to <strong>Clio Secured HRIS</strong>.</p>\",\r\n      \"<p style=\\\"margin:0 0 16px 0\\\">To open your account, please verify your email and complete secure onboarding.</p>\",\r\n      `<p style=\"margin:0 0 16px 0\"><a href=\"${safeVerifyUrl}\" style=\"display:inline-block;background:#0f6bcf;color:#ffffff;text-decoration:none;padding:10px 18px;border-radius:10px;font-weight:600\">Verify Clio Account</a></p>`,\r\n      `<p style=\"margin:0 0 12px 0\"><strong>Assigned role:</strong> ${safeRole}<br/>`,\r\n      `<strong>Invited by:</strong> ${safeInvitedBy}<br/>`,\r\n      `<strong>Invitation expires:</strong> ${safeReadableExpiration}</p>`,\r\n      `<p style=\"margin:0 0 12px 0\">After verification, sign in here: <a href=\"${safeLoginUrl}\">${safeLoginUrl}</a></p>`,\r\n      `<p style=\"margin:0 0 12px 0\">For security, complete SMS OTP after email verification and use the same invited work email.</p>`,\r\n      `<p style=\"margin:0;color:#475569;font-size:12px\">This invitation is intended for authorized recipients of ${safeBrandDomain}.</p>`,\r\n      \"</div>\",\r\n    ].join(\"\"),\r\n  };\r\n}\r\n\r\nfunction parseFirebaseAuthError(payload) {\r\n  const code = String(payload?.error?.message || \"\").trim();\r\n  if (!code) {\r\n    return \"email_delivery_failed\";\r\n  }\r\n  if (code === \"OPERATION_NOT_ALLOWED\") {\r\n    return \"firebase_email_provider_not_enabled\";\r\n  }\r\n  if (code === \"MISSING_CONTINUE_URI\" || code === \"INVALID_CONTINUE_URI\") {\r\n    return \"firebase_continue_url_invalid\";\r\n  }\r\n  if (code === \"INVALID_EMAIL\") {\r\n    return \"invalid_email\";\r\n  }\r\n  if (code === \"PROJECT_NOT_FOUND\" || code === \"API_KEY_INVALID\") {\r\n    return \"firebase_api_key_not_configured\";\r\n  }\r\n  return \"email_delivery_failed\";\r\n}\r\n\r\nasync function sendViaFirebaseAuth({ toEmail, verifyUrl }) {\r\n  const apiKey = String(process.env.NEXT_PUBLIC_FIREBASE_API_KEY || \"\").trim();\r\n  if (!apiKey) {\r\n    throw new Error(\"firebase_api_key_not_configured\");\r\n  }\r\n\r\n  const response = await fetch(`https://identitytoolkit.googleapis.com/v1/accounts:sendOobCode?key=${apiKey}`, {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n    body: JSON.stringify({\r\n      requestType: \"EMAIL_SIGNIN\",\r\n      email: toEmail,\r\n      continueUrl: verifyUrl,\r\n      canHandleCodeInApp: true,\r\n    }),\r\n  });\r\n\r\n  const payload = await response.json().catch(() => ({}));\r\n  if (!response.ok) {\r\n    throw new Error(parseFirebaseAuthError(payload));\r\n  }\r\n\r\n  return {\r\n    provider: \"firebase\",\r\n    status: \"sent\",\r\n    messageId: `firebase-${Date.now()}`,\r\n  };\r\n}\r\n\r\nasync function sendViaResend({ toEmail, subject, html, text }) {\r\n  const apiKey = String(process.env.RESEND_API_KEY || \"\").trim();\r\n  const fromAddress = String(process.env.CLIO_EMAIL_FROM || \"\").trim();\r\n  if (!apiKey || !fromAddress || !apiKey.startsWith(\"re_\")) {\r\n    throw new Error(\"email_provider_not_configured\");\r\n  }\r\n\r\n  const response = await fetch(\"https://api.resend.com/emails\", {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n      Authorization: `Bearer ${apiKey}`,\r\n    },\r\n    body: JSON.stringify({\r\n      from: fromAddress,\r\n      to: [toEmail],\r\n      subject,\r\n      html,\r\n      text,\r\n    }),\r\n  });\r\n\r\n  if (!response.ok) {\r\n    const payload = await response.json().catch(() => ({}));\r\n    const providerMessage =\r\n      typeof payload?.message === \"string\"\r\n        ? payload.message\r\n        : typeof payload?.error?.message === \"string\"\r\n          ? payload.error.message\r\n          : \"\";\r\n    throw new Error(\r\n      providerMessage ? `email_delivery_failed:${providerMessage}` : \"email_delivery_failed\",\r\n    );\r\n  }\r\n\r\n  const payload = await response.json().catch(() => ({}));\r\n  return {\r\n    provider: \"resend\",\r\n    status: \"sent\",\r\n    messageId: typeof payload?.id === \"string\" ? payload.id : `resend-${Date.now()}`,\r\n  };\r\n}\r\n\r\nfunction sendViaConsole({ toEmail, subject, verifyUrl, loginUrl }) {\r\n  const messageId = `console-${Date.now()}`;\r\n  if (isDevelopmentPreviewEnabled()) {\r\n    console.info(\"[CLIO:InviteEmail]\", {\r\n      toEmail,\r\n      subject,\r\n      verifyUrl,\r\n      loginUrl,\r\n      messageId,\r\n    });\r\n  }\r\n\r\n  return {\r\n    provider: \"console\",\r\n    status: \"simulated\",\r\n    messageId,\r\n    previewUrl: verifyUrl,\r\n    loginUrl,\r\n  };\r\n}\r\n\r\nexport async function deliverInviteEmail({\r\n  toEmail,\r\n  role,\r\n  invitedBy,\r\n  expiresAt,\r\n  inviteToken,\r\n  requestOrigin = \"\",\r\n}) {\r\n  const baseUrl = getAppBaseUrl({ requestOrigin });\r\n  const verifyUrl = buildInviteVerificationUrl(inviteToken, baseUrl);\r\n  const loginUrl = buildLoginUrl(baseUrl);\r\n  const content = buildEmailContent({\r\n    role,\r\n    invitedBy,\r\n    verifyUrl,\r\n    loginUrl,\r\n    expiresAt,\r\n  });\r\n  const provider = getEmailProvider();\r\n\r\n  if (provider === \"firebase\") {\r\n    return await sendViaFirebaseAuth({\r\n      toEmail,\r\n      verifyUrl,\r\n    });\r\n  }\r\n\r\n  if (provider === \"resend\") {\r\n    return await sendViaResend({\r\n      toEmail,\r\n      subject: content.subject,\r\n      html: content.html,\r\n      text: content.text,\r\n    });\r\n  }\r\n\r\n  if (provider === \"console\") {\r\n    if (!isConsoleEmailAllowed()) {\r\n      throw new Error(\"email_provider_not_configured\");\r\n    }\r\n\r\n    return sendViaConsole({\r\n      toEmail,\r\n      subject: content.subject,\r\n      verifyUrl,\r\n      loginUrl,\r\n    });\r\n  }\r\n\r\n  throw new Error(\"unsupported_email_provider\");\r\n}\r\n","import {\r\n  addDoc,\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  limit as queryLimit,\r\n  orderBy,\r\n  query,\r\n  updateDoc,\r\n} from \"firebase/firestore/lite\";\r\nimport { getFirestoreDb, isFirestoreEnabled } from \"@/lib/firebase\";\r\nimport { listUserAccounts } from \"@/lib/user-accounts\";\r\n\r\nconst DEFAULT_LIST_LIMIT = 20;\r\nconst MAX_LIST_LIMIT = 120;\r\nconst MAX_READ_ALL_LIMIT = 300;\r\n\r\nfunction nowIso() {\r\n  return new Date().toISOString();\r\n}\r\n\r\nfunction asString(value, fallback = \"\") {\r\n  const normalized = String(value || \"\").trim();\r\n  return normalized || fallback;\r\n}\r\n\r\nfunction asBoolean(value, fallback = false) {\r\n  if (typeof value === \"boolean\") {\r\n    return value;\r\n  }\r\n  if (typeof value === \"number\") {\r\n    return value !== 0;\r\n  }\r\n  if (typeof value === \"string\") {\r\n    const normalized = value.trim().toLowerCase();\r\n    if (!normalized) {\r\n      return fallback;\r\n    }\r\n    if ([\"true\", \"1\", \"yes\", \"on\", \"y\"].includes(normalized)) {\r\n      return true;\r\n    }\r\n    if ([\"false\", \"0\", \"no\", \"off\", \"n\"].includes(normalized)) {\r\n      return false;\r\n    }\r\n  }\r\n  return fallback;\r\n}\r\n\r\nfunction asObject(value) {\r\n  if (value && typeof value === \"object\" && !Array.isArray(value)) {\r\n    return value;\r\n  }\r\n  return {};\r\n}\r\n\r\nfunction asArray(value) {\r\n  return Array.isArray(value) ? value : [];\r\n}\r\n\r\nfunction clampInt(value, fallback, { min = 1, max = Number.MAX_SAFE_INTEGER } = {}) {\r\n  const parsed = Number.parseInt(String(value || \"\"), 10);\r\n  if (!Number.isFinite(parsed)) {\r\n    return fallback;\r\n  }\r\n  return Math.min(max, Math.max(min, parsed));\r\n}\r\n\r\nfunction normalizeEmail(value) {\r\n  return String(value || \"\").trim().toLowerCase();\r\n}\r\n\r\nfunction normalizeText(value) {\r\n  return String(value || \"\").trim().toLowerCase();\r\n}\r\n\r\nfunction parseEmailList(rawValue) {\r\n  return String(rawValue || \"\")\r\n    .split(\",\")\r\n    .map((item) => normalizeEmail(item))\r\n    .filter(Boolean);\r\n}\r\n\r\nfunction normalizeSeverity(value) {\r\n  const normalized = String(value || \"\").trim().toLowerCase();\r\n  if (normalized === \"critical\") return \"critical\";\r\n  if (normalized === \"high\") return \"high\";\r\n  if (normalized === \"low\") return \"low\";\r\n  return \"medium\";\r\n}\r\n\r\nfunction normalizeNotificationStatus(value) {\r\n  return String(value || \"\").trim().toLowerCase() === \"read\" ? \"read\" : \"unread\";\r\n}\r\n\r\nfunction getNotificationsCollectionName() {\r\n  return asString(process.env.CLIO_FIRESTORE_NOTIFICATIONS_COLLECTION, \"clio_notifications\");\r\n}\r\n\r\nfunction getFirestoreStore() {\r\n  if (!isFirestoreEnabled()) {\r\n    return null;\r\n  }\r\n  return getFirestoreDb();\r\n}\r\n\r\nfunction toNotificationRecord(snapshot) {\r\n  const payload = snapshot.data() || {};\r\n  return {\r\n    ...payload,\r\n    id: snapshot.id,\r\n    recordId: snapshot.id,\r\n  };\r\n}\r\n\r\nfunction isVisibleNotification(row, recipientEmail) {\r\n  const recipient = normalizeEmail(recipientEmail);\r\n  const owner = normalizeEmail(row?.recipientEmail);\r\n  const broadcast = asBoolean(row?.broadcast, false);\r\n  return broadcast || (recipient && owner && recipient === owner);\r\n}\r\n\r\nfunction sortByCreatedDesc(left, right) {\r\n  return new Date(right?.createdAt || 0).getTime() - new Date(left?.createdAt || 0).getTime();\r\n}\r\n\r\nfunction normalizeNotificationPayload(payload) {\r\n  const now = nowIso();\r\n  const recipientEmail = normalizeEmail(payload?.recipientEmail);\r\n  const broadcast = asBoolean(payload?.broadcast, false);\r\n  if (!recipientEmail && !broadcast) {\r\n    throw new Error(\"invalid_notification_recipient\");\r\n  }\r\n\r\n  return {\r\n    title: asString(payload?.title, \"Security notification\"),\r\n    message: asString(payload?.message, \"A security event requires review.\"),\r\n    severity: normalizeSeverity(payload?.severity),\r\n    type: asString(payload?.type, \"security\"),\r\n    module: asString(payload?.module, \"Incident Management\"),\r\n    actionUrl: asString(payload?.actionUrl, \"/incident-management\"),\r\n    recipientEmail,\r\n    broadcast,\r\n    status: normalizeNotificationStatus(payload?.status),\r\n    metadata: asObject(payload?.metadata),\r\n    createdAt: asString(payload?.createdAt, now),\r\n    updatedAt: asString(payload?.updatedAt, now),\r\n    readAt: asString(payload?.readAt, \"\"),\r\n    createdBy: normalizeEmail(payload?.createdBy),\r\n  };\r\n}\r\n\r\nexport async function createInAppNotification(payload) {\r\n  const db = getFirestoreStore();\r\n  if (!db) {\r\n    return null;\r\n  }\r\n\r\n  const normalized = normalizeNotificationPayload(payload);\r\n  const ref = await addDoc(collection(db, getNotificationsCollectionName()), normalized);\r\n  return {\r\n    ...normalized,\r\n    id: ref.id,\r\n    recordId: ref.id,\r\n  };\r\n}\r\n\r\nexport async function createInAppNotificationsBulk(payloads) {\r\n  const entries = asArray(payloads);\r\n  if (entries.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  const created = [];\r\n  for (const payload of entries) {\r\n    const result = await createInAppNotification(payload);\r\n    if (result) {\r\n      created.push(result);\r\n    }\r\n  }\r\n  return created;\r\n}\r\n\r\nexport async function getInAppNotificationForRecipient(recordId, recipientEmail) {\r\n  const db = getFirestoreStore();\r\n  if (!db) {\r\n    return null;\r\n  }\r\n\r\n  const normalizedId = asString(recordId);\r\n  if (!normalizedId) {\r\n    throw new Error(\"invalid_record_id\");\r\n  }\r\n\r\n  const ref = doc(db, getNotificationsCollectionName(), normalizedId);\r\n  const snapshot = await getDoc(ref);\r\n  if (!snapshot.exists()) {\r\n    return null;\r\n  }\r\n\r\n  const current = toNotificationRecord(snapshot);\r\n  if (!isVisibleNotification(current, recipientEmail)) {\r\n    throw new Error(\"forbidden_notification_access\");\r\n  }\r\n\r\n  return current;\r\n}\r\n\r\nexport async function listInAppNotifications({\r\n  recipientEmail,\r\n  status = \"all\",\r\n  limit = DEFAULT_LIST_LIMIT,\r\n} = {}) {\r\n  const db = getFirestoreStore();\r\n  if (!db) {\r\n    return {\r\n      records: [],\r\n      unreadCount: 0,\r\n      totalScoped: 0,\r\n    };\r\n  }\r\n\r\n  const normalizedStatus = String(status || \"\").trim().toLowerCase();\r\n  const safeLimit = clampInt(limit, DEFAULT_LIST_LIMIT, { min: 1, max: MAX_LIST_LIMIT });\r\n  const scanLimit = Math.max(safeLimit * 4, 100);\r\n\r\n  const snapshot = await getDocs(\r\n    query(\r\n      collection(db, getNotificationsCollectionName()),\r\n      orderBy(\"createdAt\", \"desc\"),\r\n      queryLimit(scanLimit),\r\n    ),\r\n  );\r\n\r\n  const scoped = snapshot.docs.map(toNotificationRecord).filter((row) => isVisibleNotification(row, recipientEmail));\r\n  const unreadCount = scoped.reduce((count, row) => count + (normalizeNotificationStatus(row?.status) === \"unread\" ? 1 : 0), 0);\r\n\r\n  const statusFiltered = scoped.filter((row) => {\r\n    if (normalizedStatus === \"all\" || !normalizedStatus) {\r\n      return true;\r\n    }\r\n    return normalizeNotificationStatus(row?.status) === normalizedStatus;\r\n  });\r\n\r\n  return {\r\n    records: statusFiltered.sort(sortByCreatedDesc).slice(0, safeLimit),\r\n    unreadCount,\r\n    totalScoped: scoped.length,\r\n  };\r\n}\r\n\r\nexport async function markInAppNotificationRead(recordId, recipientEmail) {\r\n  const db = getFirestoreStore();\r\n  if (!db) {\r\n    return null;\r\n  }\r\n\r\n  const normalizedId = asString(recordId);\r\n  if (!normalizedId) {\r\n    throw new Error(\"invalid_record_id\");\r\n  }\r\n\r\n  const ref = doc(db, getNotificationsCollectionName(), normalizedId);\r\n  const snapshot = await getDoc(ref);\r\n  if (!snapshot.exists()) {\r\n    return null;\r\n  }\r\n\r\n  const current = toNotificationRecord(snapshot);\r\n  if (!isVisibleNotification(current, recipientEmail)) {\r\n    throw new Error(\"forbidden_notification_access\");\r\n  }\r\n\r\n  if (normalizeNotificationStatus(current.status) === \"read\") {\r\n    return current;\r\n  }\r\n\r\n  const patched = {\r\n    ...current,\r\n    status: \"read\",\r\n    readAt: nowIso(),\r\n    updatedAt: nowIso(),\r\n  };\r\n  await updateDoc(ref, patched);\r\n  return patched;\r\n}\r\n\r\nexport async function resolveDeviceVerificationNotification(recordId, recipientEmail, decision) {\n  const db = getFirestoreStore();\r\n  if (!db) {\r\n    return null;\r\n  }\r\n\r\n  const normalizedId = asString(recordId);\r\n  if (!normalizedId) {\r\n    throw new Error(\"invalid_record_id\");\r\n  }\r\n\r\n  const normalizedRecipient = normalizeEmail(recipientEmail);\r\n  const normalizedDecision = asString(decision).toLowerCase();\r\n  if (normalizedDecision !== \"confirm\" && normalizedDecision !== \"deny\") {\r\n    throw new Error(\"invalid_device_verification_decision\");\r\n  }\r\n\r\n  const ref = doc(db, getNotificationsCollectionName(), normalizedId);\r\n  const snapshot = await getDoc(ref);\r\n  if (!snapshot.exists()) {\r\n    return null;\r\n  }\r\n\r\n  const current = toNotificationRecord(snapshot);\n  if (!isVisibleNotification(current, normalizedRecipient)) {\n    throw new Error(\"forbidden_notification_access\");\n  }\n\n  const metadata = asObject(current?.metadata);\n  const existingDecision = asString(metadata?.deviceVerificationDecision).toLowerCase();\n  if (existingDecision) {\n    if (existingDecision === normalizedDecision) {\n      return current;\n    }\n    throw new Error(\"device_verification_already_resolved\");\n  }\n\n  const now = nowIso();\n  const patched = {\n    ...current,\n    status: \"read\",\n    readAt: asString(current?.readAt, now),\r\n    updatedAt: now,\r\n    metadata: {\r\n      ...metadata,\r\n      deviceVerificationDecision: normalizedDecision,\r\n      deviceVerificationResolvedAt: now,\r\n      deviceVerificationResponder: normalizedRecipient,\r\n    },\r\n  };\r\n\r\n  await updateDoc(ref, patched);\r\n  return patched;\r\n}\r\n\r\nexport async function markAllInAppNotificationsRead({ recipientEmail, limit = 120 } = {}) {\r\n  const normalizedRecipient = normalizeEmail(recipientEmail);\r\n  if (!normalizedRecipient) {\r\n    return {\r\n      updatedCount: 0,\r\n    };\r\n  }\r\n\r\n  const db = getFirestoreStore();\r\n  if (!db) {\r\n    return {\r\n      updatedCount: 0,\r\n    };\r\n  }\r\n\r\n  const safeLimit = clampInt(limit, 120, { min: 1, max: MAX_READ_ALL_LIMIT });\r\n  const { records } = await listInAppNotifications({\r\n    recipientEmail: normalizedRecipient,\r\n    status: \"unread\",\r\n    limit: safeLimit,\r\n  });\r\n\r\n  let updatedCount = 0;\r\n  for (const row of records) {\r\n    const recordId = asString(row?.id || row?.recordId);\r\n    if (!recordId) {\r\n      continue;\r\n    }\r\n    const ref = doc(db, getNotificationsCollectionName(), recordId);\r\n    await updateDoc(ref, {\r\n      status: \"read\",\r\n      readAt: nowIso(),\r\n      updatedAt: nowIso(),\r\n    });\r\n    updatedCount += 1;\r\n  }\r\n\r\n  return {\r\n    updatedCount,\r\n  };\r\n}\r\n\r\nexport function resolveNotificationRecipients(values = []) {\r\n  return Array.from(\r\n    new Set(\r\n      asArray(values)\r\n        .map((value) => normalizeEmail(value))\r\n        .filter(Boolean),\r\n    ),\r\n  );\r\n}\r\n\r\nexport async function resolveIncidentStakeholderRecipients({\r\n  ownerEmail,\r\n  affectedEmployeeEmail,\r\n  actorEmail,\r\n  includeAffectedEmployee = true,\r\n  includeActor = false,\r\n} = {}) {\r\n  const baseRecipients = [\r\n    normalizeEmail(process.env.CLIO_GRC_ALERT_EMAIL),\r\n    ...parseEmailList(process.env.GRC_EMAILS),\r\n    normalizeEmail(ownerEmail),\r\n  ];\r\n\r\n  if (includeAffectedEmployee) {\r\n    baseRecipients.push(normalizeEmail(affectedEmployeeEmail));\r\n  }\r\n  if (includeActor) {\r\n    baseRecipients.push(normalizeEmail(actorEmail));\r\n  }\r\n\r\n  let dynamicRoleRecipients = [];\r\n  try {\r\n    const users = await listUserAccounts();\r\n    dynamicRoleRecipients = asArray(users)\r\n      .filter((user) => normalizeEmail(user?.email))\r\n      .filter((user) => normalizeText(user?.status) === \"active\")\r\n      .filter((user) => {\r\n        const role = String(user?.role || \"\").trim().toUpperCase();\r\n        return role === \"GRC\";\r\n      })\r\n      .map((user) => normalizeEmail(user?.email));\r\n  } catch {\r\n    dynamicRoleRecipients = [];\r\n  }\r\n\r\n  return resolveNotificationRecipients([...baseRecipients, ...dynamicRoleRecipients]);\r\n}\r\n\r\nexport async function resolveGrcRecipients() {\r\n  const baseRecipients = [\r\n    normalizeEmail(process.env.CLIO_GRC_ALERT_EMAIL),\r\n    ...parseEmailList(process.env.GRC_EMAILS),\r\n  ];\r\n\r\n  let dynamicRoleRecipients = [];\r\n  try {\r\n    const users = await listUserAccounts();\r\n    dynamicRoleRecipients = asArray(users)\r\n      .filter((user) => normalizeEmail(user?.email))\r\n      .filter((user) => normalizeText(user?.status) === \"active\")\r\n      .filter((user) => String(user?.role || \"\").trim().toUpperCase() === \"GRC\")\r\n      .map((user) => normalizeEmail(user?.email));\r\n  } catch {\r\n    dynamicRoleRecipients = [];\r\n  }\r\n\r\n  return resolveNotificationRecipients([...baseRecipients, ...dynamicRoleRecipients]);\r\n}\r\n","const RESEND_API_BASE = \"https://api.resend.com\";\r\nconst TWILIO_API_BASE = \"https://api.twilio.com/2010-04-01\";\r\n\r\nfunction asString(value, fallback = \"\") {\r\n  const normalized = String(value || \"\").trim();\r\n  return normalized || fallback;\r\n}\r\n\r\nfunction asArray(value) {\r\n  return Array.isArray(value) ? value : [];\r\n}\r\n\r\nfunction parseBooleanEnv(name, fallbackValue = false) {\r\n  const raw = asString(process.env[name]).toLowerCase();\r\n  if (!raw) {\r\n    return fallbackValue;\r\n  }\r\n  return raw === \"true\" || raw === \"1\" || raw === \"yes\";\r\n}\r\n\r\nfunction normalizeEmail(value) {\r\n  return asString(value).toLowerCase();\r\n}\r\n\r\nfunction normalizePhone(value) {\r\n  return String(value || \"\").replace(/[^\\d+]/g, \"\").trim();\r\n}\r\n\r\nfunction parseCsvList(value) {\r\n  return asString(value)\r\n    .split(\",\")\r\n    .map((item) => item.trim())\r\n    .filter(Boolean);\r\n}\r\n\r\nfunction dedupe(values = []) {\r\n  return Array.from(new Set(values.filter(Boolean)));\r\n}\r\n\r\nfunction normalizeEmailProvider(value) {\r\n  const normalized = asString(value).toLowerCase();\r\n  if (!normalized) {\r\n    return \"\";\r\n  }\r\n  if (normalized.includes(\"resend\")) return \"resend\";\r\n  if (normalized.includes(\"firebase\")) return \"firebase\";\r\n  if (normalized.includes(\"console\") || normalized === \"dev\") return \"console\";\r\n  if (normalized === \"none\" || normalized === \"off\") return \"none\";\r\n  return normalized;\r\n}\r\n\r\nfunction normalizeSmsProvider(value) {\r\n  const normalized = asString(value).toLowerCase();\r\n  if (!normalized) {\r\n    return \"\";\r\n  }\r\n  if (normalized.includes(\"twilio\")) return \"twilio\";\r\n  if (normalized.includes(\"console\") || normalized === \"dev\") return \"console\";\r\n  if (normalized === \"none\" || normalized === \"off\") return \"none\";\r\n  return normalized;\r\n}\r\n\r\nfunction resolveAlertEmailProvider() {\r\n  const configured = normalizeEmailProvider(process.env.CLIO_ALERT_EMAIL_PROVIDER);\r\n  if (configured) {\r\n    return configured;\r\n  }\r\n  if (process.env.NODE_ENV === \"production\") {\r\n    return \"none\";\r\n  }\r\n  const hasResend = asString(process.env.RESEND_API_KEY).startsWith(\"re_\") && asString(process.env.CLIO_EMAIL_FROM);\r\n  return hasResend ? \"resend\" : \"console\";\r\n}\r\n\r\nfunction resolveAlertSmsProvider() {\r\n  const configured = normalizeSmsProvider(process.env.CLIO_ALERT_SMS_PROVIDER);\r\n  if (configured) {\r\n    return configured;\r\n  }\r\n  return \"none\";\r\n}\r\n\r\nfunction resolveSecurityAlertRecipients(explicitRecipients = []) {\r\n  const fromEnv = [\r\n    ...parseCsvList(process.env.CLIO_SECURITY_ALERT_RECIPIENTS),\r\n    ...parseCsvList(process.env.GRC_EMAILS),\r\n    ...parseCsvList(process.env.SUPER_ADMIN_EMAILS),\r\n  ];\r\n  return dedupe(\r\n    [...fromEnv, ...asArray(explicitRecipients)]\r\n      .map((value) => normalizeEmail(value))\r\n      .filter(Boolean),\r\n  );\r\n}\r\n\r\nfunction resolveSmsRecipients(explicitRecipients = []) {\r\n  const fromEnv = parseCsvList(process.env.CLIO_SMS_ALERT_RECIPIENTS);\r\n  return dedupe([...fromEnv, ...asArray(explicitRecipients)].map((value) => normalizePhone(value)).filter(Boolean));\r\n}\r\n\r\nfunction buildIncidentAlertSubject({ incident, detection }) {\r\n  const severity = asString(incident?.severity || detection?.severity || \"Medium\").toUpperCase();\r\n  const incidentCode = asString(incident?.incidentCode, \"INCIDENT\");\r\n  const title = asString(incident?.title, \"Security anomaly detected\");\r\n  return `[CLIO][${severity}] ${incidentCode} - ${title}`;\r\n}\r\n\r\nfunction buildIncidentAlertText({ incident, detection, sourceEvent }) {\r\n  const ruleId = asString(detection?.ruleId, \"N/A\");\r\n  const sourceIp = asString(sourceEvent?.metadata?.sourceIp || sourceEvent?.sourceIp, \"unknown\");\r\n  const actor = asString(sourceEvent?.performedBy, \"unknown\");\r\n  const requestPath = asString(sourceEvent?.metadata?.requestPath || sourceEvent?.requestPath, \"unknown\");\r\n  const observedCount = Number(detection?.observedCount || 0);\r\n  const detectedAt = asString(incident?.detectedAt || sourceEvent?.occurredAt, new Date().toISOString());\r\n  return [\r\n    \"CLIO security anomaly alert\",\r\n    `Incident: ${asString(incident?.incidentCode, \"-\")} | ${asString(incident?.title, \"-\")}`,\r\n    `Severity: ${asString(incident?.severity, \"-\")}`,\r\n    `Rule: ${ruleId}`,\r\n    `Detected At: ${detectedAt}`,\r\n    `Actor: ${actor}`,\r\n    `Source IP: ${sourceIp}`,\r\n    `Request Path: ${requestPath}`,\r\n    `Observed Count: ${observedCount > 0 ? observedCount : \"-\"}`,\r\n    `Summary: ${asString(incident?.summary || detection?.summary, \"-\")}`,\r\n    `Action URL: ${asString(incident?.actionUrl, \"/incident-management\")}`,\r\n  ].join(\"\\n\");\r\n}\r\n\r\nfunction buildIncidentAlertHtml(text) {\r\n  const escaped = String(text || \"\")\r\n    .replaceAll(\"&\", \"&amp;\")\r\n    .replaceAll(\"<\", \"&lt;\")\r\n    .replaceAll(\">\", \"&gt;\");\r\n  return `<pre style=\"font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; white-space:pre-wrap;\">${escaped}</pre>`;\r\n}\r\n\r\nasync function sendEmailViaResend({ recipients, subject, text, html }) {\r\n  const apiKey = asString(process.env.RESEND_API_KEY);\r\n  const fromAddress = asString(process.env.CLIO_EMAIL_FROM);\r\n  if (!apiKey || !fromAddress || !apiKey.startsWith(\"re_\")) {\r\n    throw new Error(\"email_provider_not_configured\");\r\n  }\r\n\r\n  const response = await fetch(`${RESEND_API_BASE}/emails`, {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n      Authorization: `Bearer ${apiKey}`,\r\n    },\r\n    body: JSON.stringify({\r\n      from: fromAddress,\r\n      to: recipients,\r\n      subject,\r\n      text,\r\n      html,\r\n    }),\r\n  });\r\n\r\n  const payload = await response.json().catch(() => ({}));\r\n  if (!response.ok) {\r\n    const message =\r\n      asString(payload?.message) ||\r\n      asString(payload?.error?.message) ||\r\n      \"email_delivery_failed\";\r\n    throw new Error(`email_delivery_failed:${message}`);\r\n  }\r\n\r\n  return {\r\n    provider: \"resend\",\r\n    status: \"sent\",\r\n    messageId: asString(payload?.id, `resend-${Date.now()}`),\r\n    recipientCount: recipients.length,\r\n  };\r\n}\r\n\r\nfunction sendEmailViaConsole({ recipients, subject, text }) {\r\n  if (parseBooleanEnv(\"CLIO_ALLOW_CONSOLE_EMAIL\", true) || process.env.NODE_ENV !== \"production\") {\r\n    console.info(\"[CLIO:SecurityAlert:Email]\", {\r\n      recipients,\r\n      subject,\r\n      text,\r\n    });\r\n  }\r\n  return {\r\n    provider: \"console\",\r\n    status: \"simulated\",\r\n    recipientCount: recipients.length,\r\n  };\r\n}\r\n\r\nasync function dispatchEmailAlerts({ recipients, subject, text, html }) {\r\n  const safeRecipients = dedupe(asArray(recipients).map(normalizeEmail).filter(Boolean));\r\n  if (safeRecipients.length === 0) {\r\n    return {\r\n      provider: \"none\",\r\n      status: \"skipped\",\r\n      reason: \"no_recipients\",\r\n      recipientCount: 0,\r\n    };\r\n  }\r\n\r\n  const provider = resolveAlertEmailProvider();\r\n  if (provider === \"none\") {\r\n    return {\r\n      provider,\r\n      status: \"skipped\",\r\n      reason: \"provider_disabled\",\r\n      recipientCount: 0,\r\n    };\r\n  }\r\n  if (provider === \"firebase\") {\r\n    return {\r\n      provider,\r\n      status: \"skipped\",\r\n      reason: \"firebase_not_supported_for_custom_alert_email\",\r\n      recipientCount: 0,\r\n    };\r\n  }\r\n  if (provider === \"console\") {\r\n    return sendEmailViaConsole({\r\n      recipients: safeRecipients,\r\n      subject,\r\n      text,\r\n    });\r\n  }\r\n  if (provider === \"resend\") {\r\n    return await sendEmailViaResend({\r\n      recipients: safeRecipients,\r\n      subject,\r\n      text,\r\n      html,\r\n    });\r\n  }\r\n\r\n  return {\r\n    provider,\r\n    status: \"skipped\",\r\n    reason: \"unsupported_provider\",\r\n    recipientCount: 0,\r\n  };\r\n}\r\n\r\nasync function sendSmsViaTwilio({ recipients, body }) {\r\n  const accountSid = asString(process.env.TWILIO_ACCOUNT_SID);\r\n  const authToken = asString(process.env.TWILIO_AUTH_TOKEN);\r\n  const fromNumber = asString(process.env.TWILIO_FROM_NUMBER);\r\n  if (!accountSid || !authToken || !fromNumber) {\r\n    throw new Error(\"twilio_not_configured\");\r\n  }\r\n\r\n  const authHeader = Buffer.from(`${accountSid}:${authToken}`, \"utf8\").toString(\"base64\");\r\n  const requests = recipients.map(async (to) => {\r\n    const form = new URLSearchParams();\r\n    form.set(\"To\", to);\r\n    form.set(\"From\", fromNumber);\r\n    form.set(\"Body\", body);\r\n    const response = await fetch(`${TWILIO_API_BASE}/Accounts/${encodeURIComponent(accountSid)}/Messages.json`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        Authorization: `Basic ${authHeader}`,\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n      },\r\n      body: form.toString(),\r\n    });\r\n    const payload = await response.json().catch(() => ({}));\r\n    if (!response.ok) {\r\n      const message = asString(payload?.message, \"sms_delivery_failed\");\r\n      throw new Error(`twilio_delivery_failed:${message}`);\r\n    }\r\n    return {\r\n      to,\r\n      sid: asString(payload?.sid),\r\n    };\r\n  });\r\n\r\n  const settled = await Promise.allSettled(requests);\r\n  const delivered = settled\r\n    .filter((item) => item.status === \"fulfilled\")\r\n    .map((item) => item.value);\r\n  const failed = settled\r\n    .filter((item) => item.status === \"rejected\")\r\n    .map((item) => asString(item.reason?.message || \"sms_delivery_failed\"));\r\n\r\n  return {\r\n    provider: \"twilio\",\r\n    status: failed.length > 0 ? (delivered.length > 0 ? \"partial\" : \"failed\") : \"sent\",\r\n    deliveredCount: delivered.length,\r\n    recipientCount: recipients.length,\r\n    delivered,\r\n    failed,\r\n  };\r\n}\r\n\r\nfunction sendSmsViaConsole({ recipients, body }) {\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    console.info(\"[CLIO:SecurityAlert:SMS]\", {\r\n      recipients,\r\n      body,\r\n    });\r\n  }\r\n  return {\r\n    provider: \"console\",\r\n    status: \"simulated\",\r\n    deliveredCount: recipients.length,\r\n    recipientCount: recipients.length,\r\n    delivered: recipients.map((to) => ({ to, sid: `console-${Date.now()}` })),\r\n    failed: [],\r\n  };\r\n}\r\n\r\nasync function dispatchSmsAlerts({ recipients, body }) {\r\n  const safeRecipients = dedupe(asArray(recipients).map(normalizePhone).filter(Boolean));\r\n  if (safeRecipients.length === 0) {\r\n    return {\r\n      provider: \"none\",\r\n      status: \"skipped\",\r\n      reason: \"no_recipients\",\r\n      deliveredCount: 0,\r\n      recipientCount: 0,\r\n      failed: [],\r\n    };\r\n  }\r\n\r\n  const provider = resolveAlertSmsProvider();\r\n  if (provider === \"none\") {\r\n    return {\r\n      provider,\r\n      status: \"skipped\",\r\n      reason: \"provider_disabled\",\r\n      deliveredCount: 0,\r\n      recipientCount: safeRecipients.length,\r\n      failed: [],\r\n    };\r\n  }\r\n  if (provider === \"console\") {\r\n    return sendSmsViaConsole({\r\n      recipients: safeRecipients,\r\n      body,\r\n    });\r\n  }\r\n  if (provider === \"twilio\") {\r\n    return await sendSmsViaTwilio({\r\n      recipients: safeRecipients,\r\n      body,\r\n    });\r\n  }\r\n\r\n  return {\r\n    provider,\r\n    status: \"skipped\",\r\n    reason: \"unsupported_provider\",\r\n    deliveredCount: 0,\r\n    recipientCount: safeRecipients.length,\r\n    failed: [],\r\n  };\r\n}\r\n\r\nfunction getConfiguredWebhookTargets() {\r\n  const generic = parseCsvList(process.env.CLIO_SECURITY_WEBHOOK_URLS).map((url) => ({\r\n    label: \"security-webhook\",\r\n    url,\r\n    token: asString(process.env.CLIO_SECURITY_WEBHOOK_TOKEN),\r\n  }));\r\n  const siemUrl = asString(process.env.CLIO_SIEM_WEBHOOK_URL);\r\n  const edrUrl = asString(process.env.CLIO_EDR_WEBHOOK_URL);\r\n  const targets = [...generic];\r\n  if (siemUrl) {\r\n    targets.push({\r\n      label: \"siem\",\r\n      url: siemUrl,\r\n      token: asString(process.env.CLIO_SIEM_WEBHOOK_TOKEN),\r\n    });\r\n  }\r\n  if (edrUrl) {\r\n    targets.push({\r\n      label: \"edr\",\r\n      url: edrUrl,\r\n      token: asString(process.env.CLIO_EDR_WEBHOOK_TOKEN),\r\n    });\r\n  }\r\n  return targets.filter((target) => asString(target.url));\r\n}\r\n\r\nasync function postWebhook({ url, label, token, payload, timeoutMs }) {\r\n  const controller = new AbortController();\r\n  const timer = setTimeout(() => controller.abort(), timeoutMs);\r\n  try {\r\n    const headers = {\r\n      \"Content-Type\": \"application/json\",\r\n      \"X-CLIO-Source\": \"security-detection\",\r\n      \"X-CLIO-Target\": label,\r\n    };\r\n    if (token) {\r\n      headers.Authorization = `Bearer ${token}`;\r\n    }\r\n    const response = await fetch(url, {\r\n      method: \"POST\",\r\n      headers,\r\n      body: JSON.stringify(payload),\r\n      signal: controller.signal,\r\n    });\r\n    const body = await response.text().catch(() => \"\");\r\n    return {\r\n      label,\r\n      url,\r\n      ok: response.ok,\r\n      status: response.status,\r\n      body: asString(body),\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      label,\r\n      url,\r\n      ok: false,\r\n      status: 0,\r\n      body: asString(error?.message, \"webhook_delivery_failed\"),\r\n    };\r\n  } finally {\r\n    clearTimeout(timer);\r\n  }\r\n}\r\n\r\nasync function dispatchWebhooks(payload) {\r\n  const targets = getConfiguredWebhookTargets();\r\n  if (targets.length === 0) {\r\n    return {\r\n      status: \"skipped\",\r\n      targets: [],\r\n      successCount: 0,\r\n    };\r\n  }\r\n\r\n  const timeoutMs = Number.parseInt(asString(process.env.CLIO_SECURITY_WEBHOOK_TIMEOUT_MS, \"5000\"), 10) || 5000;\r\n  const results = await Promise.all(\r\n    targets.map((target) =>\r\n      postWebhook({\r\n        ...target,\r\n        payload,\r\n        timeoutMs: Math.max(1000, Math.min(20000, timeoutMs)),\r\n      }),\r\n    ),\r\n  );\r\n  const successCount = results.filter((item) => item.ok).length;\r\n  return {\r\n    status: successCount === results.length ? \"sent\" : successCount > 0 ? \"partial\" : \"failed\",\r\n    targets: results,\r\n    successCount,\r\n  };\r\n}\r\n\r\nexport async function dispatchSecurityIncidentAlerts({\r\n  incident,\r\n  detection,\r\n  sourceEvent,\r\n  emailRecipients = [],\r\n  smsRecipients = [],\r\n} = {}) {\r\n  const recipients = resolveSecurityAlertRecipients(emailRecipients);\r\n  const smsTargets = resolveSmsRecipients(smsRecipients);\r\n  const subject = buildIncidentAlertSubject({ incident, detection });\r\n  const text = buildIncidentAlertText({ incident, detection, sourceEvent });\r\n  const html = buildIncidentAlertHtml(text);\r\n\r\n  const [emailResult, smsResult, webhookResult] = await Promise.all([\r\n    dispatchEmailAlerts({\r\n      recipients,\r\n      subject,\r\n      text,\r\n      html,\r\n    }).catch((error) => ({\r\n      provider: resolveAlertEmailProvider(),\r\n      status: \"failed\",\r\n      reason: asString(error?.message, \"email_delivery_failed\"),\r\n      recipientCount: recipients.length,\r\n    })),\r\n    dispatchSmsAlerts({\r\n      recipients: smsTargets,\r\n      body: `${subject}\\n${text}`.slice(0, 1200),\r\n    }).catch((error) => ({\r\n      provider: resolveAlertSmsProvider(),\r\n      status: \"failed\",\r\n      reason: asString(error?.message, \"sms_delivery_failed\"),\r\n      deliveredCount: 0,\r\n      recipientCount: smsTargets.length,\r\n      failed: [asString(error?.message, \"sms_delivery_failed\")],\r\n    })),\r\n    dispatchWebhooks({\r\n      eventType: \"clio.security.incident\",\r\n      generatedAt: new Date().toISOString(),\r\n      incident,\r\n      detection,\r\n      sourceEvent: {\r\n        id: asString(sourceEvent?.id),\r\n        module: asString(sourceEvent?.module),\r\n        activityName: asString(sourceEvent?.activityName),\r\n        status: asString(sourceEvent?.status),\r\n        occurredAt: asString(sourceEvent?.occurredAt),\r\n        sourceIp: asString(sourceEvent?.metadata?.sourceIp || sourceEvent?.sourceIp),\r\n        requestPath: asString(sourceEvent?.metadata?.requestPath || sourceEvent?.requestPath),\r\n      },\r\n    }),\r\n  ]);\r\n\r\n  return {\r\n    subject,\r\n    email: emailResult,\r\n    sms: smsResult,\r\n    webhooks: webhookResult,\r\n    recipients,\r\n    smsRecipients: smsTargets,\r\n  };\r\n}\r\n\r\nexport function resolveSecurityAlertEmailRecipients(explicitRecipients = []) {\r\n  return resolveSecurityAlertRecipients(explicitRecipients);\r\n}\r\n\r\nexport async function dispatchDirectSms({ recipients = [], body = \"\" } = {}) {\r\n  return await dispatchSmsAlerts({\r\n    recipients,\r\n    body: asString(body, \"\"),\r\n  });\r\n}\r\n","import {\r\n  createIncidentRecordBackend,\r\n  listIncidentRecordsBackend,\r\n  updateIncidentRecordBackend,\r\n} from \"@/lib/hris-backend\";\r\nimport {\r\n  addDoc,\r\n  collection,\r\n  deleteDoc,\r\n  doc,\r\n  getDocs,\r\n  limit as queryLimit,\r\n  orderBy,\r\n  query,\r\n  updateDoc,\r\n} from \"firebase/firestore/lite\";\r\nimport { getFirestoreDb, isFirestoreEnabled } from \"@/lib/firebase\";\r\nimport {\r\n  createInAppNotificationsBulk,\r\n  resolveIncidentStakeholderRecipients,\r\n} from \"@/lib/security-notifications\";\r\nimport {\r\n  dispatchSecurityIncidentAlerts,\r\n  resolveSecurityAlertEmailRecipients,\r\n} from \"@/lib/security-alert-delivery\";\r\n\r\nconst EVENT_COUNTER_WINDOWS = new Map();\r\nconst INCIDENT_COOLDOWN_CACHE = new Map();\r\nconst MAX_COUNTER_BUCKET_SIZE = 256;\r\nconst DEFAULT_SYSTEM_ACTOR = \"system@gmail.com\";\r\nlet IDS_RETRY_DRAIN_PROMISE = null;\r\n\r\nconst PERMISSION_DENIED_REASONS = new Set([\r\n  \"missing_permission\",\r\n  \"role_not_allowed\",\r\n  \"ownership_validation_failed\",\r\n  \"unauthorized\",\r\n  \"account_not_active\",\r\n  \"session_role_mismatch\",\r\n  \"session_version_mismatch\",\r\n]);\r\nconst ACCOUNT_ACCESS_BLOCK_REASONS = new Set([\r\n  \"account_disabled\",\r\n  \"account_inactive\",\r\n  \"account_archived\",\r\n  \"offboarded_user\",\r\n]);\r\nconst PRIVILEGED_ROLE_KEYS = new Set([\"SUPER_ADMIN\", \"GRC\", \"HR\", \"EA\"]);\r\n\r\nfunction nowIso() {\r\n  return new Date().toISOString();\r\n}\r\n\r\nfunction asString(value, fallback = \"\") {\r\n  const normalized = String(value || \"\").trim();\r\n  return normalized || fallback;\r\n}\r\n\r\nfunction asObject(value) {\r\n  if (value && typeof value === \"object\" && !Array.isArray(value)) {\r\n    return value;\r\n  }\r\n  return {};\r\n}\r\n\r\nfunction asArray(value) {\r\n  return Array.isArray(value) ? value : [];\r\n}\r\n\r\nfunction normalizeText(value) {\r\n  return asString(value).toLowerCase();\r\n}\r\n\r\nfunction normalizeEmail(value) {\r\n  return asString(value).toLowerCase();\r\n}\r\n\r\nfunction normalizeIp(value) {\r\n  const ip = asString(value).toLowerCase();\r\n  return ip || \"unknown\";\r\n}\r\n\r\nfunction normalizeRoleKey(value) {\r\n  return asString(value)\r\n    .toUpperCase()\r\n    .replace(/[^A-Z0-9]+/g, \"_\")\r\n    .replace(/^_+|_+$/g, \"\");\r\n}\r\n\r\nfunction toTimeMs(value) {\r\n  const timestamp = new Date(value || \"\").getTime();\r\n  return Number.isNaN(timestamp) ? null : timestamp;\r\n}\r\n\r\nfunction parseBooleanEnv(name, fallbackValue = false) {\r\n  const raw = normalizeText(process.env[name]);\r\n  if (!raw) {\r\n    return fallbackValue;\r\n  }\r\n  return raw === \"true\" || raw === \"1\" || raw === \"yes\";\r\n}\r\n\r\nfunction parseIntegerEnv(name, fallbackValue, { min = 1, max = Number.MAX_SAFE_INTEGER } = {}) {\r\n  const parsed = Number.parseInt(asString(process.env[name]), 10);\r\n  if (!Number.isFinite(parsed)) {\r\n    return fallbackValue;\r\n  }\r\n  return Math.min(max, Math.max(min, parsed));\r\n}\r\n\r\nfunction normalizeBaseUrl(value) {\r\n  const raw = asString(value);\r\n  if (!raw) {\r\n    return \"\";\r\n  }\r\n  if (raw.startsWith(\"http://\") || raw.startsWith(\"https://\")) {\r\n    return raw.replace(/\\/+$/, \"\");\r\n  }\r\n  return `https://${raw.replace(/^\\/+/, \"\").replace(/\\/+$/, \"\")}`;\r\n}\r\n\r\nfunction resolveAppBaseUrl() {\r\n  const configured = normalizeBaseUrl(process.env.CLIO_APP_BASE_URL);\r\n  if (configured) {\r\n    return configured;\r\n  }\r\n\r\n  const publicSiteUrl = normalizeBaseUrl(process.env.NEXT_PUBLIC_APP_URL);\r\n  if (publicSiteUrl) {\r\n    return publicSiteUrl;\r\n  }\r\n\r\n  const firebaseAuthDomain = normalizeBaseUrl(\r\n    process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN || process.env.FIREBASE_AUTH_DOMAIN,\r\n  );\r\n  if (firebaseAuthDomain) {\r\n    return firebaseAuthDomain;\r\n  }\r\n\r\n  const vercelUrl = normalizeBaseUrl(\r\n    process.env.VERCEL_PROJECT_PRODUCTION_URL || process.env.VERCEL_URL,\r\n  );\r\n  if (vercelUrl) {\r\n    return vercelUrl;\r\n  }\r\n\r\n  return \"\";\r\n}\r\n\r\nfunction getDetectionRetryQueueCollectionName() {\r\n  return asString(process.env.CLIO_FIRESTORE_IDS_RETRY_COLLECTION, \"clio_ids_retry_queue\");\r\n}\r\n\r\nfunction getDetectionDeadLetterCollectionName() {\r\n  return asString(process.env.CLIO_FIRESTORE_IDS_DEAD_LETTER_COLLECTION, \"clio_ids_dead_letter\");\r\n}\r\n\r\nfunction getDetectionQueueDb() {\r\n  if (!isFirestoreEnabled()) {\r\n    return null;\r\n  }\r\n  return getFirestoreDb();\r\n}\r\n\r\nfunction getDetectionConfig() {\r\n  return {\r\n    enabled: parseBooleanEnv(\"CLIO_IDS_ENABLED\", true),\r\n    authFailureThreshold: parseIntegerEnv(\"CLIO_IDS_AUTH_FAILURE_THRESHOLD\", 5, { min: 2, max: 30 }),\r\n    authFailureWindowMinutes: parseIntegerEnv(\"CLIO_IDS_AUTH_FAILURE_WINDOW_MINUTES\", 10, { min: 1, max: 120 }),\r\n    permissionDeniedThreshold: parseIntegerEnv(\"CLIO_IDS_PERMISSION_DENIED_THRESHOLD\", 3, { min: 2, max: 20 }),\r\n    permissionDeniedWindowMinutes: parseIntegerEnv(\"CLIO_IDS_PERMISSION_DENIED_WINDOW_MINUTES\", 15, { min: 1, max: 120 }),\r\n    exportSpikeThreshold: parseIntegerEnv(\"CLIO_IDS_EXPORT_SPIKE_THRESHOLD\", 4, { min: 2, max: 20 }),\r\n    exportSpikeWindowMinutes: parseIntegerEnv(\"CLIO_IDS_EXPORT_SPIKE_WINDOW_MINUTES\", 20, { min: 1, max: 180 }),\r\n    piiAccessSpikeThreshold: parseIntegerEnv(\"CLIO_IDS_PII_ACCESS_SPIKE_THRESHOLD\", 12, { min: 4, max: 80 }),\r\n    piiAccessSpikeWindowMinutes: parseIntegerEnv(\"CLIO_IDS_PII_ACCESS_SPIKE_WINDOW_MINUTES\", 15, { min: 1, max: 180 }),\r\n    offboardedAccessThreshold: parseIntegerEnv(\"CLIO_IDS_OFFBOARDED_ACCESS_THRESHOLD\", 2, { min: 1, max: 30 }),\r\n    offboardedAccessWindowMinutes: parseIntegerEnv(\"CLIO_IDS_OFFBOARDED_ACCESS_WINDOW_MINUTES\", 30, { min: 1, max: 240 }),\r\n    privilegedRoleChangeThreshold: parseIntegerEnv(\"CLIO_IDS_ROLE_ESCALATION_THRESHOLD\", 2, { min: 1, max: 20 }),\r\n    privilegedRoleChangeWindowMinutes: parseIntegerEnv(\"CLIO_IDS_ROLE_ESCALATION_WINDOW_MINUTES\", 60, { min: 1, max: 480 }),\r\n    breachWindowMinutes: parseIntegerEnv(\"CLIO_IDS_BREACH_WINDOW_MINUTES\", 30, { min: 5, max: 240 }),\r\n    breachExportThreshold: parseIntegerEnv(\"CLIO_IDS_BREACH_EXPORT_THRESHOLD\", 2, { min: 1, max: 50 }),\r\n    breachPiiThreshold: parseIntegerEnv(\"CLIO_IDS_BREACH_PII_THRESHOLD\", 6, { min: 1, max: 120 }),\r\n    breachDeniedThreshold: parseIntegerEnv(\"CLIO_IDS_BREACH_DENIED_THRESHOLD\", 2, { min: 0, max: 50 }),\r\n    incidentCooldownMinutes: parseIntegerEnv(\"CLIO_IDS_INCIDENT_COOLDOWN_MINUTES\", 15, { min: 1, max: 360 }),\r\n    maxRecipientCount: parseIntegerEnv(\"CLIO_IDS_MAX_RECIPIENTS\", 20, { min: 1, max: 100 }),\r\n    systemActorEmail: normalizeEmail(process.env.CLIO_IDS_SYSTEM_ACTOR_EMAIL) || DEFAULT_SYSTEM_ACTOR,\r\n    appBaseUrl: resolveAppBaseUrl(),\r\n    retryEnabled: parseBooleanEnv(\"CLIO_IDS_RETRY_ENABLED\", true),\r\n    retryBatchSize: parseIntegerEnv(\"CLIO_IDS_RETRY_BATCH_SIZE\", 8, { min: 1, max: 32 }),\r\n    retryMaxAttempts: parseIntegerEnv(\"CLIO_IDS_RETRY_MAX_ATTEMPTS\", 5, { min: 1, max: 20 }),\r\n    retryBaseBackoffSeconds: parseIntegerEnv(\"CLIO_IDS_RETRY_BASE_BACKOFF_SECONDS\", 30, {\r\n      min: 5,\r\n      max: 3600,\r\n    }),\r\n    retryMaxBackoffSeconds: parseIntegerEnv(\"CLIO_IDS_RETRY_MAX_BACKOFF_SECONDS\", 1800, {\r\n      min: 30,\r\n      max: 24 * 3600,\r\n    }),\r\n    retryCollectionName: getDetectionRetryQueueCollectionName(),\r\n    deadLetterCollectionName: getDetectionDeadLetterCollectionName(),\r\n  };\r\n}\r\n\r\nfunction pruneCounterWindow(values, currentTimeMs, windowMs) {\r\n  const cutoff = currentTimeMs - windowMs;\r\n  return values.filter((value) => value >= cutoff).slice(-MAX_COUNTER_BUCKET_SIZE);\r\n}\r\n\r\nfunction incrementCounterWindow(key, timestampMs, windowMs) {\r\n  const normalizedKey = asString(key);\r\n  if (!normalizedKey) {\r\n    return 0;\r\n  }\r\n  const safeTimestamp = Number.isFinite(timestampMs) ? timestampMs : Date.now();\r\n  const existing = EVENT_COUNTER_WINDOWS.get(normalizedKey) || [];\r\n  const pruned = pruneCounterWindow(existing, safeTimestamp, windowMs);\r\n  pruned.push(safeTimestamp);\r\n  EVENT_COUNTER_WINDOWS.set(normalizedKey, pruned);\r\n  return pruned.length;\r\n}\r\n\r\nfunction getCounterCount(key, timestampMs, windowMs) {\r\n  const normalizedKey = asString(key);\r\n  if (!normalizedKey) {\r\n    return 0;\r\n  }\r\n  const safeTimestamp = Number.isFinite(timestampMs) ? timestampMs : Date.now();\r\n  const existing = EVENT_COUNTER_WINDOWS.get(normalizedKey) || [];\r\n  const pruned = pruneCounterWindow(existing, safeTimestamp, windowMs);\r\n  EVENT_COUNTER_WINDOWS.set(normalizedKey, pruned);\r\n  return pruned.length;\r\n}\r\n\r\nfunction cleanupIncidentCooldown(nowMs) {\r\n  const current = Number.isFinite(nowMs) ? nowMs : Date.now();\r\n  for (const [key, value] of INCIDENT_COOLDOWN_CACHE.entries()) {\r\n    if (!Number.isFinite(value) || value <= current) {\r\n      INCIDENT_COOLDOWN_CACHE.delete(key);\r\n    }\r\n  }\r\n}\r\n\r\nfunction isInIncidentCooldown(fingerprint, nowMs) {\r\n  cleanupIncidentCooldown(nowMs);\r\n  const expiresAt = INCIDENT_COOLDOWN_CACHE.get(fingerprint);\r\n  return Number.isFinite(expiresAt) && expiresAt > nowMs;\r\n}\r\n\r\nfunction rememberIncidentCooldown(fingerprint, nowMs, minutes) {\r\n  const ttlMs = Math.max(1, Number(minutes || 1)) * 60 * 1000;\r\n  INCIDENT_COOLDOWN_CACHE.set(fingerprint, nowMs + ttlMs);\r\n}\r\n\r\nfunction shouldSkipEvent(entry) {\r\n  const metadata = asObject(entry?.metadata);\r\n  if (metadata.skipAnomalyDetection === true || metadata.autoGenerated === true) {\r\n    return true;\r\n  }\r\n\r\n  const moduleName = normalizeText(entry?.module);\r\n  const requestPath = normalizeText(metadata.requestPath || entry?.requestPath);\r\n  if (moduleName.includes(\"incident management\")) {\r\n    return true;\r\n  }\r\n  if (requestPath.startsWith(\"/api/notifications\")) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction buildFingerprint(ruleId, entry, detection, nowMs, windowMinutes) {\r\n  const actor = normalizeEmail(entry?.performedBy);\r\n  const sourceIp = normalizeIp(entry?.metadata?.sourceIp || entry?.sourceIp);\r\n  const moduleName = normalizeText(entry?.module || \"\");\r\n  const target = normalizeEmail(detection?.affectedEmployeeEmail || entry?.metadata?.employeeEmail || \"\");\r\n  const bucket = Math.floor(nowMs / (Math.max(1, Number(windowMinutes || 1)) * 60 * 1000));\r\n  return [asString(ruleId), actor || \"unknown\", sourceIp, moduleName || \"module\", target || \"none\", bucket].join(\"|\");\r\n}\r\n\r\nfunction buildCorrelationKey(ruleId, entry, detection) {\r\n  const actor = normalizeEmail(entry?.performedBy);\r\n  const sourceIp = normalizeIp(entry?.metadata?.sourceIp || entry?.sourceIp);\r\n  const moduleName = normalizeText(entry?.module || \"\");\r\n  const target = normalizeEmail(detection?.affectedEmployeeEmail || entry?.metadata?.employeeEmail || \"\");\r\n  return [asString(ruleId), actor || \"unknown\", sourceIp, moduleName || \"module\", target || \"none\"].join(\"|\");\r\n}\r\n\r\nfunction normalizeIncidentState(value) {\r\n  return normalizeText(value).replace(/\\s+/g, \"_\");\r\n}\r\n\r\nfunction isIncidentOpenForConsolidation(status) {\r\n  const state = normalizeIncidentState(status);\r\n  return ![\"resolved\", \"closed\"].includes(state);\r\n}\r\n\r\nfunction toDetectionOccurrenceEntry(entry) {\r\n  const metadata = asObject(entry?.metadata);\r\n  return {\r\n    at: asString(entry?.occurredAt, nowIso()),\r\n    activityName: asString(entry?.activityName, \"Activity\"),\r\n    module: asString(entry?.module, \"System\"),\r\n    sourceEventId: asString(entry?.id),\r\n    sourceIp: asString(metadata.sourceIp || entry?.sourceIp),\r\n    requestPath: asString(metadata.requestPath || entry?.requestPath),\r\n    requestMethod: asString(metadata.requestMethod || entry?.requestMethod),\r\n    actorEmail: normalizeEmail(entry?.performedBy),\r\n    targetEmployeeEmail: normalizeEmail(metadata.targetEmployeeEmail || metadata.employeeEmail || metadata.affectedEmployeeEmail),\r\n  };\r\n}\r\n\r\nfunction chooseSeverity(baseSeverity, observedCount, threshold) {\r\n  const severity = normalizeText(baseSeverity);\r\n  if (severity === \"critical\") {\r\n    return \"High\";\r\n  }\r\n  const safeThreshold = Math.max(1, Number(threshold || 1));\r\n  if (observedCount >= safeThreshold * 2) {\r\n    return \"High\";\r\n  }\r\n  if (severity === \"high\") {\r\n    return \"High\";\r\n  }\r\n  return \"Low\";\r\n}\r\n\r\nfunction extractEventContext(entry) {\r\n  const metadata = asObject(entry?.metadata);\r\n  return {\r\n    actorEmail: normalizeEmail(entry?.performedBy),\r\n    status: normalizeText(entry?.status),\r\n    moduleName: normalizeText(entry?.module),\r\n    activityName: normalizeText(entry?.activityName),\r\n    reason: normalizeText(metadata.reason),\r\n    requestPath: normalizeText(metadata.requestPath || entry?.requestPath),\r\n    requestMethod: normalizeText(metadata.requestMethod || entry?.requestMethod),\r\n    sourceIp: normalizeIp(metadata.sourceIp || entry?.sourceIp),\r\n    sensitivity: normalizeText(entry?.sensitivity),\r\n    targetEmployeeEmail: normalizeEmail(metadata.targetEmployeeEmail || metadata.employeeEmail || metadata.affectedEmployeeEmail),\r\n    ownerEmail: normalizeEmail(metadata.ownerEmail),\r\n    targetRole: normalizeRoleKey(metadata.targetRole || metadata.assignedRole || \"\"),\r\n    actorRole: normalizeRoleKey(metadata.actorRole || metadata.currentRole || \"\"),\r\n    occurredAtMs: toTimeMs(entry?.occurredAt) || Date.now(),\r\n  };\r\n}\r\n\r\nfunction isDeniedStatus(status) {\r\n  return status === \"failed\" || status === \"rejected\";\r\n}\r\n\r\nfunction detectAuthFailureSpike(entry, context, config) {\r\n  if (!context.moduleName.includes(\"authentication\") || !isDeniedStatus(context.status)) {\r\n    return null;\r\n  }\r\n\r\n  const key = `auth-fail:${context.sourceIp || context.actorEmail || \"unknown\"}`;\r\n  const count = incrementCounterWindow(\r\n    key,\r\n    context.occurredAtMs,\r\n    config.authFailureWindowMinutes * 60 * 1000,\r\n  );\r\n  if (count < config.authFailureThreshold) {\r\n    return null;\r\n  }\r\n\r\n  const severity = chooseSeverity(\"high\", count, config.authFailureThreshold);\r\n  return {\r\n    ruleId: \"AUTH_BRUTE_FORCE\",\r\n    incidentType: \"Credential Compromise\",\r\n    severity,\r\n    restrictedPiiInvolved: false,\r\n    observedCount: count,\r\n    windowMinutes: config.authFailureWindowMinutes,\r\n    affectedEmployeeEmail: context.actorEmail,\r\n    title: \"Repeated authentication failures detected\",\r\n    summary: `Detected ${count} failed/rejected authentication events from ${context.sourceIp} within ${config.authFailureWindowMinutes} minute(s).`,\r\n    tags: [\"authentication\", \"brute-force\", \"ids\"],\r\n  };\r\n}\r\n\r\nfunction detectPermissionDeniedSpike(entry, context, config) {\r\n  const isPermissionDenied =\r\n    isDeniedStatus(context.status) &&\r\n    (PERMISSION_DENIED_REASONS.has(context.reason) ||\r\n      context.activityName.includes(\"permission\") ||\r\n      context.activityName.includes(\"ownership\") ||\r\n      context.activityName.includes(\"forbidden\"));\r\n  if (!isPermissionDenied) {\r\n    return null;\r\n  }\r\n\r\n  const key = `permission-denied:${context.actorEmail || context.sourceIp || \"unknown\"}`;\r\n  const count = incrementCounterWindow(\r\n    key,\r\n    context.occurredAtMs,\r\n    config.permissionDeniedWindowMinutes * 60 * 1000,\r\n  );\r\n  if (count < config.permissionDeniedThreshold) {\r\n    return null;\r\n  }\r\n\r\n  const piiModule =\r\n    context.moduleName.includes(\"employee records\") ||\r\n    context.moduleName.includes(\"performance\") ||\r\n    context.moduleName.includes(\"attendance\");\r\n  const severity = chooseSeverity(piiModule ? \"high\" : \"low\", count, config.permissionDeniedThreshold);\r\n  return {\r\n    ruleId: \"UNAUTHORIZED_ACCESS_ATTEMPT\",\r\n    incidentType: \"Unauthorized Access\",\r\n    severity,\r\n    restrictedPiiInvolved: piiModule,\r\n    observedCount: count,\r\n    windowMinutes: config.permissionDeniedWindowMinutes,\r\n    affectedEmployeeEmail: context.targetEmployeeEmail || context.actorEmail,\r\n    title: \"Repeated unauthorized access attempts detected\",\r\n    summary: `Detected ${count} permission/ownership denials for actor ${context.actorEmail || \"unknown\"} within ${config.permissionDeniedWindowMinutes} minute(s).`,\r\n    tags: [\"authorization\", \"idor\", \"least-privilege\", \"ids\"],\r\n  };\r\n}\r\n\r\nfunction detectExportSpike(entry, context, config) {\r\n  const isExportActivity =\r\n    context.moduleName.includes(\"export\") ||\r\n    context.requestPath.includes(\"/api/hris/exports\") ||\r\n    context.activityName.includes(\"export\");\r\n  if (!isExportActivity) {\r\n    return null;\r\n  }\r\n\r\n  if (!(context.status === \"approved\" || context.status === \"completed\")) {\r\n    return null;\r\n  }\r\n\r\n  const key = `export-spike:${context.actorEmail || context.sourceIp || \"unknown\"}`;\r\n  const count = incrementCounterWindow(\r\n    key,\r\n    context.occurredAtMs,\r\n    config.exportSpikeWindowMinutes * 60 * 1000,\r\n  );\r\n  if (count < config.exportSpikeThreshold) {\r\n    return null;\r\n  }\r\n\r\n  const severity = chooseSeverity(\"high\", count, config.exportSpikeThreshold);\r\n  return {\r\n    ruleId: \"MASS_EXPORT_ACTIVITY\",\r\n    incidentType: \"Data Exposure\",\r\n    severity,\r\n    restrictedPiiInvolved: true,\r\n    observedCount: count,\r\n    windowMinutes: config.exportSpikeWindowMinutes,\r\n    affectedEmployeeEmail: context.targetEmployeeEmail || \"\",\r\n    title: \"Mass export activity detected\",\r\n    summary: `Detected ${count} export-related actions by ${context.actorEmail || context.sourceIp} within ${config.exportSpikeWindowMinutes} minute(s).`,\r\n    tags: [\"export\", \"dlp\", \"ids\"],\r\n  };\r\n}\r\n\r\nfunction detectPiiAccessSpike(entry, context, config) {\r\n  const isRecordViewActivity = context.activityName.includes(\"view\") || context.activityName.includes(\"list\");\r\n  const isUnauthorizedRecordView =\r\n    context.moduleName.includes(\"employee records\") &&\r\n    isRecordViewActivity &&\r\n    isDeniedStatus(context.status) &&\r\n    (PERMISSION_DENIED_REASONS.has(context.reason) ||\r\n      context.activityName.includes(\"permission\") ||\r\n      context.activityName.includes(\"ownership\") ||\r\n      context.activityName.includes(\"forbidden\"));\r\n  if (!isUnauthorizedRecordView) {\r\n    return null;\r\n  }\r\n\r\n  const key = `unauthorized-record-view:${context.actorEmail || context.sourceIp || \"unknown\"}`;\r\n  const count = incrementCounterWindow(\r\n    key,\r\n    context.occurredAtMs,\r\n    config.piiAccessSpikeWindowMinutes * 60 * 1000,\r\n  );\r\n  if (count < config.piiAccessSpikeThreshold) {\r\n    return null;\r\n  }\r\n\r\n  const severity = chooseSeverity(\"high\", count, config.piiAccessSpikeThreshold);\r\n  return {\r\n    ruleId: \"UNAUTHORIZED_RECORD_VIEW_SPIKE\",\r\n    incidentType: \"Unauthorized Access\",\r\n    severity,\r\n    restrictedPiiInvolved: true,\r\n    observedCount: count,\r\n    windowMinutes: config.piiAccessSpikeWindowMinutes,\r\n    affectedEmployeeEmail: context.targetEmployeeEmail || \"\",\r\n    title: \"Unauthorized employee-record view attempts detected\",\r\n    summary: `Detected ${count} denied employee-record view/list actions in ${config.piiAccessSpikeWindowMinutes} minute(s).`,\r\n    tags: [\"authorization\", \"employee-records\", \"pii\", \"ids\"],\r\n  };\r\n}\r\n\r\nfunction detectOffboardedAccessAttempt(entry, context, config) {\r\n  const isAuthenticationModule = context.moduleName.includes(\"authentication\") || context.requestPath.includes(\"/api/auth/\");\r\n  const isAccountBlockedAttempt =\r\n    isDeniedStatus(context.status) &&\r\n    (ACCOUNT_ACCESS_BLOCK_REASONS.has(context.reason) ||\r\n      context.activityName.includes(\"account disabled\") ||\r\n      context.activityName.includes(\"account inactive\") ||\r\n      context.activityName.includes(\"offboard\"));\r\n  if (!(isAuthenticationModule && isAccountBlockedAttempt)) {\r\n    return null;\r\n  }\r\n\r\n  const key = `offboarded-access:${context.actorEmail || context.sourceIp || \"unknown\"}`;\r\n  const count = incrementCounterWindow(\r\n    key,\r\n    context.occurredAtMs,\r\n    config.offboardedAccessWindowMinutes * 60 * 1000,\r\n  );\r\n  if (count < config.offboardedAccessThreshold) {\r\n    return null;\r\n  }\r\n\r\n  const severity = chooseSeverity(\"high\", count, config.offboardedAccessThreshold);\r\n  return {\r\n    ruleId: \"OFFBOARDED_ACCESS_ATTEMPT\",\r\n    incidentType: \"Unauthorized Access\",\r\n    severity,\r\n    restrictedPiiInvolved: true,\r\n    observedCount: count,\r\n    windowMinutes: config.offboardedAccessWindowMinutes,\r\n    affectedEmployeeEmail: context.actorEmail || context.targetEmployeeEmail,\r\n    title: \"Offboarded/disabled account access attempts detected\",\r\n    summary: `Detected ${count} blocked sign-in/access attempts for disabled or offboarded account ${context.actorEmail || \"unknown\"} within ${config.offboardedAccessWindowMinutes} minute(s).`,\r\n    tags: [\"authentication\", \"offboarding\", \"access-control\", \"ids\"],\r\n  };\r\n}\r\n\r\nfunction detectPrivilegedRoleAssignmentSpike(entry, context, config) {\r\n  const isRoleAssignmentActivity =\r\n    context.moduleName.includes(\"user management\") &&\r\n    context.activityName.includes(\"role updated\") &&\r\n    (context.status === \"approved\" || context.status === \"completed\");\r\n  if (!isRoleAssignmentActivity) {\r\n    return null;\r\n  }\r\n  if (!context.targetRole || !PRIVILEGED_ROLE_KEYS.has(context.targetRole)) {\r\n    return null;\r\n  }\r\n\r\n  const key = `priv-role-assignment:${context.actorEmail || \"unknown\"}:${context.targetRole}`;\r\n  const count = incrementCounterWindow(\r\n    key,\r\n    context.occurredAtMs,\r\n    config.privilegedRoleChangeWindowMinutes * 60 * 1000,\r\n  );\r\n  if (count < config.privilegedRoleChangeThreshold) {\r\n    return null;\r\n  }\r\n\r\n  const severity = chooseSeverity(\"high\", count, config.privilegedRoleChangeThreshold);\r\n  return {\r\n    ruleId: \"PRIVILEGED_ROLE_ASSIGNMENT_SPIKE\",\r\n    incidentType: \"Policy Violation\",\r\n    severity,\r\n    restrictedPiiInvolved: true,\r\n    observedCount: count,\r\n    windowMinutes: config.privilegedRoleChangeWindowMinutes,\r\n    affectedEmployeeEmail: context.targetEmployeeEmail || \"\",\r\n    title: \"Privileged role assignment spike detected\",\r\n    summary: `Detected ${count} privileged role assignments (${context.targetRole}) by ${context.actorEmail || \"unknown\"} within ${config.privilegedRoleChangeWindowMinutes} minute(s).`,\r\n    tags: [\"rbac\", \"role-assignment\", \"privilege\", \"ids\"],\r\n  };\r\n}\r\n\r\nfunction detectPotentialBreach(entry, context, config) {\r\n  const windowMs = config.breachWindowMinutes * 60 * 1000;\r\n  const actorKey = context.actorEmail || context.sourceIp || \"unknown\";\r\n\r\n  const isExportActivity =\r\n    context.moduleName.includes(\"export\") ||\r\n    context.requestPath.includes(\"/api/hris/exports\") ||\r\n    context.activityName.includes(\"export\");\r\n  const isExportCompleted =\r\n    isExportActivity && (context.status === \"approved\" || context.status === \"completed\");\r\n  if (isExportCompleted) {\r\n    incrementCounterWindow(`breach-export:${actorKey}`, context.occurredAtMs, windowMs);\r\n  }\r\n\r\n  const isPiiRead =\r\n    context.sensitivity === \"sensitive\" &&\r\n    context.moduleName.includes(\"employee records\") &&\r\n    (context.activityName.includes(\"view\") || context.activityName.includes(\"list\")) &&\r\n    (context.status === \"completed\" || context.status === \"approved\");\r\n  if (isPiiRead) {\r\n    incrementCounterWindow(`breach-pii:${actorKey}`, context.occurredAtMs, windowMs);\r\n  }\r\n\r\n  const isPermissionDenied =\r\n    isDeniedStatus(context.status) &&\r\n    (PERMISSION_DENIED_REASONS.has(context.reason) ||\r\n      context.activityName.includes(\"permission\") ||\r\n      context.activityName.includes(\"ownership\") ||\r\n      context.activityName.includes(\"forbidden\"));\r\n  if (isPermissionDenied) {\r\n    incrementCounterWindow(`breach-denied:${actorKey}`, context.occurredAtMs, windowMs);\r\n  }\r\n\r\n  const exportCount = getCounterCount(`breach-export:${actorKey}`, context.occurredAtMs, windowMs);\r\n  const piiCount = getCounterCount(`breach-pii:${actorKey}`, context.occurredAtMs, windowMs);\r\n  const deniedCount = getCounterCount(`breach-denied:${actorKey}`, context.occurredAtMs, windowMs);\r\n\r\n  const meetsExport = exportCount >= config.breachExportThreshold;\r\n  const meetsPii = piiCount >= config.breachPiiThreshold;\r\n  const meetsDenied = config.breachDeniedThreshold <= 0 || deniedCount >= config.breachDeniedThreshold;\r\n  if (!(meetsExport && meetsPii && meetsDenied)) {\r\n    return null;\r\n  }\r\n\r\n  const severity = chooseSeverity(\"high\", exportCount + piiCount + deniedCount, Math.max(1, config.breachExportThreshold));\r\n  return {\r\n    ruleId: \"POTENTIAL_BREACH_SIGNAL\",\r\n    incidentType: \"Data Exposure\",\r\n    severity,\r\n    restrictedPiiInvolved: true,\r\n    observedCount: exportCount + piiCount + deniedCount,\r\n    windowMinutes: config.breachWindowMinutes,\r\n    affectedEmployeeEmail: context.targetEmployeeEmail || context.actorEmail,\r\n    title: \"Potential breach indicators detected\",\r\n    summary: `Detected ${exportCount} export action(s), ${piiCount} PII access event(s), and ${deniedCount} access denial(s) for ${actorKey} within ${config.breachWindowMinutes} minute(s).`,\r\n    tags: [\"breach-signal\", \"export\", \"pii\", \"ids\"],\r\n  };\r\n}\r\n\r\nfunction detectSuspiciousEvent(entry, context, config) {\r\n  const rules = [\r\n    detectAuthFailureSpike,\r\n    detectPermissionDeniedSpike,\r\n    detectOffboardedAccessAttempt,\r\n    detectPrivilegedRoleAssignmentSpike,\r\n    detectExportSpike,\r\n    detectPiiAccessSpike,\r\n    detectPotentialBreach,\r\n  ];\r\n\r\n  for (const detect of rules) {\r\n    const match = detect(entry, context, config);\r\n    if (match) {\r\n      return match;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction toNotificationTitle(incident, detection) {\r\n  return asString(incident?.title || detection?.title, \"Security anomaly detected\");\r\n}\r\n\r\nfunction toNotificationMessage(incident, detection) {\r\n  const severity = asString(incident?.severity || detection?.severity, \"Medium\");\r\n  const code = asString(incident?.incidentCode, \"INCIDENT\");\r\n  const summary = asString(incident?.summary || detection?.summary, \"Review incident workbench for containment.\");\r\n  return `[${severity}] ${code}: ${summary}`;\r\n}\r\n\r\nfunction parseRoleEmails(value) {\r\n  return asString(value)\r\n    .split(\",\")\r\n    .map((item) => normalizeEmail(item))\r\n    .filter(Boolean);\r\n}\r\n\r\nfunction resolveOwnerEmail(entry, detection) {\r\n  const preferredOwner =\r\n    normalizeEmail(process.env.CLIO_GRC_ALERT_EMAIL) ||\r\n    parseRoleEmails(process.env.GRC_EMAILS)[0] ||\r\n    parseRoleEmails(process.env.SUPER_ADMIN_EMAILS)[0];\r\n  if (preferredOwner) {\r\n    return preferredOwner;\r\n  }\r\n  return normalizeEmail(detection?.affectedEmployeeEmail || entry?.metadata?.ownerEmail || entry?.performedBy || DEFAULT_SYSTEM_ACTOR);\r\n}\r\n\r\nasync function resolveAlertRecipients(entry, detection, incident, config) {\r\n  const owner = resolveOwnerEmail(entry, detection) || normalizeEmail(incident?.ownerEmail);\r\n  const resolved = await resolveIncidentStakeholderRecipients({\r\n    ownerEmail: owner,\r\n    affectedEmployeeEmail: normalizeEmail(detection?.affectedEmployeeEmail),\r\n    actorEmail: normalizeEmail(entry?.performedBy),\r\n    includeAffectedEmployee: true,\r\n    includeActor: true,\r\n  });\r\n  const withExplicitSecurityRecipients = resolveSecurityAlertEmailRecipients(resolved);\r\n  return withExplicitSecurityRecipients.slice(0, config.maxRecipientCount);\r\n}\r\n\r\nfunction buildActionUrl(config, incidentId) {\r\n  if (!incidentId) {\r\n    return \"/incident-management\";\r\n  }\r\n  return `/incident-management?incident=${encodeURIComponent(incidentId)}`;\r\n}\r\n\r\nfunction buildAbsoluteActionUrl(config, actionPath) {\r\n  const base = asString(config?.appBaseUrl).replace(/\\/+$/, \"\");\r\n  const path = asString(actionPath, \"/incident-management\");\r\n  if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\r\n    return path;\r\n  }\r\n  if (!base) {\r\n    return path.startsWith(\"/\") ? path : `/${path}`;\r\n  }\r\n  return `${base}${path.startsWith(\"/\") ? path : `/${path}`}`;\r\n}\r\n\r\nfunction getRetryDelaySeconds(attempt, config) {\r\n  const safeAttempt = Math.max(1, Number(attempt || 1));\r\n  const baseSeconds = Math.max(5, Number(config?.retryBaseBackoffSeconds || 30));\r\n  const maxSeconds = Math.max(baseSeconds, Number(config?.retryMaxBackoffSeconds || 1800));\r\n  return Math.min(maxSeconds, baseSeconds * Math.pow(2, Math.max(0, safeAttempt - 1)));\r\n}\r\n\r\nfunction buildRetryQueueEntry({\r\n  entry,\r\n  detection,\r\n  fingerprint,\r\n  correlationKey,\r\n  errorMessage,\r\n  config,\r\n  attempts = 1,\r\n  source = \"live\",\r\n  queuedAtIso = nowIso(),\r\n}) {\r\n  const safeAttempts = Math.max(1, Number(attempts || 1));\r\n  const delaySeconds = getRetryDelaySeconds(safeAttempts, config);\r\n  const nextAttemptAt = new Date(Date.now() + delaySeconds * 1000).toISOString();\r\n  return {\r\n    status: \"pending\",\r\n    source: asString(source, \"live\"),\r\n    attempts: safeAttempts,\r\n    maxAttempts: Math.max(1, Number(config?.retryMaxAttempts || 5)),\r\n    nextAttemptAt,\r\n    lastError: asString(errorMessage, \"ids_processing_failed\"),\r\n    fingerprint: asString(fingerprint),\r\n    correlationKey: asString(correlationKey),\r\n    entry: asObject(entry),\r\n    detection: asObject(detection),\r\n    createdAt: queuedAtIso,\r\n    updatedAt: queuedAtIso,\r\n  };\r\n}\r\n\r\nasync function enqueueDetectionRetryWorkItem({\r\n  entry,\r\n  detection,\r\n  fingerprint,\r\n  correlationKey,\r\n  errorMessage,\r\n  config,\r\n  attempts = 1,\r\n  source = \"live\",\r\n}) {\r\n  if (!config?.retryEnabled) {\r\n    return {\r\n      queued: false,\r\n      reason: \"retry_disabled\",\r\n    };\r\n  }\r\n\r\n  const db = getDetectionQueueDb();\r\n  if (!db) {\r\n    return {\r\n      queued: false,\r\n      reason: \"retry_queue_unavailable\",\r\n    };\r\n  }\r\n\r\n  const now = nowIso();\r\n  const payload = buildRetryQueueEntry({\r\n    entry,\r\n    detection,\r\n    fingerprint,\r\n    correlationKey,\r\n    errorMessage,\r\n    config,\r\n    attempts,\r\n    source,\r\n    queuedAtIso: now,\r\n  });\r\n  const ref = await addDoc(collection(db, config.retryCollectionName), payload);\r\n  return {\r\n    queued: true,\r\n    retryRecordId: ref.id,\r\n    attempts: payload.attempts,\r\n    nextAttemptAt: payload.nextAttemptAt,\r\n  };\r\n}\r\n\r\nasync function listDueRetryQueueRecords(config, { batchSize } = {}) {\r\n  const db = getDetectionQueueDb();\r\n  if (!db) {\r\n    return [];\r\n  }\r\n\r\n  const limitValue = Math.max(1, Number(batchSize || config?.retryBatchSize || 8));\r\n  const scanLimit = Math.max(limitValue * 3, 16);\r\n  const snapshot = await getDocs(\r\n    query(\r\n      collection(db, config.retryCollectionName),\r\n      orderBy(\"nextAttemptAt\", \"asc\"),\r\n      queryLimit(scanLimit),\r\n    ),\r\n  );\r\n  const nowMs = Date.now();\r\n  return snapshot.docs\r\n    .map((docSnapshot) => ({\r\n      id: docSnapshot.id,\r\n      ...(docSnapshot.data() || {}),\r\n    }))\r\n    .filter((row) => normalizeText(row?.status || \"pending\") === \"pending\")\r\n    .filter((row) => {\r\n      const nextAttemptMs = toTimeMs(row?.nextAttemptAt);\r\n      return !Number.isFinite(nextAttemptMs) || nextAttemptMs <= nowMs;\r\n    })\r\n    .slice(0, limitValue);\r\n}\r\n\r\nasync function moveRetryRecordToDeadLetter(config, record, reason) {\r\n  const db = getDetectionQueueDb();\r\n  if (!db) {\r\n    return null;\r\n  }\r\n\r\n  const payload = {\r\n    ...record,\r\n    status: \"dead-letter\",\r\n    deadLetteredAt: nowIso(),\r\n    deadLetterReason: asString(reason, \"ids_retry_exhausted\"),\r\n    originalRetryRecordId: asString(record?.id),\r\n  };\r\n  const ref = await addDoc(collection(db, config.deadLetterCollectionName), payload);\r\n  return ref.id;\r\n}\r\n\r\nasync function updateRetryQueueRecord(config, recordId, patch) {\r\n  const db = getDetectionQueueDb();\r\n  if (!db) {\r\n    return;\r\n  }\r\n  await updateDoc(doc(db, config.retryCollectionName, recordId), {\r\n    ...patch,\r\n    updatedAt: nowIso(),\r\n  });\r\n}\r\n\r\nasync function deleteRetryQueueRecord(config, recordId) {\r\n  const db = getDetectionQueueDb();\r\n  if (!db) {\r\n    return;\r\n  }\r\n  await deleteDoc(doc(db, config.retryCollectionName, recordId));\r\n}\r\n\r\nasync function findConsolidationIncident({ correlationKey, fingerprint, nowMs, config }) {\r\n  let rows = [];\r\n  try {\r\n    rows = await listIncidentRecordsBackend();\r\n  } catch {\r\n    rows = [];\r\n  }\r\n\r\n  const exactActiveMatch = asArray(rows).find((row) => {\r\n    if (!isIncidentOpenForConsolidation(row?.status)) {\r\n      return false;\r\n    }\r\n    const currentCorrelationKey = asString(row?.detectionCorrelationKey);\r\n    if (currentCorrelationKey && currentCorrelationKey === correlationKey) {\r\n      return true;\r\n    }\r\n    const currentFingerprint = asString(row?.detectionFingerprint);\r\n    return Boolean(currentFingerprint && currentFingerprint === fingerprint);\r\n  });\r\n  if (exactActiveMatch) {\r\n    return exactActiveMatch;\r\n  }\r\n\r\n  if (isInIncidentCooldown(fingerprint, nowMs)) {\r\n    return { id: \"\", duplicateOnly: true };\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nasync function mergeDetectionIntoIncident({\r\n  incident,\r\n  entry,\r\n  detection,\r\n  correlationKey,\r\n  fingerprint,\r\n  nowMs,\r\n  config,\r\n}) {\r\n  if (!incident?.id) {\r\n    return null;\r\n  }\r\n  const nextCount = Math.max(1, Number(incident?.alertOccurrenceCount || 1)) + 1;\r\n  const previousOccurrences = asArray(incident?.alertOccurrences).slice(-39);\r\n  const nextOccurrences = [...previousOccurrences, toDetectionOccurrenceEntry(entry)];\r\n  const patchPayload = {\r\n    detectionFingerprint: asString(incident?.detectionFingerprint || fingerprint),\r\n    detectionCorrelationKey: asString(incident?.detectionCorrelationKey || correlationKey),\r\n    detectionWindowEnd: new Date(nowMs).toISOString(),\r\n    alertDescription: detection.summary,\r\n    alertOccurrenceCount: nextCount,\r\n    alertFirstObservedAt: asString(incident?.alertFirstObservedAt || incident?.detectedAt || nowIso()),\r\n    alertLastObservedAt: asString(entry?.occurredAt, nowIso()),\r\n    alertOccurrences: nextOccurrences,\r\n    summary: detection.summary,\r\n    notes: [\r\n      asString(incident?.notes),\r\n      `Latest alert occurrence #${nextCount}: ${asString(entry?.activityName, \"Activity\")} | ${asString(entry?.module, \"System\")} | ${asString(entry?.occurredAt, nowIso())} | Source IP: ${asString(entry?.metadata?.sourceIp || entry?.sourceIp, \"unknown\")}`,\r\n    ]\r\n      .filter(Boolean)\r\n      .join(\"\\n\"),\r\n  };\r\n\r\n  const updated = await updateIncidentRecordBackend(incident.id, patchPayload, config.systemActorEmail);\r\n  rememberIncidentCooldown(fingerprint, nowMs, config.incidentCooldownMinutes);\r\n  return updated;\r\n}\r\n\r\nasync function createAutoIncident(entry, detection, config, fingerprint, correlationKey, nowMs) {\r\n  const occurredAt = asString(entry?.occurredAt, nowIso());\r\n  const ownerEmail = resolveOwnerEmail(entry, detection);\r\n  const actorEmail = config.systemActorEmail || DEFAULT_SYSTEM_ACTOR;\r\n  const sourceMetadata = asObject(entry?.metadata);\r\n  const targetEmployee = asString(\r\n    sourceMetadata.targetEmployeeEmail || sourceMetadata.employeeEmail || detection.affectedEmployeeEmail,\r\n    \"\",\r\n  );\r\n  const recordLabel = asString(sourceMetadata.resourceLabel || sourceMetadata.recordRef || sourceMetadata.recordId, \"\");\r\n  const viewedFields = asArray(sourceMetadata.viewedFields, []);\r\n  const accessedDocuments = asArray(sourceMetadata.accessedDocuments, []);\r\n  const firstObservedAt = asString(entry?.occurredAt, nowIso());\r\n  const firstOccurrence = toDetectionOccurrenceEntry(entry);\r\n  const payload = {\r\n    title: detection.title,\r\n    summary: detection.summary,\r\n    incidentType: detection.incidentType,\r\n    severity: detection.severity,\r\n    status: \"Open\",\r\n    restrictedPiiInvolved: Boolean(detection.restrictedPiiInvolved),\r\n    affectedEmployeeEmail: normalizeEmail(detection.affectedEmployeeEmail || sourceMetadata.targetEmployeeEmail || \"\"),\r\n    ownerEmail,\r\n    detectedAt: occurredAt,\r\n    escalationRequired: true,\r\n    containmentStatus: \"Not Started\",\r\n    impactAssessmentStatus: \"Pending\",\r\n    regulatoryNotificationRequired: Boolean(detection.restrictedPiiInvolved),\r\n    documentationRetained: true,\r\n    classificationStandard: \"CLIO-IDS-V1\",\r\n    notes: [\r\n      `Auto-generated by CLIO IDS rule: ${detection.ruleId}`,\r\n      `Observed count: ${Number(detection.observedCount || 0)}`,\r\n      `Window: ${Number(detection.windowMinutes || 0)} minute(s)`,\r\n      targetEmployee ? `Target employee: ${targetEmployee}` : null,\r\n      recordLabel ? `Record reference: ${recordLabel}` : null,\r\n      viewedFields.length > 0 ? `Viewed fields: ${viewedFields.slice(0, 12).join(\", \")}` : null,\r\n      accessedDocuments.length > 0\r\n        ? `Accessed documents: ${accessedDocuments\r\n            .map((doc) => asString(doc?.name || doc?.ref || doc?.id))\r\n            .filter(Boolean)\r\n            .slice(0, 6)\r\n            .join(\", \")}`\r\n        : null,\r\n      `Source event: ${asString(entry?.id, \"N/A\")} | ${asString(entry?.module, \"System\")} | ${asString(entry?.activityName, \"Activity\")}`,\r\n      `Source IP: ${asString(sourceMetadata.sourceIp || entry?.sourceIp, \"unknown\")}`,\r\n      `Request: ${asString(sourceMetadata.requestMethod || entry?.requestMethod, \"GET\")} ${asString(sourceMetadata.requestPath || entry?.requestPath, \"unknown\")}`,\r\n    ]\r\n      .filter(Boolean)\r\n      .join(\"\\n\"),\r\n    autoGenerated: true,\r\n    detectionRuleId: detection.ruleId,\r\n    detectionFingerprint: fingerprint,\r\n    detectionCorrelationKey: correlationKey,\r\n    detectionWindowStart: new Date(nowMs - detection.windowMinutes * 60 * 1000).toISOString(),\r\n    detectionWindowEnd: new Date(nowMs).toISOString(),\r\n    alertDescription: detection.summary,\r\n    alertOccurrenceCount: 1,\r\n    alertFirstObservedAt: firstObservedAt,\r\n    alertLastObservedAt: firstObservedAt,\r\n    alertOccurrences: [firstOccurrence],\r\n    sourceSystem: \"CLIO_IDS\",\r\n    sourceEventId: asString(entry?.id),\r\n    sourceEventModule: asString(entry?.module),\r\n    sourceEventPath: asString(sourceMetadata.requestPath || entry?.requestPath),\r\n    sourceIp: asString(sourceMetadata.sourceIp || entry?.sourceIp),\r\n    alertRecipients: [],\r\n    actionUrl: \"/incident-management\",\r\n  };\r\n\r\n  const created = await createIncidentRecordBackend(payload, actorEmail);\r\n  rememberIncidentCooldown(fingerprint, nowMs, config.incidentCooldownMinutes);\r\n  return created;\r\n}\r\n\r\nasync function createInAppIncidentNotifications({\r\n  incident,\r\n  detection,\r\n  recipients,\r\n  actionUrl,\r\n  actorEmail,\r\n}) {\r\n  const notifications = recipients.map((recipientEmail) => ({\r\n    recipientEmail,\r\n    title: toNotificationTitle(incident, detection),\r\n    message: toNotificationMessage(incident, detection),\r\n    severity: normalizeText(incident?.severity || detection?.severity || \"medium\"),\r\n    type: \"security-anomaly\",\r\n    module: \"Incident Management\",\r\n    actionUrl,\r\n    status: \"unread\",\r\n    createdBy: actorEmail,\r\n    metadata: {\r\n      incidentId: asString(incident?.id || incident?.recordId),\r\n      incidentCode: asString(incident?.incidentCode),\r\n      detectionRuleId: asString(detection?.ruleId),\r\n      autoGenerated: true,\r\n    },\r\n  }));\r\n  return await createInAppNotificationsBulk(notifications);\r\n}\r\n\r\nasync function executeDetectionWorkflow({\r\n  entry,\r\n  detection,\r\n  config,\r\n  fingerprint,\r\n  correlationKey,\r\n  nowMs,\r\n}) {\r\n  const existingIncident = await findConsolidationIncident({\r\n    correlationKey,\r\n    fingerprint,\r\n    nowMs,\r\n    config,\r\n  });\r\n  if (existingIncident?.duplicateOnly) {\r\n    return {\r\n      detected: true,\r\n      duplicate: true,\r\n      detection,\r\n      fingerprint,\r\n      correlationKey,\r\n    };\r\n  }\r\n  if (existingIncident?.id) {\r\n    const updatedIncident = await mergeDetectionIntoIncident({\r\n      incident: existingIncident,\r\n      entry,\r\n      detection,\r\n      correlationKey,\r\n      fingerprint,\r\n      nowMs,\r\n      config,\r\n    });\r\n    return {\r\n      detected: true,\r\n      duplicate: true,\r\n      consolidated: true,\r\n      detection,\r\n      fingerprint,\r\n      correlationKey,\r\n      incidentRecord: updatedIncident || existingIncident,\r\n    };\r\n  }\r\n\r\n  const incident = await createAutoIncident(entry, detection, config, fingerprint, correlationKey, nowMs);\r\n  const actionUrl = buildActionUrl(config, incident?.id || incident?.recordId);\r\n  const absoluteActionUrl = buildAbsoluteActionUrl(config, actionUrl);\r\n  const recipients = await resolveAlertRecipients(entry, detection, incident, config);\r\n  const inAppNotifications = await createInAppIncidentNotifications({\r\n    incident,\r\n    detection,\r\n    recipients,\r\n    actionUrl,\r\n    actorEmail: config.systemActorEmail,\r\n  });\r\n  const deliverySummary = await dispatchSecurityIncidentAlerts({\r\n    incident: {\r\n      ...incident,\r\n      actionUrl: absoluteActionUrl,\r\n    },\r\n    detection,\r\n    sourceEvent: entry,\r\n    emailRecipients: recipients,\r\n  });\r\n\r\n  const patchPayload = {\r\n    alertRecipients: recipients,\r\n    alertDispatchSummary: deliverySummary,\r\n    externalIntegrations: {\r\n      webhooks: deliverySummary?.webhooks || {},\r\n    },\r\n    lastAlertDispatchAt: nowIso(),\r\n  };\r\n  await updateIncidentRecordBackend(incident.id, patchPayload, config.systemActorEmail).catch(() => null);\r\n\r\n  return {\r\n    detected: true,\r\n    duplicate: false,\r\n    detection,\r\n    incidentRecord: incident,\r\n    fingerprint,\r\n    recipients,\r\n    inAppNotificationCount: inAppNotifications.length,\r\n    deliverySummary,\r\n  };\r\n}\r\n\r\nfunction hasForcedDetectionPayload(value) {\r\n  return Boolean(value && typeof value === \"object\" && !Array.isArray(value));\r\n}\r\n\r\nasync function processSingleRetryQueueRecord(config, row) {\r\n  const recordId = asString(row?.id);\r\n  if (!recordId) {\r\n    return { processed: false, reason: \"missing_retry_record_id\" };\r\n  }\r\n\r\n  const attempts = Math.max(1, Number(row?.attempts || 1));\r\n  const maxAttempts = Math.max(1, Number(row?.maxAttempts || config.retryMaxAttempts || 5));\r\n  const entry = asObject(row?.entry);\r\n  const detection = asObject(row?.detection);\r\n  const fingerprint = asString(row?.fingerprint);\r\n  const correlationKey = asString(row?.correlationKey);\r\n  if (!fingerprint || !asString(detection?.ruleId) || (!asString(entry?.activityName) && !asString(entry?.module))) {\r\n    await moveRetryRecordToDeadLetter(config, row, \"invalid_retry_payload\");\r\n    await deleteRetryQueueRecord(config, recordId);\r\n    return { processed: false, deadLettered: true, reason: \"invalid_retry_payload\" };\r\n  }\r\n\r\n  const result = await processAuditEventForSecurityDetections(entry, {\r\n    forcedDetection: detection,\r\n    forcedFingerprint: fingerprint,\r\n    forcedCorrelationKey: correlationKey,\r\n    skipQueueOnError: true,\r\n    disableQueueDrain: true,\r\n  });\r\n\r\n  if (!result?.failed) {\r\n    await deleteRetryQueueRecord(config, recordId);\r\n    return {\r\n      processed: true,\r\n      duplicate: Boolean(result?.duplicate),\r\n      detected: Boolean(result?.detected),\r\n    };\r\n  }\r\n\r\n  const nextAttempts = attempts + 1;\r\n  const errorMessage = asString(result?.error, \"ids_processing_failed\");\r\n  if (nextAttempts > maxAttempts) {\r\n    await moveRetryRecordToDeadLetter(config, {\r\n      ...row,\r\n      attempts: nextAttempts,\r\n      maxAttempts,\r\n      lastError: errorMessage,\r\n    }, errorMessage);\r\n    await deleteRetryQueueRecord(config, recordId);\r\n    return {\r\n      processed: false,\r\n      deadLettered: true,\r\n      reason: errorMessage,\r\n    };\r\n  }\r\n\r\n  const nextAttemptAt = new Date(Date.now() + getRetryDelaySeconds(nextAttempts, config) * 1000).toISOString();\r\n  await updateRetryQueueRecord(config, recordId, {\r\n    attempts: nextAttempts,\r\n    maxAttempts,\r\n    nextAttemptAt,\r\n    lastError: errorMessage,\r\n    status: \"pending\",\r\n  });\r\n\r\n  return {\r\n    processed: false,\r\n    retried: true,\r\n    reason: errorMessage,\r\n    nextAttemptAt,\r\n  };\r\n}\r\n\r\nexport async function drainSecurityDetectionRetryQueue({ reason = \"manual\", batchSize } = {}) {\r\n  const config = getDetectionConfig();\r\n  if (!config.enabled || !config.retryEnabled) {\r\n    return {\r\n      processedCount: 0,\r\n      reason: !config.enabled ? \"ids_disabled\" : \"retry_disabled\",\r\n    };\r\n  }\r\n\r\n  if (IDS_RETRY_DRAIN_PROMISE) {\r\n    return IDS_RETRY_DRAIN_PROMISE;\r\n  }\r\n\r\n  IDS_RETRY_DRAIN_PROMISE = (async () => {\r\n    const dueRecords = await listDueRetryQueueRecords(config, {\r\n      batchSize: Number(batchSize || config.retryBatchSize || 8),\r\n    });\r\n    let processedCount = 0;\r\n    let deadLetterCount = 0;\r\n    let failedCount = 0;\r\n\r\n    for (const row of dueRecords) {\r\n      try {\r\n        const result = await processSingleRetryQueueRecord(config, row);\r\n        if (result?.processed) {\r\n          processedCount += 1;\r\n        }\r\n        if (result?.deadLettered) {\r\n          deadLetterCount += 1;\r\n        }\r\n      } catch {\r\n        failedCount += 1;\r\n      }\r\n    }\r\n\r\n    return {\r\n      reason: asString(reason, \"manual\"),\r\n      processedCount,\r\n      deadLetterCount,\r\n      failedCount,\r\n      dueCount: dueRecords.length,\r\n    };\r\n  })();\r\n\r\n  try {\r\n    return await IDS_RETRY_DRAIN_PROMISE;\r\n  } finally {\r\n    IDS_RETRY_DRAIN_PROMISE = null;\r\n  }\r\n}\r\n\r\nexport async function processAuditEventForSecurityDetections(entry, options = {}) {\r\n  const config = getDetectionConfig();\r\n  if (!config.enabled) {\r\n    return {\r\n      detected: false,\r\n      reason: \"ids_disabled\",\r\n    };\r\n  }\r\n\r\n  if (!entry || typeof entry !== \"object\") {\r\n    return {\r\n      detected: false,\r\n      reason: \"invalid_audit_entry\",\r\n    };\r\n  }\r\n\r\n  if (!options?.disableQueueDrain && config.retryEnabled) {\r\n    void drainSecurityDetectionRetryQueue({ reason: \"audit-event\" }).catch(() => null);\r\n  }\r\n\r\n  const forcedDetection = hasForcedDetectionPayload(options?.forcedDetection)\r\n    ? options.forcedDetection\r\n    : null;\r\n  if (!forcedDetection && shouldSkipEvent(entry)) {\r\n    return {\r\n      detected: false,\r\n      reason: \"event_skipped\",\r\n    };\r\n  }\r\n\r\n  const context = extractEventContext(entry);\r\n  const detection = forcedDetection || detectSuspiciousEvent(entry, context, config);\r\n  if (!detection) {\r\n    return {\r\n      detected: false,\r\n      reason: \"no_rule_match\",\r\n    };\r\n  }\r\n\r\n  const nowMs = context.occurredAtMs || Date.now();\r\n  const fingerprint =\r\n    asString(options?.forcedFingerprint) ||\r\n    buildFingerprint(\r\n      detection.ruleId,\r\n      entry,\r\n      detection,\r\n      nowMs,\r\n      detection.windowMinutes || config.incidentCooldownMinutes,\r\n    );\r\n  const correlationKey =\r\n    asString(options?.forcedCorrelationKey) || buildCorrelationKey(detection.ruleId, entry, detection);\r\n\r\n  try {\r\n    return await executeDetectionWorkflow({\r\n      entry,\r\n      detection,\r\n      config,\r\n      fingerprint,\r\n      correlationKey,\r\n      nowMs,\r\n    });\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? asString(error.message, \"ids_processing_failed\") : \"ids_processing_failed\";\r\n    if (options?.skipQueueOnError) {\r\n      return {\r\n        detected: true,\r\n        duplicate: false,\r\n        failed: true,\r\n        detection,\r\n        fingerprint,\r\n        reason: \"processing_failed\",\r\n        error: errorMessage,\r\n      };\r\n    }\r\n\r\n    const queueResult = await enqueueDetectionRetryWorkItem({\r\n      entry,\r\n      detection,\r\n      fingerprint,\r\n      correlationKey,\r\n      errorMessage,\r\n      config,\r\n      attempts: 1,\r\n      source: \"live\",\r\n    });\r\n    return {\r\n      detected: true,\r\n      duplicate: false,\r\n      failed: true,\r\n      queuedForRetry: Boolean(queueResult?.queued),\r\n      retryRecordId: asString(queueResult?.retryRecordId),\r\n      detection,\r\n      fingerprint,\r\n      reason: \"processing_failed\",\r\n      error: errorMessage,\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":"uCAAA,EAAA,CAAA,CAAA,MAAA,IAAA,EAAA,EAAA,CAAA,CAAA,OAYA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OAWA,EAAA,CAAA,CAAA,OACA,IAAA,EAAA,EAAA,CAAA,CAAA,MAoIA,IAAM,EAA2B,CAAC,MAAO,OAAO,CAC1C,EAAyB,CAAC,OAAQ,cAAe,gBAAiB,YAAa,oBAAqB,WAAY,SAAS,CACzH,EAAqC,CAAC,cAAe,cAAe,YAAY,CAChF,EAAgC,CAAC,UAAW,cAAe,YAAY,CACvE,EAAuB,CAC3B,sBACA,gBACA,wBACA,iBACA,uBACA,mBACA,0BACA,QACD,CAEK,EAA+C,IAAI,IAAI,CAC3D,MACA,MACA,MACA,OACA,OACA,MACA,OACA,MACA,OACA,MACA,MACD,EACK,EAA+C,IAAI,IAAI,CAC3D,kBACA,YACA,aACA,aACA,qBACA,0EACA,2BACA,oEACA,WACA,aACD,EAED,SAAS,EAAI,CAAI,CAAE,CAAQ,EAEzB,OAAO,AADO,OAAO,QAAQ,GAAG,CAAC,EAAK,EAAI,IAAI,IAAI,IAClC,CAClB,CAYA,SAAS,EAAY,CAAK,CAAE,CAAW,EACrC,IAAM,EAAa,OAAO,GAAS,IAChC,KAAK,CAAC,KACN,GAAG,CAAC,AAAC,GAAS,OAAO,GAAQ,IAAI,IAAI,GAAG,WAAW,IACnD,MAAM,CAAC,oBAEG,IADT,AAAsB,GAAG,GAAd,MAAM,CACJ,IAAI,EAAY,CAElB,EACjB,CA+CA,SAAS,IACP,OAAO,IAAI,OAAO,WAAW,EAC/B,CAqBA,SAAS,EAAS,CAAK,CAAE,EAAW,EAAE,EAEpC,OADmB,AACZ,OADmB,GAAS,IAAI,IAAI,IACtB,CACvB,CAEA,SAAS,EAAc,CAAK,EAC1B,OAAO,OAAO,GAAS,IACpB,IAAI,GACJ,WAAW,EAChB,CAEA,SAAS,EAAe,CAAK,EAC3B,OAAO,OAAO,GAAS,IAAI,IAAI,GAAG,WAAW,EAC/C,CA2FA,SAAS,EAAQ,CAAK,EACpB,OAAO,MAAM,OAAO,CAAC,GAAS,EAAQ,EAAE,AAC1C,CAEA,SAAS,EAAS,CAAK,CAAE,EAAW,CAAC,CAAC,SACpC,AAAI,GAAS,AAAiB,iBAAV,GAAsB,CAAC,MAAM,OAAO,CAAC,GAChD,EAEF,CACT,CAEA,CANmE,QAM1D,EAAU,CAAK,CAAE,GAAW,CAAK,EACxC,GAAqB,WAAjB,AAA4B,OAArB,EACT,OAAO,EAET,GAAI,AAAiB,UAAU,OAApB,EACT,OAAiB,IAAV,EAET,GAAqB,UAAjB,OAAO,EAAoB,CAC7B,IAAM,EAAa,EAAM,IAAI,GAAG,WAAW,GAC3C,GAAI,CAAC,EACH,OAAO,EAET,CAHiB,EAGb,CAAC,OAAQ,IAAK,MAAO,IAAK,KAAK,CAAC,QAAQ,CAAC,GAC3C,OAAO,EAET,CAH0D,EAGtD,CAAC,QAAS,IAAK,KAAM,IAAK,MAAM,CAAC,QAAQ,CAAC,GAC5C,OAAO,CAEX,CACA,CAJ6D,MAItD,CACT,CAgzBA,SAAS,EAAgB,CAAC,CAAE,CAAC,EAC3B,OAAO,IAAI,KAAK,EAAE,SAAS,EAAI,EAAE,SAAS,EAAI,GAAG,OAAO,GAAK,IAAI,KAAK,EAAE,SAAS,EAAI,EAAE,SAAS,EAAI,GAAG,OAAO,EAChH,CAEA,SAAS,EAAkB,CAAG,EAY5B,MAAO,CAXK,CACV,UAAW,EAAI,sCAAuC,aACtD,UAAW,EAAI,sCAAuC,wBACtD,WAAY,EAAI,uCAAwC,cACxD,MAAO,EAAI,kCAAmC,kBAC9C,YAAa,EAAI,wCAAyC,uBAC1D,UAAW,EAAI,sCAAuC,sBACtD,QAAS,EAAI,oCAAqC,mBAClD,UAAW,EAAI,sCAAuC,sBACtD,kBAAmB,EAAI,+CAAgD,2BACzE,CACU,CAAC,EAAI,EAAI,CACrB,CAMA,SAAS,IACP,GAAI,CAAC,CAAA,EAAA,EAAA,kBAAA,AAAkB,IACrB,CADyB,KACnB,AAAI,MAAM,4BAElB,IAAM,EAAK,CAAA,EAAA,EAAA,cAAA,AAAc,IACzB,GAAI,CAAC,EACH,EADO,IACD,AAAI,MAAM,4BAElB,OAAO,CACT,CAEA,eAAe,EAAsB,CAAc,CAAE,aAAE,CAAW,aAAE,CAAW,CAAE,CAAG,CAAC,CAAC,EACpF,IAAM,EAAK,IACL,EAAM,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAI,GAQ3B,MAAO,CANH,GAAsC,UAAvB,OAAO,GAA4B,EAAY,IAAI,GACzD,CAD6D,KACvD,CAAA,EAAA,EAAA,OAAO,AAAP,EAAQ,CAAA,EAAA,EAAA,KAAA,AAAK,EAAC,EAAK,CAAA,EAAA,EAAA,KAAA,AAAK,EAAC,EAAa,KAAM,EAAY,IAAI,MAElE,MAAM,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,IAGX,IAAI,CACjB,GAAG,CAAC,AAAC,IAAU,CACd,EADa,CACV,EAAK,IAAI,EAAE,CACd,GAAI,EAAK,EAAE,CACX,SAAU,EAAK,EAAE,CACnB,CAAC,EACA,IAAI,CAAC,EACV,CAEA,eAAe,EAAwB,CAAc,CAAE,CAAQ,EAC7D,IAAM,EAAK,IACL,EAAe,EAAS,GAC9B,GAAI,CAAC,EACH,MAAU,AAAJ,MAAU,AADC,qBAInB,IAAM,EAAM,CAAA,EAAA,EAAA,GAAA,AAAG,EAAC,EAAI,EAAgB,GAC9B,EAAW,MAAM,CAAA,EAAA,EAAA,MAAA,AAAM,EAAC,UAC9B,AAAK,EAAS,EAAV,IAAgB,GAGb,CAHiB,AAItB,GAAG,EAAS,IAAI,EAAE,CAClB,GAAI,EAAS,EAAE,CACf,SAAU,EAAS,EAAE,AACvB,EANS,IAOX,CAEA,eAAe,EAAuB,CAAc,CAAE,CAAO,EAC3D,IAAM,EAAK,IACL,EAAM,MAAM,CAAA,EAAA,EAAA,MAAA,AAAM,EAAC,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAI,GAAiB,GACzD,MAAO,CACL,GAAG,CAAO,CACV,GAAI,EAAI,EAAE,CACV,SAAU,EAAI,EAAE,AAClB,CACF,CAEA,eAAe,EAAuB,CAAc,CAAE,CAAQ,CAAE,CAAO,EACrE,IAAM,EAAK,IACL,EAAe,EAAS,GAC9B,GAAI,CAAC,EACH,MAAU,AAAJ,MAAU,AADC,qBAInB,IAAM,EAAM,CAAA,EAAA,EAAA,GAAA,AAAG,EAAC,EAAI,EAAgB,GAC9B,EAAW,MAAM,CAAA,EAAA,EAAA,MAAA,AAAM,EAAC,GAC9B,GAAI,CAAC,EAAS,MAAM,GAClB,CADsB,MACf,KAIT,IAAM,EAAO,CADuB,GAApB,EAAS,IAAI,IAAM,CAAC,CAElC,CACA,EADG,CACA,CAAO,AACZ,EAEA,GAJY,IAGZ,MAAM,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,EAAK,GACd,CACL,GAAG,CAAI,CACP,GAAI,EAAS,EAAE,CACf,SAAU,EAAS,EACrB,AADuB,CAEzB,CA06CA,SAAS,EAA0B,CAAK,CAAE,EAAW,KAAK,EACxD,IAAM,EAAa,EAAS,EAAO,GAAU,WAAW,SACxD,AAAI,AAAe,YAAY,GACtB,OAEU,UAAU,CAAzB,EACK,MAGF,AADS,EAAyB,IAAI,CAAC,AAAC,GAAU,EAAM,WAAW,KAAO,IAC/D,KACpB,CA2JA,SAAS,EAAqB,CAAK,QAEjC,EACO,KADC,IADS,EAA0B,GAO7C,CA0FA,eAAe,EAA8B,CAAM,CAAE,CAAE,OAAK,CAAE,CAAG,CAAC,CAAC,EACjE,IAAM,EAAc,IACd,EAAc,EAAa,GAAQ,qBAAuB,GAAQ,aAAe,EACjF,EAAY,EAAa,GAAQ,mBAAqB,IAAgB,EACtE,EAAgB,EAAS,IAAgB,EACzC,EAAc,EAAS,IAAc,KAAK,GAAG,GAC7C,EAAe,EAAe,GAAQ,uBAAyB,GAAQ,eAAiB,IACxF,EAAY,OAAO,QAAQ,CAAC,OAAO,IAAU,OAAO,GAAS,KAE/D,EAAO,EAAE,CACb,GAAI,CACF,EAAO,MAAM,CAAA,EAAA,EAAA,eAAA,AAAe,EAAC,CAAE,MAAO,KAAK,GAAG,CAAC,IAAK,KAAK,GAAG,CAAC,IAAM,GAAY,EACjF,CAAE,KAAM,CACN,EAAO,EAAE,AACX,CAEA,IAAM,EAAa,EAAK,MAAM,CAAC,AAAC,IAC9B,IAAM,EAAe,EAAS,GAAK,YAAc,GAAK,UACtD,GAAI,CAAC,OAAO,QAAQ,CAAC,IAGjB,EAAe,GAAiB,EAAe,EAFjD,EADkC,KAC3B,EArCX,EAuCkE,EAvC5D,EAAU,EA0CqB,GAzCrC,GAAI,CAAC,EACH,IAF6B,GAEtB,AADK,EAId,IAAM,EAAW,KAAc,IAAL,KAAe,CAAC,GAU1C,MATmB,AASZ,IARA,YAmCyB,GAlCzB,iBACL,EAAS,aAAa,CACtB,EAAS,UAAU,CACnB,EAAS,WAAW,CACpB,EAAS,mBAAmB,CAC5B,EAAS,qBAAqB,CAC/B,CACiB,IAAI,CAAE,AAAD,GAAW,EAAe,KAAW,EA4B5D,KAGc,EAAE,GACF,EAAE,GACS,EAAE,GACL,EAAE,CAsBxB,OAnBA,EAAW,OAAO,CAAC,AAAC,oBAhGd,EACA,QAgGE,GAhFF,EAAW,IAgFA,CAhFc,IAAL,KAAe,CAAC,GACnC,CACL,GAAI,KAAc,IAAL,AACb,aAAc,KAAc,IAAL,UACvB,OAAQ,KAAc,IAAL,IACjB,OAAQ,KAAc,IAAL,IACjB,WAAY,EA0EmC,GA1ErB,IAAL,QACrB,YAAa,KAAc,IAAL,SACtB,cAAe,KAAc,IAAL,WACxB,YAAa,KAAc,IAAL,SACtB,SAAU,EAAS,GAAK,UAAY,GAAU,UAC9C,UAAW,EAAS,GAAK,WAAa,GAAU,WAChD,OAAQ,EAAS,GAAU,QAAU,IACrC,UAAW,EAAS,GAAU,WAAa,GAAU,UACrD,cAAe,EAAS,GAAU,eAClC,cAAe,EAAS,GAAU,eAClC,oBAAqB,EAAS,GAAU,qBAAuB,GAAU,uBACzE,aAAc,EAAQ,GAAU,aAAc,EAAE,EAChD,iBAAkB,OAAO,GAAU,kBAAoB,GACvD,kBAAmB,EAAQ,GAAU,kBAAmB,EAAE,EAC1D,sBAAuB,OAAO,GAAU,uBAAyB,GACjE,cAAe,EAAQ,GAAU,cAAe,EAAE,EAClD,cAAe,EAAQ,GAAU,cAAe,EAAE,CACpD,EA0DE,EA9GI,EAAS,AA8GT,EAAwB,GA9GI,GA8GE,MA9GP,MACvB,EAAW,KAAmB,SAAL,KAElB,WAAX,GACA,EAAS,QAAQ,CAAC,WAClB,EAAS,QAAQ,CAAC,UAClB,EAAS,QAAQ,CAAC,YAClB,EAAS,QAAQ,CAAC,YAwGhB,EAA2B,IAAI,CAAC,CAAxB,GAtHN,EAAa,KAAmB,QAsHR,AArHxB,CAD2B,CACpB,EAwHe,GAxHI,GAwHE,MAxHP,IACrB,EAAW,KAAmB,SAAL,KACxB,EAAW,QAAQ,CAAC,WAAa,EAAK,QAAQ,CAAC,sBAAwB,EAAS,QAAQ,CAAC,WAuH5F,EAAmB,IAAI,CAAC,CAAhB,KAvGO,EA0GiB,GA1GE,AAuGhB,GAGoB,MA1GT,CAClB,KAAmB,SAAL,MACvB,EAAW,KAAmB,SAAL,KAE7B,EAAW,QAAQ,CAAC,kBACpB,EAAW,QAAQ,CAAC,oBACpB,EAAW,QAAQ,CAAC,sBACT,UAAX,GACA,AAAW,YACX,EAAS,QAAQ,CAAC,YAClB,EAAS,QAAQ,CAAC,UAClB,EAAS,QAAQ,CAAC,WAClB,EAAS,QAAQ,CAAC,SA+FhB,EAA8B,IAAI,CAAC,CAA3B,GApIN,AAuIA,EAvIS,EAuIa,GAvIM,SAAL,EAoII,IAnI3B,EAAW,KAAmB,SAAL,MACb,QAAX,GAAoB,EAAS,QAAQ,CAAC,WAAa,EAAS,QAAQ,CAAC,WAAa,EAAS,QAAQ,CAAC,SAAA,GAsIvG,EAAmB,IAAI,CAAC,CAAhB,CADgB,CAG5B,EAHkC,CAK3B,CACL,IALoB,QAKP,cACb,YACA,EACA,mBAAoB,GAAgB,GACpC,gBAAiB,EAAW,MAAM,CAClC,gBAAiB,EAAmB,MAAX,AAAiB,CAC1C,SADmC,OAClB,EAAmB,MAAX,AAAiB,CAC1C,SADmC,kBACP,EAA8B,MAAtB,AAA4B,CAChE,oBADyD,IAChC,EAA2B,MAAnB,AAAyB,CAC1D,WAAY,EAAmB,IADoB,CACf,CAAhB,AAAiB,GAAG,EACxC,KAD8B,MAClB,EAAmB,KAAK,CAAhB,AAAiB,GAAG,EACxC,KAD8B,iBACP,EAA8B,KAAK,CAA3B,AAA4B,GAAG,EAC9D,gBADoD,GAChC,EAA2B,KAAK,CAAxB,AAAyB,EAxhGnB,CAwhGsB,CAC1D,CACF,CAEA,SAAS,EAA8B,CAJW,AAIJ,CAAE,CAAU,CAAE,MAAE,CAAI,CAAE,CAAG,CAAC,CAAC,YACvE,MA3xEM,QA2xEA,EAAY,IACZ,EAAQ,EAAS,GAAS,MAAO,EAAS,GAAM,QACtD,GAAI,CAAC,EACH,KADU,CACJ,AAAI,MAAM,0BAGlB,IAAM,EAAa,EAAa,GAAS,YAAc,GAAM,YAAc,IAAc,EACnF,EAAW,EAA0B,GAAS,SAAU,EAAS,GAAM,SAAU,QACjF,EAxTR,AAwTuB,SAxTd,AAAsB,CAAK,CAAE,EAAW,OAAO,EACtD,IAAM,EAAa,EAAS,EAAO,GAAU,WAAW,GAExD,OAAO,AADS,EAAqB,IAAI,CAAC,AAAC,GAAU,EAAM,WAAW,KAAO,IAC3D,OACpB,EAoT6C,GAAS,aAAc,EAAS,GAAM,aAAc,UACzF,EAAwB,EAAU,GAAS,sBAAuB,EAAU,GAAM,uBAAuB,IACzG,EAAgC,EACpC,GAAS,8BACI,SAAb,GAAuB,EAAU,GAAM,+BAA+B,IAElE,EAAqB,EACzB,GAAS,mBACT,GACE,GACA,EAAqB,IAAa,EAAqB,SACvD,EAAU,GAAM,oBAAoB,IAElC,EA5NR,AA4N0B,SA5NjB,AAA+B,UAAE,CAAQ,uBAAE,CAAqB,+BAAE,CAA6B,CAAE,QACxG,AAAiB,SAAb,GAAuB,EAClB,YAEL,EACK,MAEF,SANmD,IAO5D,EAJ6B,AAwN4B,UACrD,wBACA,gCACA,CACF,GAEM,EAAS,AA7VjB,SAAiC,AAAxB,CAA6B,CAAE,EAAW,MAAM,EACvD,IAAM,EAAa,EAAS,EAAO,GAAU,WAAW,GAExD,OADgB,AACT,EADgC,IAAI,CAAC,AAAC,GAAU,EAAM,WAAW,KAAO,IAC7D,MACpB,EAyVyC,GAAS,OAAQ,EAAS,GAAM,OAAQ,SACzE,EAAoB,AAxV5B,SAAS,AAAmC,CAAK,CAAE,EAAW,aAAa,EACzE,IAAM,EAAa,EAAS,EAAO,GAAU,WAAW,GAExD,OADgB,AACT,EAD4C,IAAI,CAAC,AAAC,GAAU,EAAM,WAAW,KAAO,IACzE,aACpB,EAqVI,GAAS,kBACT,EAAS,GAAM,kBAAmB,gBAE9B,EAtVR,AAsViC,SAtVxB,AAA8B,CAAK,CAAE,EAAW,SAAS,EAChE,IAAM,EAAa,EAAS,EAAO,GAAU,WAAW,GAExD,OADgB,AACT,EADuC,IAAI,CAAC,AAAC,GAAU,EAAM,WAAW,KAAO,IACpE,SACpB,EAmVI,GAAS,uBACT,EAAS,GAAM,uBAAwB,YAGnC,EAAiC,EACrC,GAAS,+BACT,GAAyB,EAAU,GAAM,gCAAgC,IAErE,EAAkB,EACpB,EAAS,GAAM,iBAAiB,AAt0E9B,EAAY,OAAO,QAAQ,CAAC,OAAO,KAAU,OAAO,AAs0EI,IAt0EK,EAEnE,AAAI,OAAO,KAAK,CAAC,GADJ,IAAI,KAAK,AAq0E4B,GAr0EhB,MACZ,OAAO,IACpB,CADyB,IAGlC,EAAK,OAAO,CAAC,EAAK,OAAO,GAA8B,KAAK,GAAzB,EAA8B,CAA3B,CAAC,EAAG,GAAZ,KACvB,EAAK,WAAW,MAi0EnB,GACE,EAAuB,EAAa,GAAS,sBAAwB,GAAM,sBAAwB,IACnG,EAAgC,EACpC,GAAS,+BAAiC,GAAM,+BAAiC,IAE7E,EA7OR,AA6O2B,SA7OlB,AAAgC,gCACvC,CAA8B,sBAC9B,CAAoB,iBACpB,CAAe,aACf,EAAc,GAAQ,CACvB,EACC,GAAI,CAAC,EACH,MAAO,eAET,GAAI,EAAS,GACX,CAJmC,KAI5B,WAET,GAHoC,CAG9B,EAAU,EAAS,GACnB,EAAQ,EAAS,IAAgB,KAAK,GAAG,UAC/C,AAAI,OAAO,QAAQ,CAAC,IAAY,EAAU,EACjC,KADwC,KAG1C,SACT,EA2N2D,gCACvD,uBACA,kBACA,EACA,YAAa,CACf,GAEM,EAAwB,EAAU,GAAS,sBAAuB,EAAU,GAAM,uBAAuB,IACzG,EAA0B,EAC5B,EAAa,GAAS,yBAA2B,GAAM,yBAA2B,IAAc,EAChG,GACE,EAAsB,EAAa,GAAS,qBAAuB,GAAM,qBAAuB,IAChG,EAAe,EACjB,EAAa,GAAS,cAAgB,GAAM,cAAgB,IAAc,EAC1E,GACE,EAAkB,EAAU,GAAS,gBAAiB,EAAU,GAAM,iBAAiB,IACvF,EAAoB,EACtB,EAAa,GAAS,mBAAqB,GAAM,mBAAqB,IAAc,EACpF,GACE,EAAoB,EACtB,EAAe,GAAS,mBAAqB,GAAM,mBAAqB,GACxE,GAEE,GACkB,gBAAtB,GAAuC,AAAsB,gBACzD,EAAa,GAAS,sBAAwB,GAAM,sBAAwB,IAAc,EAC1F,EAAa,GAAS,sBAAwB,GAAM,sBAAwB,IAC5E,GACkB,cAAtB,EACI,EAAa,GAAS,wBAA0B,GAAM,wBAA0B,IAAc,EAC9F,EAAa,GAAS,wBAA0B,GAAM,wBAA0B,IAChF,GACuB,cAA3B,EACI,EAAa,GAAS,6BAA+B,GAAM,6BAA+B,IAAc,EACxG,EAAa,GAAS,6BAA+B,GAAM,6BAA+B,IAE1F,GAAsB,EAAa,GAAS,qBAAuB,GAAM,qBAAuB,IAAe,EAC/G,GAAoB,EAAa,GAAS,mBAAqB,GAAM,mBAAqB,IAAc,EACxG,IArWmC,EAsWvC,GAtW4C,EAAE,EAsWvC,OADiB,CArWgC,CAsWxC,CAtW0C,AAsWzC,cAtWuD,AAsWzC,CAAC,IAAI,CAAC,EAAS,EAAS,CAAC,GAAI,qBACxD,GAAS,kBACT,GAAM,kBAvWN,EAAY,EAyWhB,EAzWyC,KAAhB,AACrB,EAvkFC,CACL,MAskFa,GAtkFH,AAVd,SAAS,AAAgB,CAAI,CAAE,CAAa,CAAE,KAAE,EAAM,CAAC,KAAE,EAAM,OAAO,gBAAgB,CAAE,CAAG,CAAC,CAAC,EAC3F,IAAM,EAAS,OAAO,QAAQ,CAAC,OAAO,QAAQ,GAAG,CAAC,EAAK,EAAI,IAAI,IAAI,GAAI,WACvE,AAAK,IAAD,GAAQ,QAAQ,CAAC,GAGd,KAAK,CAHkB,EAGf,CAAC,EAAK,KAAK,GAAG,CAAC,EAAK,YACrC,EAI8B,mCA/Dc,CA+DsB,CAAqC,CACjG,EAhE2C,EAgEtC,KAhE6C,CAgEvC,CACX,IAAK,KAAK,IACZ,GACA,AAFmB,kBAEA,EACjB,QAAQ,GAAG,CAAC,yCAAyC,CACrD,GAEF,iBAAkB,EAChB,QAAQ,GAAG,CAAC,yCAAyC,CACrD,EAEJ,EA2jFO,EAAQ,GACZ,GAAG,CAAC,CAAC,EAAO,KACX,IAAM,EAAS,EAAS,EAAO,CAAC,GAC1B,EAAa,EAAa,EAAO,UAAU,EAAI,IAAc,EAC7D,EAAa,EAAe,EAAO,UAAU,IAAI,CACjD,EAAO,EAAS,EAAO,IAAI,CAAE,CAAC,kBAAkB,EAAE,EAAQ,EAAA,CAAG,EAC7D,EAAO,EAAS,EAAO,IAAI,CAAE,qBAC7B,EAAM,EAAS,EAAO,GAAG,EACzB,EAAc,EAAS,EAAO,WAAW,EACzC,EAzBZ,AAyB4B,SAzBnB,AAAyB,CAAK,EACrC,IAAM,EAAa,EAAS,GAAO,WAAW,GAC9C,GAAI,CAAC,EACH,MAAO,GAGT,CAJiB,GAIX,EAAQ,AADA,EAAW,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAChC,KAAK,CAAC,KAAK,GAAG,IAAM,SACnC,AAAL,IAAI,eAAoB,IAAI,CAAC,GAGtB,EAFE,EAGX,CAJuC,CAkBc,EAAO,aAAa,EAAI,GAAQ,GAAe,GACxF,EAAc,EAAc,EAAO,WAAW,EAC9C,EAAY,OAAO,QAAQ,CAAC,OAAO,EAAO,SAAS,GAAK,OAAO,EAAO,SAAS,EAAI,EACnF,EAAK,EAAS,EAAO,EAAE,EAAI,EAAO,QAAQ,EAAI,GAAe,CAAA,EAAG,EAAQ,EAAA,CAAG,EACjF,GAAI,CAAC,GAAQ,CAAC,GAAO,CAAC,EACpB,OAAO,IAD0B,CAGnC,GAAI,GAAiB,CAAC,EAAO,iBAAiB,CAAC,GAAG,CAAC,GACjD,MAAM,AAAI,MAAM,CADiD,sCAGnE,GAAI,GAAe,CAAC,EAAO,gBAAgB,CAAC,GAAG,CAAC,GAC9C,MAAM,AAAI,KADkD,CAC5C,0CAElB,GAAI,EAAY,EAAO,QAAQ,CAC7B,CAD+B,KACzB,AAAI,MAAM,kCAElB,MAAO,IACL,EACA,KAAM,GAAQ,oBACd,KAAM,GAAQ,wBACd,cACA,gBACA,cACA,YACA,EACA,WAAY,EAAS,EAAO,UAAU,EACtC,cAAe,EAAS,EAAO,aAAa,EAC5C,UAAW,EAAa,EAAO,SAAS,EAAI,eAC5C,EACA,WAAY,GAgUhB,CA/TE,CACF,GACC,MAAM,AAHuB,CAGtB,SACP,KAAK,CAAC,EA5zFyB,CA4zFtB,IA+TN,GAAuB,EAAa,GAAS,sBAAwB,GAAM,sBAAwB,IACnG,GAAqB,EAAa,GAAS,oBAAsB,GAAM,oBAAsB,IAC7F,GAA0B,EAAS,GAAS,wBAAyB,EAAS,GAAM,0BACpF,GAAmB,EAAS,GAAS,iBAAkB,EAAS,GAAM,mBACtE,GA/TC,EA+TmD,GAAS,GA/TpD,QA+TU,OAA8D,GAAM,kBA9T1F,GAAG,CAAC,AAAC,IACJ,IAAM,EAAS,EAAS,EAAO,CAAC,GAC1B,EAAK,EAAa,EAAO,EAAE,EAAI,EAAO,UAAU,EAAI,WAC1D,AAAK,EAGE,EAHH,AAAK,EAIP,EACA,aAAc,EAAS,EAAO,YAAY,EAAI,EAAO,MAAM,EAAI,YAC/D,OAAQ,EAAS,EAAO,MAAM,EAAI,UAClC,cAAe,EAAS,EAAO,aAAa,EAAI,EAAO,OAAO,EAAI,IAClE,SAAU,EAAS,EAAO,QAAQ,EAAI,IACtC,YAAa,EAAS,EAAO,WAAW,EAAI,IAC5C,cAAe,EAAS,EAAO,aAAa,EAAI,IAChD,WAAY,EAAe,EAAO,UAAU,EAAI,EAAO,WAAW,EAAI,IACtE,oBAAqB,EAAe,EAAO,mBAAmB,EAAI,EAAO,aAAa,EAAI,GAC5F,EAZS,IAaX,GACC,MAAM,CAAC,SACP,KAAK,CAAC,CAAC,IA4SJ,GAAuB,EAC3B,GAAS,sBAAwB,GAAM,sBAAwB,GAAc,IAEzE,GAAsB,EAC1B,GAAS,qBAAuB,GAAM,qBAAuB,GAAc,IAEvE,GAAyB,GAAiB,MAAM,CAAG,EAAI,GAAiB,MAAM,CAAG,EACjF,GAAuB,KAAK,GAAG,CACnC,EACA,OAAO,QAAQ,CACb,OACE,GAAS,sBACP,GAAM,sBACN,IAEJ,KACG,IAED,GAAkB,EAAQ,GAAS,iBAAmB,GAAM,iBAC/D,GAAG,CAAC,AAAC,GAAU,EAAe,IAC9B,MAAM,CAAC,SACP,KAAK,CAAC,EAAG,IACN,GAAoB,EAAQ,GAAS,mBAAqB,GAAM,mBACnE,GAAG,CAAC,AAAC,GAAU,EAAe,IAC9B,MAAM,CAAC,SACP,KAAK,CAAC,EAAG,IAEZ,MAAO,CACL,aAAc,EAAS,GAAM,aAAc,AAxa/C,SAAS,AAAkB,EAAW,GAAQ,EAC5C,IAAM,EAAO,IAAI,KAAK,GAAY,KAClC,GAAI,OAAO,KAAK,CAAC,EAAK,OAAO,IAC3B,CADgC,KACzB,CAAC,IAAI,EAAE,KAAK,GAAG,GAAG,QAAQ,GAAG,KAAK,CAAC,CAAC,IAAA,CAAK,CAElD,IAAM,EAAO,OAAO,EAAK,cAAc,IACjC,EAAK,OAAO,EAAK,WAAW,GAAK,GAAG,QAAQ,CAAC,EAAG,KAChD,EAAK,OAAO,EAAK,UAAU,IAAI,QAAQ,CAAC,EAAG,KAC3C,EAAK,OAAO,EAAK,WAAW,IAAI,QAAQ,CAAC,EAAG,KAC5C,EAAK,OAAO,EAAK,aAAa,IAAI,QAAQ,CAAC,EAAG,KAC9C,EAAS,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,KAAK,CAAC,EAAG,GAAG,WAAW,GACjE,MAAO,CAAC,IAAI,EAAE,EAAA,EAAO,EAAA,EAAK,EAAG,CAAC,EAAE,EAAA,EAAK,EAAA,EAAK,EAAA,CAC5C,AADoD,EA6Za,UAC7D,EACA,QAAS,EAAS,GAAS,QAAS,EAAS,GAAM,UACnD,wBACA,SACA,wBACA,EACA,sBAAuB,EAAe,GAAS,uBAAyB,GAAM,uBAC9E,WAAY,EAAe,GAAS,YAAc,GAAM,YAAc,GACtE,WAAY,EAAS,GAAS,WAAY,EAAS,GAAM,+BACzD,sBACA,kBACA,gCACA,sBACA,eACA,oBACA,EACA,mBAAoB,EAAS,GAAS,mBAAoB,EAAS,GAAM,0CACzE,0BACA,0BACA,EACA,cAAe,EAAS,GAAS,cAAe,EAAS,GAAM,4CAC/D,kCACA,kBACA,uBACA,gCACA,mBACA,wBACA,0BACA,EACA,sBAAuB,EAAS,GAAS,sBAAuB,EAAS,GAAM,wBAC/E,kBACA,sCACA,EACA,kBAAmB,EAAS,GAAS,kBAAmB,EAAS,GAAM,oBACvE,oBAAqB,EAAS,GAAS,oBAAqB,EAAS,GAAM,sBAC3E,gBAAiB,EAAS,GAAS,gBAAiB,EAAS,GAAM,kBACnE,sBAAuB,EAAS,GAAS,sBAAuB,EAAS,GAAM,sBAAuB,qBACtG,kBAAmB,EAAS,GAAS,kBAAmB,EAAS,GAAM,oBACvE,kBAAmB,EAAa,GAAS,mBAAqB,GAAM,mBAAqB,IACzF,yCACA,qBACA,GACA,uBAAwB,GAAkB,MAAM,CAChD,MAAO,EAAS,GAAS,MAAO,EAAS,GAAM,QAC/C,uBAAwB,EAAS,GAAS,uBAAwB,EAAS,GAAM,uBAAwB,wBACzG,cAAe,EAAU,GAAS,cAAe,EAAU,GAAM,eAAe,IAChF,gBAAiB,EAAS,GAAS,gBAAiB,EAAS,GAAM,kBACnE,qBAAsB,EAAS,GAAS,qBAAsB,EAAS,GAAM,+CAC7E,wBACA,sBACA,oBACA,wBACA,wBACA,uBACA,oBACA,GACA,aAAc,EAAS,GAAS,aAAc,EAAS,GAAM,eAC7D,cAAe,EAAS,GAAS,cAAe,EAAS,GAAM,gBAC/D,kBAAmB,EAAS,GAAS,kBAAmB,EAAS,GAAM,oBACvE,gBAAiB,EAAS,GAAS,gBAAiB,EAAS,GAAM,kBACnE,SAAU,EAAS,GAAS,SAAU,EAAS,GAAM,2BACrD,GACA,qBAAsB,EAAS,GAAS,qBAAsB,EAAS,GAAM,qBAAsB,CAAC,IACpG,qBAAsB,EAAS,GAAS,qBAAsB,EAAS,GAAM,qBAAsB,CAAC,IACpG,oBAAqB,EAAa,GAAS,qBAAuB,GAAM,qBAAuB,eAC/F,EACA,WAAY,EAAa,GAAS,YAAc,GAAM,aAA0B,CAAZ,YAAC,EAAwB,EAAY,EAAA,CAAE,EAC3G,SAAU,EAAa,GAAS,UAAY,GAAM,UAAa,CAAW,CAAZ,YAAuB,EAAY,EAAA,CAAE,EACnG,UAAW,EAAS,GAAM,UAAW,GACrC,UAAW,EAAS,GAAM,UAAW,GACrC,UAAW,EACX,UAAW,EACX,YAAA,EAjjEiB,AAijEH,EAAY,GAAM,OAjjEH,MAAE,EAijEe,CAC5C,EAljEkC,CAkjE9B,EACJ,GAAI,EACJ,OAAQ,EAAO,SAAW,SAC1B,kBACA,EACA,mCACA,CACF,EAvjEF,AAAI,CADE,EAAQ,IAAI,EAAQ,GAAe,EAAM,EACrC,MAAM,IAAI,CACX,EAEF,EAAM,KAAK,CAAC,EAAM,MAAM,CA7rCH,EA6rCM,CAHS,CAwjE3C,CACF,CAEA,SAAS,EAAqB,CAAM,CAAE,CAAgB,CAAE,CAAU,EAChE,IAAM,EAAW,EAAS,EAAkB,CAAC,GAC7C,MAAO,CACL,GAAG,CAAM,CACT,iBAAkB,EAClB,gBAAiB,CACf,gBAAiB,OAAO,EAAS,eAAe,EAAI,GACpD,gBAAiB,OAAO,EAAS,eAAe,EAAI,GACpD,2BAA4B,OAAO,EAAS,0BAA0B,EAAI,GAC1E,wBAAyB,OAAO,EAAS,uBAAuB,EAAI,GACpE,gBAAiB,OAAO,EAAS,eAAe,EAAI,GACpD,YAAa,EAAS,EAAS,WAAW,EAC1C,YAAa,EAAS,EAAS,WAAW,EAC1C,UAAW,EAAS,EAAS,SAAS,CACxC,EACA,sBAAuB,EAAS,EAAS,WAAW,CAAE,KACtD,sBAAuB,CACzB,CACF,CAEO,eAAe,IACpB,OAAO,MAAM,EAAsB,EAAkB,aACvD,CAEO,eAAe,EAAyB,CAAQ,EACrD,OAAO,MAAM,EAAwB,EAAkB,aAAc,EACvE,CAEO,eAAe,EAA4B,CAAO,CAAE,CAAU,EACnE,IAAM,EAAa,EAA8B,EAAS,GACpD,EAAmB,MAAM,EAA8B,EAAY,CACvE,MAAO,OAAO,QAAQ,CAAC,EAAI,mCAAoC,QAAS,GAC1E,GACM,EAAe,EAAqB,EAAY,EAAkB,GACxE,OAAO,MAAM,EAAuB,EAAkB,aAAc,EACtE,CAEO,eAAe,EAA4B,CAAQ,CAAE,CAAO,CAAE,CAAU,EAC7E,IAAM,EAAU,MAAM,EAAyB,GAC/C,GAAI,CAAC,EACH,OAAO,AADK,KAGd,IAAM,EAAa,EAA8B,EAAS,EAAY,CAAE,KAAM,CAAQ,GAQhF,EANJ,AAMuB,EANb,GAAS,yBAAyB,IAC5C,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAS,EAAS,CAAC,GAAI,wBAC5D,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAS,EAAS,CAAC,GAAI,sBAC5D,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAS,EAAS,CAAC,GAAI,0BAC5D,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAS,EAAS,CAAC,GAAI,cAG1D,MAAM,EAA8B,EAAY,CAC9C,MAAO,OAAO,QAAQ,CAAC,EAAI,mCAAoC,QAAS,GAC1E,GACA,EAAS,EAAQ,gBAAgB,CAAE,CAAC,GAClC,EAAe,EAAqB,EAAY,EAAkB,GACxE,OAAO,MAAM,EAAuB,EAAkB,aAAc,EAAU,EAChF,CAkDA,SAAS,EAAS,CAAK,EACrB,IAAM,EAAY,IAAI,KAAK,GAAS,IAAI,OAAO,GAC/C,OAAO,OAAO,KAAK,CAAC,GAAa,KAAO,CAC1C,CAEA,SAAS,EAAa,CAAK,EACzB,IAAM,EAAY,EAAS,UAC3B,AAAK,IAAD,GAAQ,QAAQ,CAAC,GAGd,IAAI,KAHsB,AAGjB,GAAW,WAAW,GAF7B,EAGX,CEh3GA,SAAS,EAAS,CAAK,CAAE,EAAW,EAAE,EAEpC,OADmB,AACZ,OADmB,GAAS,IAAI,IAAI,IACtB,CACvB,CA+BA,SAAS,EAAQ,CAAK,EACpB,OAAO,MAAM,OAAO,CAAC,GAAS,EAAQ,EAAE,AAC1C,CAUA,SAAS,EAAe,CAAK,EAC3B,OAAO,OAAO,GAAS,IAAI,IAAI,GAAG,WAAW,EAC/C,CAkFO,eAAe,EAAwB,CAAO,EACnD,IAAM,EArDN,AAAK,CAAA,EAAA,AAqDM,CArDP,CAAC,kBAAA,AAAkB,IAGhB,CAAA,AAHoB,EAGpB,EAAA,cAAA,AAAc,IAFZ,KAqDT,GAAI,CAAC,EACH,EADO,KACA,KAGT,IAAM,EAAa,AAhCrB,SAAS,AAA6B,CAAO,QAC3C,IA3CM,EA2CA,EA5GC,IAAI,AA4GC,OA5GM,WAAW,GA6GvB,EAAiB,EAAe,GAAS,gBACzC,EAtGR,AAsGoB,SAtGX,AAAU,CAAK,CAAE,GAAW,CAAK,EACxC,GAAqB,WAAW,AAA5B,OAAO,EACT,OAAO,EAET,GAAqB,UAAjB,AAA2B,OAApB,EACT,OAAiB,AAAV,MAET,GAAqB,UAAjB,OAAO,EAAoB,CAC7B,IAAM,EAAa,EAAM,IAAI,GAAG,WAAW,GAC3C,GAAI,CAAC,EACH,OAAO,EAET,CAHiB,EAGb,CAAC,OAAQ,IAAK,MAAO,KAAM,IAAI,CAAC,QAAQ,CAAC,GAC3C,OAAO,EAET,CAH0D,EAGtD,CAAC,QAAS,IAAK,KAAM,MAAO,IAAI,CAAC,QAAQ,CAAC,GAC5C,MAAO,EAEX,CACA,CAJ6D,MAItD,CACT,EAkF8B,GAAS,UAAW,IAChD,GAAI,CAAC,GAAkB,CAAC,EACtB,MAAM,AAAI,GADuB,GACjB,kCAGlB,MAAO,CACL,MAAO,EAAS,GAAS,MAAO,yBAChC,QAAS,EAAS,GAAS,QAAS,qCACpC,QAAA,CApDE,AAAe,CAoDP,WApDmB,IADZ,OAAO,AAqDI,GAAS,UArDJ,IAAI,IAAI,GAAG,WAAW,IACnB,WACnB,QAAQ,CAAvB,EAA8B,OAC9B,AAAe,OAAO,GAAO,MAC1B,SAkDL,KAAM,EAAS,GAAS,KAAM,YAC9B,OAAQ,EAAS,GAAS,OAAQ,uBAClC,UAAW,EAAS,GAAS,UAAW,uCACxC,YACA,EACA,OAnDkD,CAmD1C,QAnDH,OAAO,AAmDwB,GAAS,QAnDxB,IAAI,IAAI,GAAG,WAAW,GAAgB,OAAS,SAoDpE,SA9FE,AAAJ,CADgB,AA+FJ,EAAS,GA/FA,AA+FS,WA9FA,UAAjB,OAAO,GAAsB,CAAC,MAAM,OAAO,CAAC,GAChD,EAEF,CAAC,EAHyD,AA+F/D,UAAW,EAAS,GAAS,UAAW,GACxC,UAAW,EAAS,GAAS,UAAW,GACxC,OAAQ,EAAS,GAAS,OAAQ,IAClC,UAAW,EAAe,GAAS,UACrC,CACF,EAQkD,GAC1C,EAAM,MAAM,CAAA,EAAA,EAAA,MAAM,AAAN,EAAO,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EA/D7B,EAAS,AA+DwB,QA/DhB,GAAG,CAAC,uCAAuC,CAAE,uBA+DM,GAC3E,MAAO,CACL,GAAG,CAAU,CACb,GAAI,EAAI,EAAE,CACV,SAAU,EAAI,EAAE,AAClB,CACF,CAEO,eAAe,EAA6B,CAAQ,EACzD,IAAM,EAAU,EAAQ,GACxB,GAAuB,GAAG,CAAtB,EAAQ,MAAM,CAChB,MAAO,EAAE,CAGX,IAAM,EAAU,EAAE,CAClB,IAAK,IAAM,KAAW,EAAS,CAC7B,IAAM,EAAS,MAAM,EAAwB,GACzC,GACF,EAAQ,GADE,CACE,CAAC,EAEjB,CACA,OAAO,CACT,CAqNO,eAAe,EAAqC,YACzD,CAAU,uBACV,CAAqB,YACrB,CAAU,yBACV,GAA0B,CAAI,cAC9B,EAAe,EAAK,CACrB,CAAG,CAAC,CAAC,EACJ,IAAM,EAAiB,CACrB,EAAe,QAAQ,GAAG,CAAC,oBAAoB,KArU1C,OAAO,AAsUM,QAAQ,GAAG,CAAC,UAAU,EAtUhB,IACvB,KAAK,CAAC,KACN,GAAG,CAAC,AAAC,GAAS,EAAe,IAC7B,MAAM,CAAC,SAoUR,EAAe,GAChB,CAEG,GACF,EAAe,IAAI,CAAC,EAAe,IAEjC,GACF,EAAe,IAJY,AAIR,CAAC,EAAe,EADnB,EAIlB,IAAI,EAAwB,EAAE,CAC9B,GAAI,CACF,IAAM,EAAQ,MAAM,CAAA,EAAA,EAAA,gBAAA,AAAgB,IACpC,EAAwB,EAAQ,GAC7B,MAAM,CAAC,AAAC,GAAS,EAAe,GAAM,QACtC,MAAM,CAAC,AAAC,gBAAS,AAAgC,YA3VjC,EA2Ve,GA3VV,AA2VgB,OA1VnC,OAAO,GAAS,IAAI,IAAI,GAAG,WAAW,MA2VxC,MAAM,CAAC,AAAC,IACP,IAAM,EAAO,OAAO,GAAM,MAAQ,IAAI,IAAI,GAAG,WAAW,GACxD,MAAO,AAAS,SAClB,GACC,GAAG,CAAC,AAAC,GAAS,EAAe,GAAM,OACxC,CAAE,KAAM,CACN,EAAwB,EAAE,AAC5B,CAEA,OA7CK,AA6CE,SA7CO,AAA8B,EAAS,EAAE,EACvD,OAAO,MAAM,IAAI,CACf,IAAI,IACF,EAAQ,GACL,GAAG,CAAC,AAAC,GAAU,EAAe,IAC9B,MAAM,CAAC,UAGhB,EAqCuC,IAAI,KAAmB,EAAsB,CACpF,CC3aA,SAAS,EAAS,CAAK,CAAE,EAAW,EAAE,EAEpC,OADmB,AACZ,OADmB,GAAS,IAAI,IAAI,IACtB,CACvB,CAEA,SAAS,EAAQ,CAAK,EACpB,OAAO,MAAM,OAAO,CAAC,GAAS,EAAQ,EACxC,AAD0C,CAW1C,SAAS,EAAe,CAAK,EAC3B,OAAO,EAAS,GAAO,WAAW,EACpC,CAEA,SAAS,EAAe,CAAK,EAC3B,OAAO,OAAO,GAAS,IAAI,OAAO,CAAC,UAAW,IAAI,IAAI,EACxD,CAEA,SAAS,EAAa,CAAK,EACzB,OAAO,EAAS,GACb,KAAK,CAAC,KACN,GAAG,CAAC,AAAC,GAAS,EAAK,IAAI,IACvB,MAAM,CAAC,QACZ,CAEA,SAAS,EAAO,EAAS,EAAE,EACzB,OAAO,MAAM,IAAI,CAAC,IAAI,IAAI,EAAO,MAAM,CAAC,UAC1C,CAyBA,SAAS,IACP,MAAM,GAvBA,EAAa,EAuBuB,MAAvB,EAvBS,AAuBsB,GAAG,CAAC,yBAAyB,EAvB5C,WAAW,IAI1C,EAAW,QAAQ,CAAC,UAAkB,CAAP,QAC/B,EAAW,QAAQ,CAAC,YAAoB,CAAP,UACjC,EAAW,QAAQ,CAAC,YAA6B,OAAO,CAAtB,EAA6B,UAChD,SAAf,GAAwC,OAAO,CAAtB,EAA6B,OACnD,EANE,UAsBL,AAAJ,GAIS,MAIX,CAEA,EAVkB,OAUT,IACP,MAAM,GAvBA,EAAa,EAuBqB,MAArB,EAvBS,AAuBoB,GAAG,CAAC,uBAAuB,EAvBxC,WAAW,IAI1C,EAAW,QAAQ,CAAC,UAAkB,CAAP,QAC/B,EAAW,QAAQ,CAAC,YAA6B,OAAO,CAAtB,EAA6B,UAChD,SAAf,GAAyB,AAAe,OAAO,GAAO,OACnD,EALE,UAsBT,AAAI,GAGG,MACT,CAEA,EANkB,OAMT,EAA+B,EAAqB,EAAE,EAM7D,OAAO,EACL,IALG,EAAa,QAAQ,GAAG,CAAC,8BAA8B,KACvD,EAAa,QAAQ,GAAG,CAAC,UAAU,KACnC,EAAa,QAAQ,GAAG,CAAC,kBAAkB,KAG9B,EAAQ,GAAoB,CACzC,GAAG,CAAC,AAAC,GAAU,EAAe,IAC9B,MAAM,CAAC,SAEd,CA4CA,eAAe,GAAmB,YAAE,CAAU,CAAE,SAAO,MAAE,CAAI,MAAE,CAAI,CAAE,EACnE,IAAM,EAAS,EAAS,QAAQ,GAAG,CAAC,cAAc,EAC5C,EAAc,EAAS,QAAQ,GAAG,CAAC,eAAe,EACxD,GAAI,CAAC,GAAU,CAAC,GAAe,CAAC,EAAO,UAAU,CAAC,OAChD,CADwD,KAClD,AAAI,MAAM,iCAGlB,IAAM,EAAW,MAAM,MAAM,GAAG,gBAAgB,OAAO,CAAC,KAAE,CACxD,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,cAAe,CAAC,OAAO,EAAE,EAAA,CAAQ,AACnC,EACA,KAAM,KAAK,SAAS,CAAC,CACnB,KAAM,EACN,GAAI,UACJ,OACA,OACA,CACF,EACF,GAEM,EAAU,MAAM,EAAS,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,EAAC,CAAC,EACrD,GAAI,CAAC,EAAS,EAAE,CAAE,CAChB,IAAM,EACJ,EAAS,GAAS,UAClB,EAAS,GAAS,OAAO,UACzB,uBACF,OAAU,AAAJ,MAAU,CAAC,sBAAsB,EAAE,EAAA,CAAS,CACpD,CAEA,MAAO,CACL,SAAU,SACV,OAAQ,OACR,UAAW,EAAS,GAAS,GAAI,CAAC,OAAO,EAAE,KAAK,GAAG,GAAA,CAAI,EACvD,eAAgB,EAAW,MAAM,AACnC,CACF,CAiBA,eAAe,GAAoB,YAAE,CAAU,SAAE,CAAO,MAAE,CAAI,MAAE,CAAI,CAAE,EACpE,IAAM,EAAiB,EAAO,EAAQ,GAAY,GAAG,CAAC,GAAgB,MAAM,CAAC,UAC7E,GAAI,AAA0B,GAAG,GAAd,MAAM,CACvB,MAAO,CACL,SAAU,OACV,OAAQ,UACR,OAAQ,gBACR,eAAgB,CAClB,EAGF,IAAM,EAAW,UACjB,AAAiB,QAAQ,CAArB,EACK,UACL,EACA,OAAQ,UACR,OAAQ,oBACR,eAAgB,CAClB,EAEe,YAAY,CAAzB,EACK,UACL,EACA,OAAQ,UACR,OAAQ,gDACR,eAAgB,CAClB,EAEe,WAAW,CAAxB,EACK,AA5CX,SAAS,AAAoB,YAAE,CAAU,SAAE,CAAO,CAAE,MAAI,CAAE,EAQxD,OA5KF,AAqKM,SArKG,AAAgB,CAAI,CAAE,GAAgB,CAAK,EAClD,IAAM,EAAM,EAAS,QAAQ,GAAG,CAAC,EAAK,EAAE,WAAW,UAC9C,AAAL,EAGe,EAHX,CAAM,MAGH,GAA0B,MAAR,GAAuB,QAAR,EAF/B,CAGX,EA+JsB,4BAA4B,IAC9C,KADuD,GAC/C,IAAI,CAAC,6BAA8B,YACzC,EAF8E,QAG9E,MAH4F,CAI5F,CACF,GAEK,CACL,SAAU,UACV,OAAQ,YACR,eAAgB,EAAW,MAAM,AACnC,CACF,EA+B+B,CACzB,WAAY,UACZ,OACA,CACF,GAEe,UAAU,CAAvB,EACK,MAAM,GAAmB,CAC9B,WAAY,UACZ,OACA,OACA,CACF,GAGK,UACL,EACA,OAAQ,UACR,OAAQ,uBACR,eAAgB,CAClB,CACF,CAEA,eAAe,GAAiB,YAAE,CAAU,MAAE,CAAI,CAAE,EAClD,IAAM,EAAa,EAAS,QAAQ,GAAG,CAAC,kBAAkB,EACpD,EAAY,EAAS,QAAQ,GAAG,CAAC,iBAAiB,EAClD,EAAa,EAAS,QAAQ,GAAG,CAAC,kBAAkB,EAC1D,GAAI,CAAC,GAAc,CAAC,GAAa,CAAC,EAChC,MAAM,AAAI,IADkC,EAC5B,yBAGlB,IAAM,EAAa,OAAO,IAAI,CAAC,CAAA,EAAG,EAAW,CAAC,EAAE,EAAA,CAAW,CAAE,QAAQ,QAAQ,CAAC,UACxE,EAAW,EAAW,GAAG,CAAC,MAAO,IACrC,IAAM,EAAO,IAAI,gBACjB,EAAK,GAAG,CAAC,KAAM,GACf,EAAK,GAAG,CAAC,OAAQ,GACjB,EAAK,GAAG,CAAC,OAAQ,GACjB,IAAM,EAAW,MAAM,MAAM,GAAG,gBAAgB,UAAU,iBAAE,mBAAmB,YAAY,MAAe,CAAE,CAC1G,MADuG,CAC/F,OACR,QAAS,CACP,cAAe,CAAC,MAAM,EAAE,EAAA,CAAY,CACpC,eAAgB,mCAClB,EACA,KAAM,EAAK,QAAQ,EACrB,GACM,EAAU,MAAM,EAAS,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,EAAC,CAAC,EACrD,GAAI,CAAC,EAAS,EAAE,CAAE,CAChB,IAAM,EAAU,EAAS,GAAS,QAAS,sBAC3C,OAAM,AAAI,MAAM,CAAC,uBAAuB,EAAE,EAAA,CAAS,CACrD,CACA,MAAO,IACL,EACA,IAAK,EAAS,GAAS,IACzB,CACF,GAEM,EAAU,MAAM,QAAQ,UAAU,CAAC,GACnC,EAAY,EACf,MAAM,CAAC,AAAC,GAAyB,cAAhB,EAAK,MAAM,EAC5B,GAAG,CAAC,AAAC,GAAS,EAAK,KAAK,EACrB,EAAS,EACZ,MAAM,CAAC,AAAC,GAAyB,aAAhB,EAAK,MAAM,EAC5B,GAAG,CAAC,AAAC,GAAS,EAAS,EAAK,MAAM,EAAE,SAAW,wBAElD,MAAO,CACL,SAAU,SACV,OAAQ,EAAO,MAAM,CAAG,EAAK,EAAU,MAAM,CAAG,EAAI,UAAY,SAAY,OAC5E,eAAgB,EAAU,MAAM,CAChC,eAAgB,EAAW,MAAM,WACjC,SACA,CACF,CACF,CAmBA,eAAe,GAAkB,YAAE,CAAU,MAAE,CAAI,CAAE,EACnD,IAAM,EAAiB,EAAO,EAAQ,GAAY,GAAG,CAAC,GAAgB,MAAM,CAAC,UAC7E,GAA8B,GAAG,CAA7B,EAAe,MAAM,CACvB,MAAO,CACL,SAAU,OACV,OAAQ,UACR,OAAQ,gBACR,eAAgB,EAChB,eAAgB,EAChB,OAAQ,EAAE,AACZ,EAGF,IAAM,EAAW,UACjB,AAAiB,QAAQ,CAArB,EACK,UACL,EACA,OAAQ,UACR,OAAQ,oBACR,eAAgB,EAChB,eAAgB,EAAe,MAAM,CACrC,OAAQ,EACV,AADY,EAGG,WAAW,CAAxB,EAzCN,AA0CW,SA1CF,AAAkB,YAAE,CAAU,MAAE,CAAI,CAAE,EAO7C,MAAO,CACL,SAAU,UACV,OAAQ,YACR,eAAgB,EAAW,MAAM,CACjC,eAAgB,EAAW,MAAM,CACjC,UAAW,EAAW,GAAG,CAAC,AAAC,IAAQ,CAAD,GAAG,EAAI,IAAK,CAAC,QAAQ,EAAE,KAAK,GAAG,GAAA,CAAI,CAAC,CAAC,EACvE,OAAQ,EAAE,AACZ,CACF,EA2B6B,CACvB,WAAY,OACZ,CACF,GAEe,UAAU,CAAvB,EACK,MAAM,GAAiB,CAC5B,WAAY,EACZ,MACF,GAGK,UACL,EACA,OAAQ,UACR,OAAQ,uBACR,eAAgB,EAChB,eAAgB,EAAe,MAAM,CACrC,OAAQ,EAAE,AACZ,CACF,CA4BA,eAAe,GAAY,KAAE,CAAG,CAAE,OAAK,OAAE,CAAK,SAAE,CAAO,WAAE,CAAS,CAAE,EAClE,IAAM,EAAa,IAAI,gBACjB,EAAQ,WAAW,IAAM,EAAW,KAAK,GAAI,GACnD,GAAI,CACF,IAAM,EAAU,CACd,eAAgB,mBAChB,gBAAiB,qBACjB,gBAAiB,CACnB,EACI,IACF,EAAQ,CADC,YACY,CAAG,CAAC,OAAO,EAAE,EAAA,CAAA,AAAO,EAE3C,IAAM,EAAW,MAAM,MAAM,EAAK,CAChC,OAAQ,eACR,EACA,KAAM,KAAK,SAAS,CAAC,GACrB,OAAQ,EAAW,MAAM,AAC3B,GACM,EAAO,MAAM,EAAS,IAAI,GAAG,KAAK,CAAC,IAAM,IAC/C,MAAO,OACL,MACA,EACA,GAAI,EAAS,EAAE,CACf,OAAQ,EAAS,MAAM,CACvB,KAAM,EAAS,EACjB,CACF,CAAE,MAAO,EAAO,CACd,MAAO,OACL,MACA,EACA,IAAI,EACJ,OAAQ,EACR,KAAM,EAAS,GAAO,QAAS,0BACjC,CACF,QAAU,CACR,aAAa,EACf,CACF,CAEA,eAAe,GAAiB,CAAO,EACrC,YAAM,GAjEA,EAAU,EAAa,GAiEb,KAjEqB,GAAG,CAAC,0BAA0B,EAAE,GAAG,CAAC,AAAC,IAAS,CACjF,CADgF,KACzE,uBACP,EACA,MAAO,EAAS,QAAQ,GAAG,CAAC,2BAA2B,EACzD,CAAC,EACK,EAAU,EAAS,QAAQ,GAAG,CAAC,qBAAqB,EACpD,EAAS,EAAS,QAAQ,GAAG,CAAC,oBAAoB,EAClD,EAAU,IAAI,EAAQ,CACxB,GACF,EAAQ,IADG,AACC,CAAC,CACX,MAAO,OACP,IAAK,EACL,MAAO,EAAS,QAAQ,GAAG,CAAC,uBAAuB,CACrD,GAEE,GACF,EAAQ,GADE,CACE,CAAC,CACX,MAAO,MACP,IAAK,EACL,MAAO,EAAS,QAAQ,GAAG,CAAC,sBAAsB,CACpD,GAEK,EAAQ,MAAM,CAAC,AAAC,GAAW,EAAS,EAAO,GAAG,IA4CrD,GAAuB,GAAG,CAAtB,EAAQ,MAAM,CAChB,MAAO,CACL,OAAQ,UACR,QAAS,EAAE,CACX,aAAc,CAChB,EAGF,IAAM,EAAY,OAAO,QAAQ,CAAC,EAAS,QAAQ,GAAG,CAAC,gCAAgC,CAAE,QAAS,KAAO,IACnG,EAAU,MAAM,QAAQ,GAAG,CAC/B,EAAQ,GAAG,CAAC,AAAC,GACX,GAAY,CACV,GAAG,CAAM,SACT,EACA,UAAW,KAAK,GAAG,CAAC,IAAM,KAAK,GAAG,CAAC,IAAO,GAC5C,KAGE,EAAe,EAAQ,MAAM,CAAC,AAAC,GAAS,EAAK,EAAE,EAAE,MAAM,CAC7D,MAAO,CACL,OAAQ,IAAiB,EAAQ,MAAM,CAAG,OAAS,EAAe,EAAI,UAAY,SAClF,QAAS,EACT,cACF,CACF,CAEO,eAAe,GAA+B,UACnD,CAAQ,WACR,CAAS,aACT,CAAW,iBACX,EAAkB,EAAE,eACpB,EAAgB,EAAE,CACnB,CAAG,CAAC,CAAC,EACJ,IAxUM,EAwUA,EAAa,EAA+B,GAC5C,EA5WR,AA4WqB,SA5WZ,AAAqB,EAAqB,EAAE,EAEnD,OAAO,EAAO,IADE,EAAa,QAAQ,GAAG,CAAC,yBAAyB,KACpC,EAAQ,GAAoB,CAAC,GAAG,CAAC,AAAC,GAAU,EAAe,IAAQ,MAAM,CAAC,SAC1G,EAyW0C,GAClC,EAAU,AAxWlB,SAAmC,AAA1B,UAA4B,CAAQ,WAAE,CAAS,CAAE,EACxD,IAAM,EAAW,EAAS,GAAU,UAAY,GAAW,UAAY,UAAU,WAAW,GACtF,EAAe,EAAS,GAAU,aAAc,YAChD,EAAQ,EAAS,GAAU,MAAO,6BACxC,MAAO,CAAC,OAAO,EAAE,EAAS,EAAE,EAAE,EAAa,GAAG,EAAE,EAAA,CAAO,AACzD,EAmW4C,UAAE,YAAU,CAAU,GAC1D,EAAO,AAlWf,SAAS,AAAuB,UAAE,CAAQ,WAAE,CAAS,aAAE,CAAW,CAAE,EAClE,IAAM,EAAS,EAAS,GAAW,OAAQ,OACrC,EAAW,EAAS,GAAa,UAAU,UAAY,GAAa,SAAU,WAC9E,EAAQ,EAAS,GAAa,YAAa,WAC3C,EAAc,EAAS,GAAa,UAAU,aAAe,GAAa,YAAa,WACvF,EAAgB,OAAO,GAAW,eAAiB,GACnD,EAAa,EAAS,GAAU,YAAc,GAAa,WAAY,IAAI,OAAO,WAAW,IACnG,MAAO;YAEQ,EAAS,GAAU,aAAc,KAAK,GAAG,EAAE,EAAS,GAAU,MAAO,MAAM;YAC3E,EAAS,GAAU,SAAU,MAAM;QACvC,QAAQ;eACD,YAAY;SAClB,OAAO;aACH,UAAU;gBACP,aAAa;kBACX,EAAgB,EAAI,EAAgB,KAAK;WAChD,EAAS,GAAU,SAAW,GAAW,QAAS,MAAM;cACrD,EAAS,GAAU,UAAW,yBAAyB,AACvE,AACH,CADI,CA+UkC,GA/U9B,CAAC,MA+U+B,EAAU,wBAAW,CAAY,GACjE,KA5UU,EA4UH,KAAuB,AA5Ub,GAAQ,IAC5B,UAAU,CAAC,IAAK,SAChB,UAAU,CAAC,IAAK,QAChB,UAAU,CAAC,IAAK,QACZ,CAAC,iHAAiH,EAAE,EAAQ,MAAM,CAAC,EA0UpI,CAAC,EAAa,EAAW,EAAc,CAAG,MAAM,QAAQ,GAAG,CAAC,CAChE,GAAoB,YAClB,UACA,OACA,OACA,CACF,GAAG,KAAK,CAAC,AAAC,IAAW,CACnB,GADkB,MACR,IACV,OAAQ,SACR,OAAQ,EAAS,GAAO,QAAS,yBACjC,eAAgB,EAAW,MAAM,CACnC,CAAC,EACD,GAAkB,CAChB,WAAY,EACZ,KAAM,CAAA,EAAG,QAAQ;AAAE,EAAE,EAAA,CAAM,CAAC,KAAK,CAAC,EAAG,KACvC,GAAG,KAAK,CAAE,AAAD,IAAY,CACnB,GADkB,MACR,IACV,OAAQ,SACR,OAAQ,EAAS,GAAO,QAAS,uBACjC,eAAgB,EAChB,eAAgB,EAAW,MAAM,CACjC,OAAQ,CAAC,EAAS,GAAO,QAAS,uBAAuB,CAC3D,CAAC,EACD,GAAiB,CACf,UAAW,yBACX,YAAa,IAAI,OAAO,WAAW,GACnC,qBACA,EACA,YAAa,CACX,GAAI,EAAS,GAAa,IAC1B,OAAQ,EAAS,GAAa,QAC9B,aAAc,EAAS,GAAa,cACpC,OAAQ,EAAS,GAAa,QAC9B,WAAY,EAAS,GAAa,YAClC,SAAU,EAAS,GAAa,UAAU,UAAY,GAAa,UACnE,YAAa,EAAS,GAAa,UAAU,aAAe,GAAa,YAC3E,CACF,GACD,EAED,MAAO,CACL,UACA,MAAO,EACP,IAAK,EACL,SAAU,aACV,EACA,cAAe,CACjB,CACF,CCteA,IAAM,GAAwB,IAAI,IAC5B,GAA0B,IAAI,IAE9B,GAAuB,mBACzB,GAA0B,KAExB,GAA4B,IAAI,IAAI,CACxC,qBACA,mBACA,8BACA,eACA,qBACA,wBACA,2BACD,EACK,GAA+B,IAAI,IAAI,CAC3C,mBACA,mBACA,mBACA,kBACD,EACK,GAAuB,IAAI,IAAI,CAAC,cAAe,MAAO,KAAM,KAAK,EAEvE,SAAS,KACP,OAAO,IAAI,OAAO,WAAW,EAC/B,CAEA,SAAS,GAAS,CAAK,CAAE,EAAW,EAAE,EAEpC,OADmB,AACZ,OADmB,GAAS,IAAI,IAAI,IACtB,CACvB,CAEA,SAAS,GAAS,CAAK,SACrB,AAAI,GAA0B,UAAjB,OAAO,GAAsB,CAAC,MAAM,OAAO,CAAC,GAChD,EAEF,CAAC,CACV,CAJmE,AAMnE,SAAS,GAAQ,CAAK,EACpB,OAAO,MAAM,OAAO,CAAC,GAAS,EAAQ,EAAE,AAC1C,CAEA,SAAS,GAAc,CAAK,EAC1B,OAAO,GAAS,GAAO,WAAW,EACpC,CAEA,SAAS,GAAe,CAAK,EAC3B,OAAO,GAAS,GAAO,WAAW,EACpC,CAEA,SAAS,GAAY,CAAK,EAExB,OADW,AACJ,GADa,GAAO,WAAW,IACzB,SACf,CAEA,SAAS,GAAiB,CAAK,EAC7B,OAAO,GAAS,GACb,WAAW,GACX,OAAO,CAAC,cAAe,KACvB,OAAO,CAAC,WAAY,GACzB,CAEA,SAAS,GAAS,CAAK,EACrB,IAAM,EAAY,IAAI,KAAK,GAAS,IAAI,OAAO,GAC/C,OAAO,OAAO,KAAK,CAAC,GAAa,KAAO,CAC1C,CAEA,SAAS,GAAgB,CAAI,CAAE,GAAgB,CAAK,EAClD,IAAM,EAAM,GAAc,QAAQ,GAAG,CAAC,EAAK,SAC3C,AAAK,EAGU,EAHX,CAAM,MAGH,GAA0B,MAAR,GAAe,AAAQ,UAFvC,CAGX,CAEA,SAAS,GAAgB,CAAI,CAAE,CAAa,CAAE,KAAE,EAAM,CAAC,KAAE,EAAM,OAAO,gBAAgB,CAAE,CAAG,CAAC,CAAC,EAC3F,IAAM,EAAS,OAAO,QAAQ,CAAC,GAAS,QAAQ,GAAG,CAAC,EAAK,EAAG,WAC5D,AAAK,IAAD,GAAQ,QAAQ,CAAC,GAGd,KAAK,CAHkB,EAGf,CAAC,EAAK,KAAK,GAAG,CAAC,EAAK,IAF1B,CAGX,CAEA,SAAS,GAAiB,CAAK,EAC7B,IAAM,EAAM,GAAS,UACrB,AAAK,EAGD,EAAI,AAHJ,CAAM,SAGQ,CAAC,YAAc,EAAI,UAAU,CAAC,YACvC,CADoD,CAChD,OAAO,CAAC,OAAQ,IAEtB,CAAC,QAAQ,EAAE,EAAI,OAAO,CAAC,OAAQ,IAAI,OAAO,CAAC,OAAQ,IAAA,CAAK,CALtD,EAMX,CAsCA,SAAS,WACP,AAAK,CAAA,EAAA,CAAD,CAAC,kBAAA,AAAkB,IAGhB,CAHoB,AAGpB,EAAA,EAAA,cAAA,AAAc,IAFZ,IAGX,CAEA,SAAS,KACP,MAAO,CACL,QAAS,GAAgB,mBAAoB,IAC7C,qBAAsB,GAAgB,kCAAmC,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,GAC9F,yBAA0B,GAAgB,uCAAwC,GAAI,CAAE,IAAK,EAAG,IAAK,GAAI,GACzG,0BAA2B,GAAgB,uCAAwC,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,GACxG,8BAA+B,GAAgB,4CAA6C,GAAI,CAAE,IAAK,EAAG,IAAK,GAAI,GACnH,qBAAsB,GAAgB,kCAAmC,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,GAC9F,yBAA0B,GAAgB,uCAAwC,GAAI,CAAE,IAAK,EAAG,IAAK,GAAI,GACzG,wBAAyB,GAAgB,sCAAuC,GAAI,CAAE,IAAK,EAAG,IAAK,EAAG,GACtG,4BAA6B,GAAgB,2CAA4C,GAAI,CAAE,IAAK,EAAG,IAAK,GAAI,GAChH,0BAA2B,GAAgB,uCAAwC,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,GACxG,8BAA+B,GAAgB,4CAA6C,GAAI,CAAE,IAAK,EAAG,IAAK,GAAI,GACnH,8BAA+B,GAAgB,qCAAsC,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,GAC1G,kCAAmC,GAAgB,0CAA2C,GAAI,CAAE,IAAK,EAAG,IAAK,GAAI,GACrH,oBAAqB,GAAgB,iCAAkC,GAAI,CAAE,IAAK,EAAG,IAAK,GAAI,GAC9F,sBAAuB,GAAgB,mCAAoC,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,GAChG,mBAAoB,GAAgB,gCAAiC,EAAG,CAAE,IAAK,EAAG,IAAK,GAAI,GAC3F,sBAAuB,GAAgB,mCAAoC,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,GAChG,wBAAyB,GAAgB,qCAAsC,GAAI,CAAE,IAAK,EAAG,IAAK,GAAI,GACtG,kBAAmB,GAAgB,0BAA2B,GAAI,CAAE,IAAK,EAAG,IAAK,GAAI,GACrF,iBAAkB,GAAe,QAAQ,GAAG,CAAC,2BAA2B,GAAK,GAC7E,WAjEJ,AAiEgB,SAjEP,EACP,IAAM,EAAa,GAAiB,QAAQ,GAAG,CAAC,iBAAiB,EACjE,GAAI,EACF,OAAO,EAGT,CAJgB,GAIV,EAAgB,GAAiB,QAAQ,GAAG,CAAC,mBAAmB,EACtE,GAAI,EACF,OAAO,EAGT,IAJmB,AAIb,EAAqB,GACzB,eAAA,4BAEF,GAAI,AAF8C,EAGhD,MAHwD,CAGjD,EAGT,AAN6D,CAAC,GAMxD,EAAY,GAChB,AALsB,QAKd,GAAG,CAPqE,AAOpE,6BAA6B,EAAI,QAAQ,GAAG,CAAC,UAAU,SAErE,AAAI,GAIG,EACT,IAwCI,EA7Ca,WA6CC,GAAgB,yBAA0B,IACxD,eAAgB,GAAgB,4BAA6B,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,GAClF,iBAAkB,GAAgB,8BAA+B,EAAG,CAAE,IAAK,EAAG,IAAK,EAAG,GACtF,wBAAyB,GAAgB,sCAAuC,GAAI,CAClF,IAAK,EACL,IAAK,IACP,GACA,uBAAwB,GAAgB,qCAAsC,KAAM,CAClF,IAAK,GACL,IAAK,KACP,AADY,GAEZ,oBAhDK,CAgDgB,EAhDP,QAAQ,GAAG,CAAC,mCAAmC,CAAE,wBAiD/D,yBA7CK,CA6CqB,EA7CZ,QAAQ,GAAG,CAAC,yCAAyC,CAAE,uBA8CvE,CACF,CAEA,SAAS,GAAmB,CAAM,CAAE,CAAa,CAAE,CAAQ,EACzD,IAAM,EAAS,EAAgB,EAC/B,OAAO,EAAO,MAAM,CAAC,AAAC,GAAU,GAAS,GAAQ,KAAK,CAAC,CAAC,IAC1D,CAEA,SAAS,GAAuB,CAAG,CAAE,CAAW,CAAE,CAAQ,EACxD,IAAM,EAAgB,GAAS,GAC/B,GAAI,CAAC,EACH,OAAO,EAET,IAHoB,AAGd,EAAgB,OAAO,QAAQ,CAAC,GAAe,EAAc,KAAK,GAAG,GAErE,EAAS,GADE,GAAsB,GAAG,CAAC,IAAkB,EAAE,CACnB,EAAV,AAAyB,GAG3D,OAFA,EAAO,IAAI,CAAC,GACZ,GAAsB,GAAG,CAAC,EAAe,GAClC,EAAO,MAAM,AACtB,CAEA,SAAS,GAAgB,CAAG,CAAE,CAAW,CAAE,CAAQ,EACjD,IAAM,EAAgB,GAAS,GAC/B,GAAI,CAAC,EACH,OAAO,EAET,IAHoB,AAGd,EAAgB,OAAO,QAAQ,CAAC,GAAe,EAAc,KAAK,GAAG,GAErE,EAAS,GADE,GAAsB,GAAG,CAAC,IAAkB,EAAE,CACnB,EAAV,AAAyB,GAE3D,OADA,GAAsB,GAAG,CAAC,EAAe,GAClC,EAAO,MAAM,AACtB,CAiBA,SAAS,GAAyB,CAAW,CAAE,CAAK,CAAE,CAAO,EAC3D,IAAM,EAA4C,GAApC,KAAK,GAAG,CAAC,EAAG,OAAO,GAAW,IAAW,IACvD,GAAwB,GAAG,CAAC,EAAa,EAAQ,EACnD,CA6CA,SAAS,GAA2B,CAAK,EACvC,IAAM,EAAW,GAAS,GAAO,UACjC,MAAO,CACL,GAAI,GAAS,GAAO,WAAY,MAChC,aAAc,GAAS,GAAO,aAAc,YAC5C,OAAQ,GAAS,GAAO,OAAQ,UAChC,cAAe,GAAS,GAAO,IAC/B,SAAU,GAAS,EAAS,QAAQ,EAAI,GAAO,UAC/C,YAAa,GAAS,EAAS,WAAW,EAAI,GAAO,aACrD,cAAe,GAAS,EAAS,aAAa,EAAI,GAAO,eACzD,WAAY,GAAe,GAAO,aAClC,oBAAqB,GAAe,EAAS,mBAAmB,EAAI,EAAS,aAAa,EAAI,EAAS,qBAAqB,CAC9H,CACF,CAEA,SAAS,GAAe,CAAY,CAAE,CAAa,CAAE,CAAS,EAC5D,IAAM,EAAW,GAAc,SAC/B,AAAiB,YAAY,CAAzB,GAIA,GAAiB,AAAgB,EADf,CACkB,IADb,GAAG,CAAC,EAAG,OAAO,GAAa,KAIrC,QAAQ,CAArB,EANK,OASF,KACT,CAsBA,SAAS,GAAe,CAAM,EAC5B,MAAO,AAAW,cAAuB,aAAX,CAChC,CAEA,SAAS,GAAuB,CAAK,CAAE,CAAO,CAAE,CAAM,EACpD,GAAI,CAAC,EAAQ,UAAU,CAAC,QAAQ,CAAC,mBAAqB,CAAC,GAAe,EAAQ,MAAM,EAClF,CADqF,MAC9E,KAIT,IAAM,EAAQ,GADF,CAAC,UAAU,EAAE,EAAQ,KAE/B,GAFuC,EAAI,EAAQ,UAAU,EAAI,UAAA,CAAW,CAG5E,EAAQ,YAAY,CACc,GAAlC,EAAO,wBAAwB,CAAQ,YAErC,AAAJ,EAAY,EAAO,oBAAoB,CAC9B,CADgC,IAKlC,CACL,OAAQ,mBACR,aAAc,wBACd,SAJe,GAAe,OAAQ,EAAO,EAAO,oBAAoB,EAKxE,uBAAuB,EACvB,cAAe,EACf,cAAe,EAAO,wBAAwB,CAC9C,sBAAuB,EAAQ,UAAU,CACzC,MAAO,4CACP,QAAS,CAAC,SAAS,EAAE,EAAM,4CAA4C,EAAE,EAAQ,QAAQ,CAAC,QAAQ,EAAE,EAAO,wBAAwB,CAAC,WAAW,CAAC,CAChJ,KAAM,CAAC,iBAAkB,cAAe,MAAM,AAChD,CACF,CAEA,SAAS,GAA4B,CAAK,CAAE,CAAO,CAAE,CAAM,EAOzD,GAAI,CAAC,CALH,GAAe,EAAQ,MAAM,IAC5B,CAAD,EAA2B,CAIJ,EAJO,CAAC,EAAQ,MAAM,GAC3C,EAAQ,YAAY,CAAC,QAAQ,CAAC,eAC9B,EAAQ,YAAY,CAAC,QAAQ,CAAC,cAC9B,EAAQ,YAAY,CAAC,QAAQ,CAAC,YAAA,CAAY,EAE5C,OAAO,KAIT,IAAM,EAAQ,GADF,CAAC,kBAAkB,CAE7B,CAF+B,EAAQ,UAAU,EAAI,EAAQ,QAAQ,EAAI,UAAA,CAAW,CAGpF,EAAQ,YAAY,CACmB,GAAvC,EAAO,6BAA6B,CAAQ,KAE9C,GAAI,EAAQ,EAAO,yBAAyB,CAC1C,CAD4C,MACrC,KAGT,IAAM,EACJ,EAAQ,UAAU,CAAC,QAAQ,CAAC,qBAC5B,EAAQ,UAAU,CAAC,QAAQ,CAAC,gBAC5B,EAAQ,UAAU,CAAC,QAAQ,CAAC,cAE9B,MAAO,CACL,OAAQ,8BACR,aAAc,sBACd,SAJe,GAAe,EAAY,OAAS,MAAO,EAAO,EAAO,yBAAyB,EAKjG,sBAAuB,EACvB,cAAe,EACf,cAAe,EAAO,6BAA6B,CACnD,sBAAuB,EAAQ,mBAAmB,EAAI,EAAQ,UAAU,CACxE,MAAO,iDACP,QAAS,CAAC,SAAS,EAAE,EAAM,wCAAwC,EAAE,EAAQ,UAAU,EAAI,UAAU,QAAQ,EAAE,EAAO,6BAA6B,CAAC,WAAW,CAAC,CAChK,KAAM,CAAC,gBAAiB,OAAQ,kBAAmB,MACrD,AAD2D,CAE7D,CAEA,SAAS,GAAkB,CAAK,CAAE,CAAO,CAAE,CAAM,EAK/C,GAAI,CAAC,CAHH,EAAQ,UAAU,CAAC,IAGE,IAHM,CAAC,WAC5B,EAAQ,WAAW,CAAC,QAAQ,CAAC,sBAC7B,EAAQ,YAAY,CAAC,QAAQ,CAAC,SAAA,GAKP,aAAnB,EAAQ,MAAM,EAAsC,WAAW,GAA9B,AAAiC,EAAzB,MAAM,CAHnD,OAAO,KAQT,IAAM,EAAQ,GADF,CAAC,aAAa,EAAE,EAAQ,EAElC,QAF4C,EAAI,EAAQ,QAAQ,EAAI,UAAA,CAAW,CAG/E,EAAQ,YAAY,CACc,GAAlC,EAAO,wBAAwB,CAAQ,YAEzC,AAAI,EAAQ,EAAO,oBAAoB,CAC9B,CADgC,IAKlC,CACL,OAAQ,uBACR,aAAc,gBACd,SAJe,GAAe,OAAQ,EAAO,EAAO,oBAAoB,EAKxE,uBAAuB,EACvB,cAAe,EACf,cAAe,EAAO,wBAAwB,CAC9C,sBAAuB,EAAQ,mBAAmB,EAAI,GACtD,MAAO,gCACP,QAAS,CAAC,SAAS,EAAE,EAAM,2BAA2B,EAAE,EAAQ,UAAU,EAAI,EAAQ,QAAQ,CAAC,QAAQ,EAAE,EAAO,wBAAwB,CAAC,WAAW,CAAC,CACrJ,KAAM,CAAC,SAAU,MAAO,MAAM,AAChC,CACF,CAEA,SAAS,GAAqB,CAAK,CAAE,CAAO,CAAE,CAAM,EAClD,IAAM,EAAuB,EAAQ,YAAY,CAAC,QAAQ,CAAC,SAAW,EAAQ,YAAY,CAAC,QAAQ,CAAC,QASpG,GAAI,CAAC,CAPH,EAAQ,UAAU,CAAC,QAAQ,CAAC,GAOC,kBAN7B,GACA,GAAe,EAAQ,MAAM,IAC5B,CAAD,EAA2B,GAAG,CAAC,EAAQ,MAAM,GAC3C,EAAQ,YAAY,CAAC,QAAQ,CAAC,eAC9B,EAAQ,YAAY,CAAC,QAAQ,CAAC,cAC9B,EAAQ,YAAY,CAAC,QAAQ,CAAC,YAAA,CAAY,EAE5C,OAAO,KAIT,IAAM,EAAQ,GADF,CAAC,mBAEX,MAFoC,EAAE,EAAQ,UAAU,EAAI,EAAQ,QAAQ,EAAI,UAAA,CAAW,CAG3F,EAAQ,YAAY,CACiB,GAArC,EAAO,2BAA2B,CAAQ,YAExC,AAAJ,EAAY,EAAO,uBAAuB,CACjC,CADmC,IAKrC,CACL,OAAQ,iCACR,aAAc,sBACd,SAJe,GAAe,OAAQ,EAAO,EAAO,uBAAuB,EAK3E,uBAAuB,EACvB,cAAe,EACf,cAAe,EAAO,2BAA2B,CACjD,sBAAuB,EAAQ,mBAAmB,EAAI,GACtD,MAAO,sDACP,QAAS,CAAC,SAAS,EAAE,EAAM,6CAA6C,EAAE,EAAO,2BAA2B,CAAC,WAAW,CAAC,CACzH,KAAM,CAAC,gBAAiB,mBAAoB,MAAO,MAAM,AAC3D,CACF,CAEA,SAAS,GAA8B,CAAK,CAAE,CAAO,CAAE,CAAM,EAC3D,IAAM,EAAyB,EAAQ,UAAU,CAAC,QAAQ,CAAC,mBAAqB,EAAQ,WAAW,CAAC,QAAQ,CAAC,cACvG,EACJ,GAAe,EAAQ,MAAM,IAC5B,CAAD,EAA8B,GAAG,CAAC,EAAQ,MAAM,GAC9C,EAAQ,YAAY,CAAC,QAAQ,CAAC,qBAC9B,EAAQ,YAAY,CAAC,QAAQ,CAAC,qBAC9B,EAAQ,YAAY,CAAC,QAAQ,CAAC,WAAA,CAAW,CAC7C,GAAI,CAAC,AAAC,IAA0B,CAAA,CAAuB,CACrD,EADwD,KACjD,KAIT,IAAM,EAAQ,GADF,CAAC,kBAAkB,CAE7B,CAF+B,EAAQ,UAAU,EAAI,EAAQ,QAAQ,EAAI,UAAA,CAAW,CAGpF,EAAQ,YAAY,CACmB,GAAvC,EAAO,6BAA6B,CAAQ,YAE1C,AAAJ,EAAY,EAAO,yBAAyB,CACnC,CADqC,IAKvC,CACL,OAAQ,4BACR,aAAc,sBACd,SAJe,GAAe,OAAQ,EAAO,EAAO,yBAAyB,EAK7E,uBAAuB,EACvB,cAAe,EACf,cAAe,EAAO,6BAA6B,CACnD,sBAAuB,EAAQ,UAAU,EAAI,EAAQ,mBAAmB,CACxE,MAAO,uDACP,QAAS,CAAC,SAAS,EAAE,EAAM,oEAAoE,EAAE,EAAQ,UAAU,EAAI,UAAU,QAAQ,EAAE,EAAO,6BAA6B,CAAC,WAAW,CAAC,CAC5L,KAAM,CAAC,iBAAkB,cAAe,iBAAkB,MAC5D,AADkE,CAEpE,CAEA,SAAS,GAAoC,CAAK,CAAE,CAAO,CAAE,CAAM,EAKjE,GAAI,CAAC,CAHH,EAAQ,UAAU,CAAC,QAAQ,CAAC,GAGC,iBAF7B,EAAQ,YAAY,CAAC,QAAQ,CAAC,kBACV,CAApB,YAAC,EAAQ,MAAM,EAAsC,cAAnB,EAAQ,MAAM,AAAK,CAAW,GAI9D,CAAC,EAAQ,UAAU,EAAI,CAAC,GAAqB,GAAG,CAAC,EAAQ,UAAU,EAFrE,CAEwE,MAFjE,KAOT,IAAM,EAAQ,GADF,CAAC,mBAEX,EAFgC,EAAE,EAAQ,UAAU,EAAI,UAAU,CAAC,EAAE,EAAQ,UAAU,CAAA,CAAE,CAGzF,EAAQ,YAAY,CACpB,AAA2C,KAApC,iCAAiC,CAAQ,YAElD,AAAI,EAAQ,EAAO,6BAA6B,CACvC,CADyC,IAK3C,CACL,OAAQ,mCACR,aAAc,mBACd,SAJe,GAAe,OAAQ,EAAO,EAAO,6BAA6B,EAKjF,uBAAuB,EACvB,cAAe,EACf,cAAe,EAAO,iCAAiC,CACvD,sBAAuB,EAAQ,mBAAmB,EAAI,GACtD,MAAO,4CACP,QAAS,CAAC,SAAS,EAAE,EAAM,8BAA8B,EAAE,EAAQ,UAAU,CAAC,KAAK,EAAE,EAAQ,UAAU,EAAI,UAAU,QAAQ,EAAE,EAAO,iCAAiC,CAAC,WAAW,CAAC,CACpL,KAAM,CAAC,OAAQ,kBAAmB,YAAa,MAAM,AACvD,CACF,CAEA,SAAS,GAAsB,CAAK,CAAE,CAAO,CAAE,CAAM,EACnD,IAAM,EAAwC,GAA7B,EAAO,mBAAmB,CAAQ,IAC7C,EAAW,EAAQ,UAAU,EAAI,EAAQ,QAAQ,EAAI,SAQvD,EALF,EAAQ,UAAU,CAAC,IAKE,IALM,CAAC,WAC5B,EAAQ,WAAW,CAAC,QAAQ,CAAC,sBAC7B,EAAQ,YAAY,CAAC,QAAQ,CAAC,SAAA,GAET,CAAmB,eAAX,MAAM,EAAsC,cAAnB,EAAQ,MAAM,AAAK,CAAW,EAEpF,GAAuB,CAAC,cAAc,EAAE,EAAA,CAAU,CAAE,EAAQ,YAAY,CAAE,GAIlD,AAItB,WAAW,GAJb,EAAQ,WAAW,EACnB,EAAQ,UAAU,CAAC,QAAQ,CAAC,sBAC3B,CAAD,CAAS,YAAY,CAAC,QAAQ,CAAC,SAAW,EAAQ,YAAY,CAAC,QAAQ,CAAC,OAAA,CAAO,EAC9E,CAAmB,EAApB,cAAS,MAAM,EAAuC,aAAnB,EAAQ,MAAM,AAAK,CAAU,EAEhE,GAAuB,CAAC,WAAW,EAAE,EAAA,CAAU,CAAE,EAAQ,YAAY,CAAE,GAIvE,AAKE,GALa,EAAQ,MAAM,IAC5B,CAAD,EAA2B,EAIL,CAJQ,CAAC,EAAQ,MAAM,GAC3C,EAAQ,YAAY,CAAC,QAAQ,CAAC,eAC9B,EAAQ,YAAY,CAAC,QAAQ,CAAC,cAC9B,EAAQ,YAAY,CAAC,QAAQ,CAAC,YAAA,CAAY,EAE5C,GAAuB,CAAC,cAAc,EAAE,EAAA,CAAU,CAAE,EAAQ,YAAY,CAAE,GAG5E,IAAM,EAAc,GAAgB,CAAC,cAAc,EAAE,EAAA,CAAU,CAAE,EAAQ,YAAY,CAAE,GACjF,EAAW,GAAgB,CAAC,WAAW,EAAE,EAAA,CAAU,CAAE,EAAQ,YAAY,CAAE,GAC3E,EAAc,GAAgB,CAAC,cAAc,EAAE,EAAA,CAAU,CAAE,EAAQ,YAAY,CAAE,GAEjF,EAAc,GAAe,EAAO,qBAAqB,CACzD,EAAW,GAAY,EAAO,kBAAkB,CAChD,EAAc,EAAO,qBAAqB,EAAI,GAAK,GAAe,EAAO,qBAAqB,QACpG,AAAM,GAAe,CAAjB,CAAC,CAA4B,EAK1B,CACL,OAAQ,CANkC,GAAG,sBAO7C,aAAc,gBACd,SAJe,GAAe,OAAQ,EAAc,EAAW,EAAa,KAAK,GAAG,CAAC,EAAG,EAAO,qBAAqB,GAKpH,sBAAuB,GACvB,cAAe,EAAc,EAAW,EACxC,cAAe,EAAO,mBAAmB,CACzC,sBAAuB,EAAQ,mBAAmB,EAAI,EAAQ,UAAU,CACxE,MAAO,uCACP,QAAS,CAAC,SAAS,EAAE,EAAY,mBAAmB,EAAE,EAAS,0BAA0B,EAAE,EAAY,sBAAsB,EAAE,EAAS,QAAQ,EAAE,EAAO,mBAAmB,CAAC,WAAW,CAAC,CACzL,KAAM,CAAC,gBAAiB,SAAU,MAAO,MAAM,AACjD,EAfS,IAgBX,CAiCA,SAAS,GAAgB,CAAK,EAC5B,OAAO,GAAS,GACb,KAAK,CAAC,KACN,GAAG,CAAC,AAAC,GAAS,GAAe,IAC7B,MAAM,CAAC,QACZ,CAEA,SAAS,GAAkB,CAAK,CAAE,CAAS,EACzC,IAAM,EACJ,GAAe,QAAQ,GAAG,CAAC,oBAAoB,GAC/C,GAAgB,QAAQ,GAAG,CAAC,UAAU,CAAC,CAAC,EAAE,EAC1C,GAAgB,QAAQ,GAAG,CAAC,kBAAkB,CAAC,CAAC,EAAE,QACpD,AAAI,GAGG,GAAe,GAAW,OAHb,gBAGsC,GAAO,UAAU,YAAc,GAAO,aAAe,GACjH,CAEA,eAAe,GAAuB,CAAK,CAAE,CAAS,CAAE,CAAQ,CAAE,CAAM,EACtE,IAAM,EAAQ,GAAkB,EAAO,IAAc,GAAe,GAAU,YAS9E,MAAO,AADgC,CD9KlC,SAAS,AAAoC,EAAqB,EAAE,EACzE,OAAO,EAA+B,GACxC,ECqKmB,MAAM,AAOoD,EAPf,CAC1D,WAAY,EACZ,sBAAuB,GAAe,GAAW,uBACjD,WAAY,GAAe,GAAO,aAClC,yBAAyB,EACzB,aAAc,EAChB,IAEsC,KAAK,CAAC,EAAG,EAAO,iBAAiB,CACzE,CAqBA,SAAS,GAAqB,CAAO,CAAE,CAAM,EAC3C,IAAM,EAAc,KAAK,GAAG,CAAC,EAAG,OAAO,GAAW,IAC5C,EAAc,KAAK,GAAG,CAAC,EAAG,OAAO,GAAQ,yBAA2B,KAE1E,OAAO,KAAK,GAAG,CADI,AACH,KADQ,GAAG,CAAC,EAAa,OAAO,GAAQ,wBAA0B,OACtD,EAAc,KAAK,GAAG,CAAC,EAAG,KAAK,GAAG,CAAC,EAAG,EAAc,IAClF,CAgCA,eAAe,GAA8B,OAC3C,CAAK,WACL,CAAS,aACT,CAAW,gBACX,CAAc,cACd,CAAY,CACZ,QAAM,UACN,EAAW,CAAC,QACZ,EAAS,MAAM,CAChB,EACC,GAAI,CAAC,GAAQ,aACX,CADyB,KAClB,CACL,OAAQ,GACR,OAAQ,gBACV,EAGF,IAAM,EAAK,KACX,GAAI,CAAC,EACH,EADO,IACA,CACL,QAAQ,EACR,OAAQ,yBACV,EAIF,IAAM,EAAU,AAxDlB,SAAS,AAAqB,OAC5B,CAAK,WACL,CAAS,aACT,CAAW,gBACX,CAAc,cACd,CAAY,QACZ,CAAM,UACN,EAAW,CAAC,QACZ,EAAS,MAAM,aACf,EAAc,IAAQ,CACvB,EACC,IAAM,EAAe,KAAK,GAAG,CAAC,EAAG,OAAO,GAAY,IAC9C,EAAe,GAAqB,EAAc,GAClD,EAAgB,IAAI,KAAK,KAAK,GAAG,GAAoB,IAAf,GAAqB,WAAW,GAC5E,MAAO,CACL,OAAQ,UACR,OAAQ,GAAS,EAAQ,QACzB,SAAU,EACV,YAAa,KAAK,GAAG,CAAC,EAAG,OAAO,GAAQ,kBAAoB,kBAC5D,EACA,UAAW,GAAS,EAAc,yBAClC,YAAa,GAAS,GACtB,eAAgB,GAAS,GACzB,MAAO,GAAS,GAChB,UAAW,GAAS,GACpB,UAAW,EACX,UAAW,CACb,CACF,EA4BuC,OACnC,YACA,cACA,EACA,8BACA,SACA,WACA,SACA,EACA,YAVU,CAUG,GACf,GAEA,MAAO,CACL,QAAQ,EACR,cAAe,CAHL,MAAM,CAAA,EAAA,EAAA,MAAA,AAAM,EAAC,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAI,EAAO,mBAAmB,EAAG,EAAA,EAGhD,EAAE,CACrB,SAAU,EAAQ,QAAQ,CAC1B,cAAe,EAAQ,aAAa,AACtC,CACF,CAEA,eAAe,GAAyB,CAAM,CAAE,WAAE,CAAS,CAAE,CAAG,CAAC,CAAC,EAChE,IAAM,EAAK,KACX,GAAI,CAAC,EACH,EADO,IACA,EAAE,CAGX,IAAM,EAAa,KAAK,GAAG,CAAC,EAAG,OAAO,GAAa,GAAQ,gBAAkB,IACvE,EAAY,KAAK,GAAG,CAAc,EAAb,EAAgB,IACrC,EAAW,MAAM,CAAA,EAAA,EAAA,OAAA,AAAO,EAC5B,CAAA,EAAA,EAAA,KAAA,AAAK,EACH,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAI,EAAO,mBAAmB,EACzC,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,gBAAiB,OACzB,CAAA,EAAA,EAAA,KAAA,AAAU,EAAC,KAGT,EAAQ,KAAK,GAAG,GACtB,OAAO,EAAS,IAAI,CACjB,GAAG,CAAC,AAAC,IAAiB,CACrB,GAAI,EAAY,EAAE,CAClB,CAFoB,EAEhB,EAAY,IAAI,IAAM,CAAC,CAAC,CAC9B,CAAC,EACA,MAAM,CAAC,AAAC,GAAoD,YAA5C,GAAc,GAAK,QAAU,YAC7C,MAAM,CAAC,AAAC,IACP,IAAM,EAAgB,GAAS,GAAK,eACpC,MAAO,CAAC,OAAO,QAAQ,CAAC,IAAkB,GAAiB,CAC7D,GACC,KAAK,CAAC,EAAG,EACd,CAEA,eAAe,GAA4B,CAAM,CAAE,CAAM,CAAE,CAAM,EAC/D,IAAM,EAAK,KACX,GAAI,CAAC,EACH,EADO,KACA,KAGT,IAAM,EAAU,CACd,GAAG,CAAM,CACT,OAAQ,cACR,eAAgB,KAChB,iBAAkB,GAAS,EAAQ,uBACnC,sBAAuB,GAAS,GAAQ,GAC1C,EAEA,MAAO,CADK,MAAM,CAAA,EAAA,EAAA,MAAA,AAAM,EAAC,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAI,EAAO,wBAAwB,EAAG,EAAA,EAC/D,EAAE,AACf,CAEA,eAAe,GAAuB,CAAM,CAAE,CAAQ,CAAE,CAAK,EAC3D,IAAM,EAAK,KACN,GAGL,CAHS,KAGH,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,CAAA,EAAA,EAAA,GAAA,AAAG,EAAC,EAAI,EAAO,mBAAmB,CAAE,GAAW,CAC7D,GAAG,CAAK,CACR,UAAW,IACb,EACF,CAEA,eAAe,GAAuB,CAAM,CAAE,CAAQ,EACpD,IAAM,EAAK,KACN,GAGL,CAHS,KAGH,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,CAAA,EAAA,EAAA,GAAA,AAAG,EAAC,EAAI,EAAO,mBAAmB,CAAE,GACtD,CAEA,eAAe,GAA0B,gBAAE,CAAc,aAAE,CAAW,OAAE,CAAK,QAAE,CAAM,CAAE,EACrF,IAAI,EAAO,EAAE,CACb,GAAI,CACF,EAAO,MAAM,GACf,CAAE,KAAM,CACN,EAAO,EACT,AADW,CAGX,IAAM,EAAmB,GAAQ,GAAM,IAAI,CAAC,AAAC,IAC3C,GA/jBM,CAAC,AA+jBH,CAAC,UA/jBc,SAAS,CAAC,QAAQ,CAAC,AALjC,GAokB+B,GAAK,QApkBf,CAokBwB,AApkB/B,MAAc,CAAC,OAAQ,MAqkBxC,OAAO,EAET,IAAM,EAAwB,GAAS,GAAK,yBAC5C,GAAI,GAAyB,IAA0B,EACrD,OAAO,EAET,IAAM,CAHiE,CAG5C,GAAS,GAAK,sBACzC,MAAO,GAAQ,GAAsB,IAAuB,CAAA,CAC9D,UACA,AAAI,KA5nBN,AAgoBM,SAhoBG,AAAqB,CAAW,CAAE,CAAK,CA4nBxB,CApoBtB,IAAM,EAAU,OAAO,QAAQ,CAAC,GASR,EATyB,IAAR,CAAa,GAAG,GACzD,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,GAAwB,OAAO,GAAI,CACxD,CAAC,OAAO,QAAQ,CAAC,IAAU,GAAS,CAAA,GAAS,AAC/C,GAAwB,MAAM,CAAC,GAOnC,IAAM,EAAY,GAAwB,GAAG,CAAC,GAC9C,OAAO,OAAO,QAAQ,CAAC,IAAc,EAAY,CACnD,EA4nB2B,EAAa,GAI/B,KAJuC,AACrC,CAAE,GAAI,GAAI,eAAe,CAAK,EAIzC,CAEA,eAAe,GAA2B,CACxC,UAAQ,OACR,CAAK,WACL,CAAS,gBACT,CAAc,CACd,aAAW,OACX,CAAK,CACL,QAAM,CACP,EACC,GAAI,CAAC,GAAU,GACb,CADiB,MACV,KAET,IAAM,EAAY,KAAK,GAAG,CAAC,EAAG,OAAO,GAAU,sBAAwB,IAAM,EAEvE,EAAkB,IADI,GAAQ,GAAU,kBAAkB,KAAK,CAAC,CAAC,IACtB,GAA2B,GAAO,CAC7E,EAAe,CACnB,qBAAsB,GAAS,GAAU,sBAAwB,GACjE,wBAAyB,GAAS,GAAU,yBAA2B,GACvE,mBAAoB,IAAI,KAAK,GAAO,WAAW,GAC/C,iBAAkB,EAAU,OAAO,CACnC,qBAAsB,EACtB,qBAAsB,GAAS,GAAU,sBAAwB,GAAU,YAAc,MACzF,oBAAqB,GAAS,GAAO,WAAY,MACjD,iBAAkB,EAClB,QAAS,EAAU,OAAO,CAC1B,MAAO,CACL,GAAS,GAAU,OACnB,CAAC,yBAAyB,EAAE,EAAU,EAAE,EAAE,GAAS,GAAO,aAAc,YAAY,GAAG,EAAE,GAAS,GAAO,OAAQ,UAAU,GAAG,EAAE,GAAS,GAAO,WAAY,MAAU,cAAc,EAAE,GAAS,GAAO,UAAU,UAAY,GAAO,SAAU,WAAA,CAAY,CAC1P,CACE,MAAM,CAAC,SACP,IAAI,CAAC,KACV,EAEM,EAAU,MAAM,EAA4B,EAAS,EAAE,CAAE,EAAc,EAAO,gBAAgB,EAEpG,OADA,GAAyB,EAAa,EAAO,EAAO,uBAAuB,EACpE,CACT,CAEA,eAAe,GAAmB,CAAK,CAAE,CAAS,CAAE,CAAM,CAAE,CAAW,CAAE,CAAc,CAAE,CAAK,EAC5F,IAAM,EAAa,GAAS,GAAO,WAAY,MACzC,EAAa,GAAkB,EAAO,GACtC,EAAa,EAAO,gBAAgB,EAAI,GACxC,EAAiB,GAAS,GAAO,UACjC,EAAiB,GACrB,EAAe,mBAAmB,EAAI,EAAe,aAAa,EAAI,EAAU,qBAAqB,CACrG,IAEI,EAAc,GAAS,EAAe,aAAa,EAAI,EAAe,SAAS,EAAI,EAAe,QAAQ,CAAE,IAC5G,EAAe,GAAQ,EAAe,YAAY,CAAE,EAAE,EACtD,EAAoB,GAAQ,EAAe,iBAAiB,CAAE,EAAE,EAChE,EAAkB,GAAS,GAAO,WAAY,MAC9C,EAAkB,GAA2B,GAC7C,EAAU,CACd,MAAO,EAAU,KAAK,CACtB,QAAS,EAAU,OAAO,CAC1B,aAAc,EAAU,YAAY,CACpC,SAAU,EAAU,QAAQ,CAC5B,OAAQ,OACR,uBAAuB,CAAQ,EAAU,qBAAqB,CAC9D,sBAAuB,GAAe,EAAU,qBAAqB,EAAI,EAAe,mBAAmB,EAAI,eAC/G,EACA,WAAY,EACZ,mBAAoB,GACpB,kBAAmB,cACnB,uBAAwB,UACxB,gCAAgC,CAAQ,EAAU,qBAAqB,CACvE,uBAAuB,EACvB,uBAAwB,cACxB,MAAO,CACL,CAAC,iCAAiC,EAAE,EAAU,MAAM,CAAA,CAAE,CACtD,CAAC,gBAAgB,EAAE,OAAO,EAAU,aAAa,EAAI,GAAA,CAAI,CACzD,CAAC,QAAQ,EAAE,OAAO,EAAU,aAAa,EAAI,GAAG,UAAU,CAAC,CAC3D,EAAiB,CAAC,iBAAiB,EAAE,EAAA,CAAgB,CAAG,KACxD,EAAc,CAAC,kBAAkB,EAAE,EAAA,CAAa,CAAG,KACnD,EAAa,MAAM,CAAG,EAAI,CAAC,eAAe,EAAE,EAAa,KAAK,CAAC,EAAG,IAAI,IAAI,CAAC,MAAA,CAAO,CAAG,KACrF,EAAkB,MAAM,CAAG,EACvB,CAAC,oBAAoB,EAAE,EACpB,GAAG,CAAC,AAAC,GAAQ,GAAS,GAAK,MAAQ,GAAK,KAAO,GAAK,KACpD,MAAM,CAAC,SACP,KAAK,CAAC,EAAG,GACT,IAAI,CAAC,MAAA,CAAO,CACf,KACJ,CAAC,cAAc,EAAE,GAAS,GAAO,GAAI,OAAO,GAAG,EAAE,GAAS,GAAO,OAAQ,UAAU,GAAG,EAAE,GAAS,GAAO,aAAc,YAAA,CAAa,CACnI,CAAC,WAAW,EAAE,GAAS,EAAe,QAAQ,EAAI,GAAO,SAAU,WAAA,CAAY,CAC/E,CAAC,SAAS,EAAE,GAAS,EAAe,aAAa,EAAI,GAAO,cAAe,OAAO,CAAC,EAAE,GAAS,EAAe,WAAW,EAAI,GAAO,YAAa,WAAA,CAAY,CAC7J,CACE,MAAM,CAAC,SACP,IAAI,CAAC,MACR,cAAe,GACf,gBAAiB,EAAU,MAAM,CACjC,qBAAsB,EACtB,wBAAyB,EACzB,qBAAsB,IAAI,KAAK,EAAkC,GAA1B,EAAU,aAAa,CAAQ,KAAM,WAAW,GACvF,mBAAoB,IAAI,KAAK,GAAO,WAAW,GAC/C,iBAAkB,EAAU,OAAO,CACnC,qBAAsB,EACtB,qBAAsB,EACtB,oBAAqB,EACrB,iBAAkB,CAAC,EAAgB,CACnC,aAAc,WACd,cAAe,GAAS,GAAO,IAC/B,kBAAmB,GAAS,GAAO,QACnC,gBAAiB,GAAS,EAAe,WAAW,EAAI,GAAO,aAC/D,SAAU,GAAS,EAAe,QAAQ,EAAI,GAAO,UACrD,gBAAiB,EAAE,CACnB,UAAW,sBACb,EAEM,EAAU,MAAM,EAA4B,EAAS,GAE3D,OADA,GAAyB,EAAa,EAAO,EAAO,uBAAuB,EACpE,CACT,CAEA,eAAe,GAAiC,UAC9C,CAAQ,WACR,CAAS,YACT,CAAU,WACV,CAAS,YACT,CAAU,CACX,EACC,IAAM,EAAgB,EAAW,GAAG,CAAC,AAAC,YAhWhC,KAgWmD,GAAC,gBACxD,EACA,MAxWK,CAwWE,EAxWO,AAwWa,GAxWH,OAwWa,EAxWJ,CAAW,MAAO,6BAyWnD,OAAA,EArWI,AAqWK,EArWM,GAAS,GAAU,YAAY,CAAW,SAAU,UAC/D,EAAO,GAoWoB,GApWD,IAAV,SAAwB,cAC9B,GAAS,GAAU,SAmWQ,EAnWG,CAAW,QAAS,8CAC3D,CAAC,CAAC,EAAE,EAAS,EAAE,EAAE,EAAK,EAAE,EAAE,EAAA,CAAS,EAmWxC,SAAU,GAAc,GAAU,UAAY,GAAW,UAAY,UACrE,KAAM,mBACN,OAAQ,gCACR,EACA,OAAQ,SACR,UAAW,EACX,SAAU,CACR,WAAY,GAAS,GAAU,IAAM,GAAU,UAC/C,aAAc,GAAS,GAAU,cACjC,gBAAiB,GAAS,GAAW,QACrC,eAAe,CACjB,CACF,CAAC,GACD,OAAO,MAAM,EAA6B,EAC5C,CAEA,eAAe,GAAyB,OACtC,CAAK,WACL,CAAS,QACT,CAAM,aACN,CAAW,gBACX,CAAc,OACd,CAAK,CACN,QACC,MAhVM,EAgVA,EAAmB,MAAM,GAA0B,gBACvD,EACA,oBACA,SACA,CACF,GACA,GAAI,GAAkB,cACpB,CADmC,KAC5B,CACL,UAAU,EACV,WAAW,YACX,cACA,iBACA,CACF,EAEF,GAAI,GAAkB,GAAI,CACxB,IAAM,EAAkB,MAAM,GAA2B,CACvD,SAAU,QACV,YACA,iBACA,cACA,QACA,EACA,QACF,GACA,MAAO,CACL,UAAU,EACV,WAAW,EACX,cAAc,YACd,cACA,iBACA,EACA,eAAgB,GAAmB,CACrC,CACF,CAEA,IAAM,EAAW,MAAM,GAAmB,EAAO,EAAW,EAAQ,EAAa,EAAgB,GAC3F,EA7XN,CAD8B,EA8XW,CA7XrC,CAAC,CA6X8C,IAAjC,AAAuC,CA9XjB,EA8X2B,IA7XlD,MAGV,CAAC,CA0XyB,6BA1XK,EAAE,mBAAmB,GAAA,CAAa,CAF/D,uBA6XH,GAvXA,EAAO,GAuXoC,GAvXnB,IAAR,KAuXI,GAvXgB,OAAO,CAAC,OAAQ,IAE1D,AAAI,GADS,GAsX4C,EAtXvB,KAAZ,oBACb,UAAU,CAAC,YAAc,EAAK,UAAU,CAAC,YACzC,CADsD,CAG1D,EAGE,CAAA,EAAG,CAHC,CAGD,EAAO,EAAK,UAAU,CAAC,KAAO,EAAO,CAAC,CAAC,EAAE,EAAA,CAAM,CAAA,CAAE,CAFlD,EAAK,UAAU,CAAC,KAAO,EAAO,CAAC,CAAC,EAAE,EAAA,CAAM,EAkX3C,EAAa,MAAM,GAAuB,EAAO,EAAW,EAAU,GACtE,EAAqB,MAAM,GAAiC,UAChE,YACA,aACA,YACA,EACA,WAAY,EAAO,gBAAgB,AACrC,GACM,EAAkB,MAAM,GAA+B,CAC3D,SAAU,CACR,GAAG,CAAQ,CACX,UAAW,CACb,YACA,EACA,YAAa,EACb,gBAAiB,CACnB,GAEM,EAAe,CACnB,gBAAiB,EACjB,qBAAsB,EACtB,qBAAsB,CACpB,SAAU,GAAiB,UAAY,CAAC,CAC1C,EACA,oBAAqB,IACvB,EAGA,OAFA,MAAM,EAA4B,EAAS,EAAE,CAAE,EAAc,EAAO,gBAAgB,EAAE,KAAK,CAAC,IAAM,MAE3F,CACL,SAAU,GACV,WAAW,YACX,EACA,eAAgB,cAChB,aACA,EACA,uBAAwB,EAAmB,MAAM,iBACjD,CACF,CACF,CAMA,eAAe,GAA8B,CAAM,CAAE,CAAG,EACtD,IAAM,EAAW,GAAS,GAAK,IAC/B,GAAI,CAAC,EACH,MAAO,CAAE,CADI,SACO,GAAO,OAAQ,yBAA0B,EAG/D,IAAM,EAAW,KAAK,GAAG,CAAC,EAAG,OAAO,GAAK,UAAY,IAC/C,EAAc,KAAK,GAAG,CAAC,EAAG,OAAO,GAAK,aAAe,EAAO,gBAAgB,EAAI,IAChF,EAAQ,GAAS,GAAK,OACtB,EAAY,GAAS,GAAK,WAC1B,EAAc,GAAS,GAAK,aAC5B,EAAiB,GAAS,GAAK,gBACrC,GAAI,CAAC,GAAe,CAAC,GAAS,GAAW,SAAY,CAAC,GAAS,GAAO,eAAiB,CAAC,GAAS,GAAO,QAGtG,CAHgH,MAChH,MAAM,GAA4B,EAAQ,EAAK,yBAC/C,MAAM,GAAuB,EAAQ,GAC9B,CAAE,WAAW,EAAO,cAAc,EAAM,OAAQ,uBAAwB,EAGjF,IAAM,EAAS,MAAM,GAAuC,EAAO,CACjE,gBAAiB,EACjB,kBAAmB,EACnB,qBAAsB,EACtB,kBAAkB,EAClB,mBAAmB,CACrB,GAEA,GAAI,CAAC,GAAQ,OAEX,CAFmB,MACnB,MAAM,GAAuB,EAAQ,GAC9B,CACL,WAAW,EACX,WAAW,CAAQ,GAAQ,UAC3B,UAAU,CAAQ,GAAQ,QAC5B,EAGF,IAAM,EAAe,EAAW,EAC1B,EAAe,GAAS,GAAQ,MAAO,yBAC7C,GAAI,EAAe,EAQjB,OAPA,IAD8B,EACxB,GAA4B,EAAQ,CACxC,GAAG,CAAG,CACN,SAAU,cACV,EACA,UAAW,CACb,EAAG,GACH,MAAM,GAAuB,EAAQ,GAC9B,CACL,WAAW,EACX,cAAc,EACd,OAAQ,CACV,EAGF,IAAM,EAAgB,IAAI,KAAK,KAAK,GAAG,GAAkD,IAA7C,GAAqB,EAAc,IAAgB,WAAW,GAS1G,OARA,MAAM,GAAuB,EAAQ,EAAU,CAC7C,SAAU,cACV,gBACA,EACA,UAAW,EACX,OAAQ,SACV,GAEO,CACL,WAAW,EACX,QAAS,GACT,OAAQ,gBACR,CACF,CACF,CAEO,eAAe,GAAiC,QAAE,EAAS,QAAQ,WAAE,CAAS,CAAE,CAAG,CAAC,CAAC,EAC1F,IAAM,EAAS,KACf,GAAI,CAAC,EAAO,OAAO,EAAI,CAAC,EAAO,YAAY,CACzC,CAD2C,KACpC,CACL,eAAgB,EAChB,OAAS,AAAD,EAAQ,OAAO,CAAoB,iBAAjB,cAC5B,EAGF,GAAI,GACF,OAAO,GAGT,GAA0B,AAAC,SAJE,EAK3B,IAAM,EAAa,MAAM,GAAyB,EAAQ,CACxD,UAAW,OAAO,GAAa,EAAO,cAAc,EAAI,EAC1D,GACI,EAAiB,EACjB,EAAkB,EAClB,EAAc,EAElB,IAAK,IAAM,KAAO,EAChB,GAAI,CACF,IAAM,CAFoB,CAEX,MAAM,GAA8B,EAAQ,GACvD,GAAQ,WAAW,CACrB,GAAkB,GAEhB,GAAQ,cAAc,CACxB,IAAmB,CAEvB,CAAE,KAAM,CACN,GAAe,CACjB,CAGF,MAAO,CACL,OAAQ,GAAS,EAAQ,yBACzB,kBACA,cACA,EACA,SAAU,EAAW,MAAM,AAC7B,EACF,CAAC,GAED,GAAI,CACF,OAAO,MAAM,EACf,QAAU,CACR,GAA0B,IAC5B,CACF,CAEO,eAAe,GAAuC,CAAK,CAAE,EAAU,CAAC,CAAC,MA5H7C,IA90BwB,CA80BnB,CAr0BX,EAk8B3B,IAl5BM,AAhD2B,EAAE,AAR7B,GADgE,CAGhE,CAMkC,CALlC,CAKoC,SAAS,EAk8B7C,EAAS,KACf,GAAI,CAAC,EAAO,OAAO,CACjB,CADmB,KACZ,CACL,UAAU,EACV,OAAQ,cACV,EAGF,GAAI,CAAC,GAA0B,UAAjB,AAA2B,OAApB,EACnB,MAAO,CACL,UAAU,EACV,OAAQ,qBACV,CAGE,EAAC,GAAS,mBAAqB,EAAO,YAAY,EAAE,AACjD,GAAiC,CAAE,OAAQ,aAAc,GAAG,KAAK,CAAC,IAAM,MAG/E,IAAM,EA/IS,AA+IS,GAA0B,GAAS,kBA/InC,AAAiB,iBAAV,GAAsB,CAAC,MAAM,OAAO,CAAC,GAgJhE,EAAQ,eAAe,CACvB,KACJ,GAAI,CAAC,GAAmB,AAl/B1B,SAAS,AAAgB,CAAK,EAC5B,IAAM,EAAW,GAAS,GAAO,UACjC,GAAsC,KAAlC,EAAS,oBAAoB,GAAwC,IAA3B,EAAiC,AAAxB,aAAa,CAClE,OAAO,EAGT,IAAM,EAAa,GAAc,GAAO,QAClC,EAAc,GAAc,EAAS,WAAW,EAAI,GAAO,sBAC7D,EAAW,QAAQ,CAAC,wBAGpB,AAH4C,EAGhC,UAAU,CAAC,sBAI7B,CAJoD,CAu+BV,GACtC,KAD8C,CACvC,CACL,SAAU,GACV,OAAQ,eACV,EAGF,IAAM,KA/6BW,KA+6BD,CA/6BiB,IAAP,MACnB,CACL,WAAY,MAAsB,UAAP,GAC3B,OAAQ,MAAqB,QAC7B,CADsB,UACV,MAAqB,QACjC,CAD0B,YACZ,MAAqB,SAAP,KAC5B,OAAQ,GAAc,EAAS,MAAM,EACrC,YAAa,GAAc,EAAS,WAAW,IAAI,CAAO,aAC1D,cAAe,GAAc,EAAS,aAAa,IAAI,CAAO,eAC9D,SAAU,GAAY,EAAS,QAAQ,IAAI,CAAO,UAClD,YAAa,GAq6BqB,GAr6BA,SAAP,IAC3B,oBAAqB,GAAe,EAAS,mBAAmB,EAAI,EAAS,aAAa,EAAI,EAAS,qBAAqB,EAC5H,WAAY,GAAe,EAAS,UAAU,EAC9C,WAAY,GAAiB,EAAS,UAAU,EAAI,EAAS,YAAY,EAAI,IAC7E,UAAW,GAAiB,EAAS,SAAS,EAAI,EAAS,WAAW,EAAI,IAC1E,aAAc,MAAgB,IAAP,SAAsB,KAAK,GAAG,EACvD,GAg6BM,EAAY,GAjoBpB,AAioBuC,SAjoB9B,AAAsB,CAAK,CAAE,CAAO,CAAE,CAAM,EAWnD,IAAK,IAAM,IAVG,CACZ,GACA,EAQmB,CAPnB,GACA,GACA,GACA,GACA,GACD,CAE2B,CAC1B,IAAM,EAAQ,EAAO,EAAO,EAAS,GACrC,GAAI,EACF,KADS,EACF,CAEX,CACA,OAAO,IACT,EA+mB6D,EAAO,EAAS,GAC3E,GAAI,CAAC,EACH,MAAO,CACL,EAFY,QAEF,EACV,OAAQ,eACV,EAGF,IAAM,EAAQ,EAAQ,YAAY,EAAI,KAAK,GAAG,GACxC,EACJ,GAAS,GAAS,qBAn/BI,CAo/BtB,CACE,EAAU,EAr/BgB,EAAE,EAq/BZ,GAr/BiB,AAy/BjC,EAz/BmC,AAy/BzB,SAz/BkC,EAAE,EAy/BvB,EAAI,CAz/BwB,CAy/BjB,uBAAuB,GAx/B/C,MAAsB,UAAP,GACvB,EAAW,GAAY,GAAO,UAAU,YAAY,CAAO,YAC9C,GAm/Bf,AAn/B6B,GAAO,QAAU,MACnC,GAAe,AAm/B1B,GAn/BqC,yBAAyB,CAAO,UAAU,eAAiB,IAC9F,EAAS,KAAK,KAAK,CAm/BrB,AAn/BsB,GAAmD,GAA1C,EAAD,GAAM,GAAG,CAAC,EAAG,OAAO,GAAiB,IAAW,GAAA,CAAI,EAC/E,CAAC,GAAS,GAAS,GAAS,UAAW,EAAU,GAAc,SAAU,GAAU,OAAQ,EAAO,CAAC,IAAI,CAAC,MAq/BzG,EACJ,GAAS,GAAS,yBAAyB,CAAoB,EAAU,MAAM,CAl/B3E,EAAQ,MAAsB,UAAP,GACvB,EAAW,GAAY,GAAO,UAAU,UAi/BqC,EAj/BzB,CAAO,UAC3D,EAAa,GAAc,GAAO,QAAU,IAC5C,EAAS,GAAe,AA++B4D,GA/+BjD,yBAAyB,CAAO,UAAU,eAAiB,IAC7F,CAAC,GAAS,GAAS,GAAS,UAAW,EAAU,GAAc,SAAU,GAAU,OAAO,CAAC,IAAI,CAAC,MAg/BvG,GAAI,CACF,OAAO,MAAM,GAAyB,OACpC,YACA,SACA,cACA,iBACA,EACA,OACF,EACF,CAAE,MAAO,EAAO,CACd,IAAM,EAAe,aAAiB,MAAQ,GAAS,EAAM,OAAO,CAAE,yBAA2B,wBACjG,GAAI,GAAS,iBACX,CAD6B,KACtB,CACL,UAAU,EACV,WAAW,EACX,OAAQ,aACR,cACA,EACA,OAAQ,oBACR,MAAO,CACT,EAGF,IAAM,EAAc,MAAM,GAA8B,OACtD,YACA,cACA,iBACA,eACA,SACA,EACA,SAAU,EACV,OAAQ,MACV,GACA,MAAO,CACL,UAAU,EACV,WAAW,EACX,QAAQ,EACR,gBAAgB,CAAQ,GAAa,OACrC,cAAe,GAAS,GAAa,yBACrC,cACA,EACA,OAAQ,oBACR,MAAO,CACT,CACF,CACF"}